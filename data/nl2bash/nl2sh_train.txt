Do a dry run of renaming file extension '.andnav' to '.tile' for all files/directories under current directory tree
find . -name "*.andnav" | rename -vn "s/\.andnav$/.tile/"

Add "A new line" on top of each *.py files under current directory
perl -pi -e 'BEGIN { print "A new line" }' $(find . -name '*.py')

Add "Added line" on top of each *.py files under current directory
for a in `find . -name '*.py'` ; do cp "$a" "$a.cp" ; echo "Added line" > "$a" ; cat "$a.cp" >> "$a" ; rm "$a.cp" ; done

Add "execute" to the permissions of all directories in the home directory tree
find ~ -type d -exec chmod +x {} \;

Add "prefix" to every non-blank line in "file.txt"
nl -s prefix file.txt | cut -c7-

Add '.avi' extension to all files/directories with '.mkv' extension under '/volume1/uploads' directory tree
find /volume1/uploads -name "*.mkv" -exec mv \{\} \{\}.avi \;

all .jpg or .png images modified in the past week
find . -mtime -7 \( '*.jpg' -o -name '*.png' \)

Add a cron job to existing list, without removing existing ones, ro tun "scripty.sh" at 2:01 am, 3rd day of april (4th month), if that day happens to be a friday (5th day of the week starting with sunday=0).
cat <(crontab -l) <(echo "1 2 3 4 5 scripty.sh") | crontab -

Add a line number to every line in "infile"
nl -ba infile

Add a line number to every line in "long-file"
nl -ba long-file \

Add a number prefix followed by ')' to each line in "$string"
echo "$string" | nl -ba -s') '

Add a date time stamp to every line of output in "ping google.com"
ping google.com | xargs -L 1 -I '{}' date '+%c: {}'

Add content of "filename" to the existing cron jobs of user "user", without removing the previously existing cron jobs.
crontab -l -u user | cat - filename | crontab -u user -

Add cron lists from "file1" and "file2" to list of cron jobs, giving errors for any lines that cannot be parsed by crontab.
cat file1 file2 | crontab

Add cron lists from "filename" to list of cron jobs, giving errors for any lines that cannot be parsed by crontab.
crontab filename

Add executable permission to "java_ee_sdk-6u2-jdk-linux-x64.sh"
sudo chmod +x java_ee_sdk-6u2-jdk-linux-x64.sh

Add executable permission to "pretty-print"
chmod +x pretty-print

Add executable permission to "rr.sh"
chmod +x rr.sh

Add execute permission to all files ending in ".sh"
chmod +x *.sh

Add group write permission to all files and directories in the current directory including hidden files and excluding ".."
chmod g+w $(ls -1a | grep -v '^..$')

Add group write permission to all files and directories in the current directory including hidden files and excluding ".."
chmod g+w .[^.]* ..?*

Add group write permission to all files in the current directory
find . -maxdepth 0 -type f -exec chmod g+w {} ';'

Add group write permission to all files matching "*" or "...*"
chmod g+w * ...*

Add line numbers to each non-blank line in "file" starting with number 1000001
nl -v1000001 file

Add the .abc suffix to the names of all *.txt regular files in the current directory tree
find . -type f -iname '*.txt' -print0 | xargs -0 mv {} {}.abc

Add the execute and read permission for all and the write permission for the user to the dir_data directory and all of its sub-directories.
find ~/dir_data -type d -exec chmod a+xr,u+w {} \;

Add prefix like number and "^M${LOGFILE}> " to every non-blank line received on standard input
nl -s"^M${LOGFILE}>  "

Add read and execute permission to command "node"
sudo chmod +rx $(which node)

Add read and execute permission to every directory under the current directory
find . -type d -exec chmod +rx {} \;

Add read permission for 'other' for all files/directories named 'rc.conf' under current directory tree
find . -name "rc.conf" -exec chmod o+r '{}' \;

add read permission to others for the files in the current folder having the name "rc.conf" in their name.
find . -name "*rc.conf" -exec chmod o+r '{}' \;

add read,write permissions to all the files in the current folder which have the permission 600
find . -perm 600 -print | xargs chmod 666

all the files that end with .mp3 and end with .jpg
find . -name '*.mp3' -name '*.jpg' -print

ask user confirmation and delete all the files in the directory /mydir which have not been accessed in the last 100*24 hours
find /mydir -atime +100 -ok rm {} \;

Adjust the timestamp of 'filename' by subtracting 2 hours from it.
touch -d "$(date -r filename) - 2 hours" filename

Adjust the timestamp of file $filename by subtracting 2 hours from it
touch -d "$(date -r "$filename") - 2 hours" "$filename"

Alias "cd $(history -p !!:1)" as "cd-"
alias cd-='cd $(history -p !!:1)'

Always answer "no" to any prompt from "<command>"
yes no | <command>

Allocate a pseudo-terminal and execute "screen -r -X ls" which executes "ls" within the screen session on host "example.com"
ssh -t example.com "screen -r -X ls"

Allocate a pseudo-terminal and execute "screen -r" followed by "ls" on host "example.com"
ssh -t example.com "screen -r; ls"

Allocate a pseudo-terminal and execute "screen -r" on host "example.com"
ssh -t example.com "screen -r"

Log in as "middleuser" with key "./middle_id.pem" and forward port 22 on host "middle.example.org" to port 2222 on localhost
ssh -i ./middle_id.pem -R 22:localhost:2222 middleuser@middle.example.org

Log in using key file "./device_id.pem" as user "deviceuser" on host "middle.example.org" and port 2222
ssh -i ./device_id.pem -p 2222 deviceuser@middle.example.org

Log into "ubuntu@ec2-XX-XXX-XXX-XXX.us-west-2.compute.amazonaws.com" using identity file "~/path/mykeypair.pem"
ssh -i ~/path/mykeypair.pem ubuntu@ec2-XX-XXX-XXX-XXX.us-west-2.compute.amazonaws.com

long list all the files in the curent folder starting with "Tes"
find . -type f -name "Tes*" -exec ls -l {} \;

long list al the files in the current directory which have only read permission to the group
find . -perm 040 -type f -exec ls -l {} \;

long list al the files in the current directory which have read permission to the group
find . -perm -g=r -type f -exec ls -l {} \;

Log output of a command in screenlog.0 every 10 seconds
screen -d -m -L python test.py

Answer "1" repeatedly until "command" exits
yes 1 | command

Answer "n" to any prompts in the interactive recursive removal of "dir1", "dir2", and "dir3"
yes n | rm -ir dir1 dir2 dir3

Answer "y" to all "Are you sure?" prompts from command "cp * /tmp"
yes | cp * /tmp

Answer "y" to all prompts of "rm -rf foo"
yes | rm -ri foo

Answer "y" to any prompts in the interactive recursive removal of "dir1", "dir2", and "dir3"
yes y | rm -ir dir1 dir2 dir3

Apply script 'script.ksh' to all files matching pattern 'image\*.jpg' under the directory tree 'dir'
find dir -name image\*.jpg -exec /bin/ksh script.ksh {} \;

Apply script rename.sh to all files from the current directory tree whose names match regular expression "xxx-xxx_[a-zA-Z]+_[0-9]+_[0-9]+\.jpg$"
find . -regex "xxx-xxx_[a-zA-Z]+_[0-9]+_[0-9]+\.jpg$" -exec ./rename.sh "{}" ";"

Archive "./dir" to "user@host:/path" via ssh on port 2222 and display progress
rsync -rvz -e 'ssh -p 2222' --progress ./dir user@host:/path

Archive "/home/abc/*" to "/mnt/windowsabc" with human readable output
rsync -avh /home/abc/* /mnt/windowsabc

Archive "/home/user1" to "wobgalaxy02:/home/user1" excluding hidden files
rsync -av /home/user1 wobgalaxy02:/home/user1

Archive "/local/path/some_file" to "/some/path" on host "server.com" authenticating as user "usr", compress data during transmission, show progress details.
rsync -avz --progress local/path/some_file usr@server.com:"/some/path/"

Archive "/media/10001/music/" on host "server" to local directory "/media/incoming/music/" and skip files that are newer in the destination, delete any files in the destination not in the source, and compress data during transmission
rsync -avzru --delete-excluded server:/media/10001/music/ /media/Incoming/music/

Archive "/my/dir" on host "server" as user "user" to the current local directory excluding files ending in ".svn"
rsync -av --exclude '*.svn' user@server:/my/dir .

Archive "/path/to/application.ini" on host "source_host" to current directory.
rsync -avv source_host:path/to/application.ini ./application.ini

Archive "/path/to/copy" on host "remote" as user "user" to "/local/path" via ssh on port "$portNumber"
rsync -avz -e "ssh -p $portNumber" user@remote.host:/path/to/copy /local/path

Archive "/path/to/copy" on host "remote.host" as user "user" to "/path/to/local/storage" updating files with different checksums, showing human readable progress and statistics, and compressing data during transmission
rsync -chavzP --stats user@remote.host:/path/to/copy /path/to/local/storage

Archive "/path/to/copy" to "/path/to/local/storage" on host "host.remoted.from" as user "user" updating files with different checksums, showing human readable progress and statistics, and compressing data during transmission
rsync -chavzP --stats /path/to/copy user@host.remoted.from:/path/to/local/storage

Archive "/path/to/files" on host "remotemachine" authentifying as user "user" and compressing data during transmission, copy symlinks as symlinks.
rsync -avlzp user@remotemachine:/path/to/files /path/to/this/folder

Archive "/path/to/files" to "/path" on host "user@targethost" with elevated permission on the remote host
rsync -av --rsync-path="sudo rsync" /path/to/files user@targethost:/path

Archive "/path/to/files" to "user@targethost:/path"
rsync -av /path/to/files user@targethost:/path

Archive "/path/to/sfolder" to "name@remote.server:/path/to/remote/dfolder" compressing the data during transmission
rsync -avlzp /path/to/sfolder name@remote.server:/path/to/remote/dfolder

Archive "/path/to/sfolder" to "name@remote.server:/path/to/remote/dfolder" preserving hard links and compressing the data during transmission
rsync -aHvz /path/to/sfolder name@remote.server:/path/to/remote/dfolder

Archive "/path/to/sfolder/" to "name@remote.server:/path/to/remote/dfolder" preserving hard links and compressing the data during transmission
rsync -aHvz /path/to/sfolder/ name@remote.server:/path/to/remote/dfolder

Archive "/top/a/b/c/d" to host "remote" using relative path names
rsync -a --relative /top/a/b/c/d remote:/

Archive "/usr/local/" to "/BackUp/usr/local/" on host "XXX.XXX.XXX.XXX" via ssh and show progress
rsync --progress -avhe ssh /usr/local/  XXX.XXX.XXX.XXX:/BackUp/usr/local/

Archive "/var/www/test/" to "/var/www/test" on host "231.210.24.48" as user "ubuntu" via ssh using identity file "/home/test/pkey_new.pem"
rsync -rave "ssh -i /home/test/pkey_new.pem" /var/www/test/ ubuntu@231.210.24.48:/var/www/test

Archive "<SOURCE_DIR>" to "rsyncuser@192.168.1.110:/srv/www/prj112/myfolder"
rsync -av <SOURCE_DIR> rsyncuser@192.168.1.110:/srv/www/prj112/myfolder

Archive "_vim/" to "~/.vim" suppressing non-error messages and compressing data during transmission
rsync -aqz _vim/ ~/.vim

Archive "_vimrc" to "~/.vimrc" suppressing non-error messages and compressing data during transmission
rsync -aqz _vimrc ~/.vimrc

Archive "blanktest/" to "test/" deleting any files in the destination not found in the source
rsync -a --delete blanktest/ test/

Archive "fileToCopy" to "/some/nonExisting/dirToCopyTO" on host "ssh.myhost.net" via ssh
rsync -ave ssh fileToCopy ssh.myhost.net:/some/nonExisting/dirToCopyTO

Archive "foo/bar/baz.c" to "remote:/tmp/" preserving the relative path of "foo/bar/baz.c"
rsync -avR foo/bar/baz.c remote:/tmp/

Archive "myfile" to "/foo/bar/" and create directory "/foo/bar/" if "/foo/" exists
rsync -a myfile /foo/bar/

Archive "path/subfolder" to "path", skipping files that are newer at the destination.
rsync -vuar --delete-after path/subfolder/ path/

Archive "path/to/working/copy" to "path/to/export" excluding files or directories named ".svn"
rsync -a --exclude .svn path/to/working/copy path/to/export

Archive "source" to "destination" via ssh with "rwX" permissions
rsync -rvz --chmod=ugo=rwX -e ssh source destination

Archive "src" to "dest" via ssh with permissions set to 755
rsync -avz --chmod=ug=rwx --chmod=o=rx -e ssh src dest

Archive "src" to "dst" updating files existing in "dst"
rsync -a -v src dst

Archive "src" to "dst" without overwriting existing files in "dst"
rsync -a -v --ignore-existing src dst

Archive "src-dir" to "dest-dir" on "remote-user@remote-host" and delete any files in "dest-dir" not found in "src-dir"
rsync -av --delete src-dir remote-user@remote-host:dest-dir

Archive "src/bar" on host "foo" to local directory "/data/tmp"
rsync -avz foo:src/bar /data/tmp

Archive "user@host1:/directory/" to "user@host2:/directory2/" via ssh and compressing data during transmission
rsync -azvu -e ssh user@host1:/directory/ user@host2:/directory2/

Archive "user@remoteip:/path/to/files/" to "/local/path" via ssh on port "$portNumber" and compressing data during transmission
rsync -avz -e "ssh -p $portNumber" user@remoteip:/path/to/files/ /local/path/

Archive all *.xml files under current directory tree to xml.tar excluding the files that match '/workspace/' in their paths
find . -name \*.xml | grep -v /workspace/ | tr '\n' '\0' | xargs -0 tar -cf xml.tar

Archive all *html files using tar.
find . -type f -name "*html" | xargs tar cvf htmlfiles.tar -

Archive and compress all files in "data" directory into "data.tar.gz"
tar -cvf - data/* | gzip > data.tar.gz

Archive all directories in /path/to/directory/* (only command line arguments, no sub-directories) to files with .tar.gz extension
find /path/to/directory/* -maxdepth 0 -type d -printf "%P\n" -exec sudo tar -zcpvf {}.tar.gz {} \;

Archive all directories in /path/to/directory/* (only command line arguments, no sub-directories) to files with .tar.gz extension transforming the full paths to relative paths
find /path/* -maxdepth 0 -type d -exec sudo tar -zcpvf {}.tar.gz {} \;

Archive all filepattern-*2009* files/directories under data/ into 2009.tar
find -x data -name "filepattern-*2009*" -print0 | tar --null --no-recursion -uf 2009.tar --files-from -

Archive all filepattern-*2009* files/directories under data/ into 2009.tar
find data -xdev -name "filepattern-*2009*" -print0 | tar --null --no-recursion -uf 2009.tar --files-from -

Archive all filepattern-*2009* files/directories under data/ into 2009.tar
find data/ -name "filepattern-*2009*" | cpio -ov --format=ustar > 2009.tar

Archive all filepattern-*2009* files/directories under data/ into 2009.tar
find data/ -name 'filepattern-*2009*' -exec tar uf 2009.tar '{}' +

Archive all filepattern-*2009* files/directories under data/ into 2009.tar
find data/ -name filepattern-*2009* -exec tar uf 2009.tar {} ;

Archive all filepattern-*2009* files/directories under data/ into 2009.tar
find data/ -name filepattern-*2009* -print0 | xargs -0 tar uf 2009.tar

Archive all files/directories under data/ into archive.tar
find data/ -print0 | tar --null -T - --create -f archive.tar

Archive all files/directories under data/ into archive.tar
find data/ -print0 | tar -T - --null --create -f archive.tar

Archive all files beginning with .env or .bash in current directory to user's home directory on host "app1", preserving timestamps and skipping files that are newer on "app1"
rsync -vaut ~/.env* ~/.bash* app1:

Archive all files (not directories) in "folder1" to "copy_of_folder1" specifying to include files info.txt and data.zip
rsync -a -f"+ info.txt" -f"+ data.zip" -f'-! */' folder1/ copy_of_folder1/

Archive all files specified on standard input under "/path/to/files" to "/path" on host "targethost" as user "user" with escalated privileges
rsync -av --files-from=- --rsync-path="sudo rsync" /path/to/files user@targethost:/path

archive all the normal/regular files in the current directory which have been modified in the last 24 hours.
find . -mtime -1 -type f -exec tar rvf "$archive.tar" '{}' \;

Archive current directory to "/some/path" on localhost, using ssh to authentify as user "me", only update files that are newer in the source directory.
rsync -auve "ssh -p 2222" . me@localhost:/some/path

Archive directory "." to "server2::sharename/B"
rsync -av . server2::sharename/B

Archive directory "/mnt/data" to "/media/WD_Disk_1/current_working_data/", deleting any extraneous files in destination, compress data during copy.
rsync -az --delete /mnt/data/ /media/WD_Disk_1/current_working_data/;

Archive directory "tata" to directory "tata2", compressing data during copy.
rsync -avz tata/ tata2/

Archive directory specified by variable "i" to "/iscsi" preserving relative paths.
rsync -avR $i /iscsi;

Archive files in "/mnt/source-tmp" to "/media/destination"
rsync -a /mnt/source-tmp /media/destination/

Archive files (not directories) in "sorce_dir" to "target_dir"
rsync -a --filter="-! */" sorce_dir/ target_dir/

Archive preserving permissions and ownership files in "/var/www/" on host "user@10.1.1.2" to local "/var/www/"
sudo rsync -az user@10.1.1.2:/var/www/ /var/www/

Archive showing progress "sourcefolder" to "/destinationfolder" excluding "thefoldertoexclude"
rsync -av --progress sourcefolder /destinationfolder --exclude thefoldertoexclude

Archive showing progress all files in "/media/2TB\ Data/data/music/" to "/media/wd/network_sync/music/" excluding files matching "*.VOB", "*.avi", "*.mkv", "*.ts", "*.mpg", "*.iso", "*ar", "*.vob", "*.BUP", "*.cdi", "*.ISO", "*.shn", "*.MPG", "*.AVI", "*.DAT", "*.img", "*.nrg", "*.cdr", "*.bin", "*.MOV", "*.goutputs*", "*.flv", "*.mov", "*.m2ts", "*.cdg", "*.IFO", "*.asf", and "*.ite"
rsync -av --progress --exclude=*.VOB --exclude=*.avi --exclude=*.mkv --exclude=*.ts --exclude=*.mpg --exclude=*.iso --exclude=*ar --exclude=*.vob --exclude=*.BUP --exclude=*.cdi --exclude=*.ISO --exclude=*.shn --exclude=*.MPG --exclude=*.AVI --exclude=*.DAT --exclude=*.img --exclude=*.nrg --exclude=*.cdr --exclude=*.bin --exclude=*.MOV --exclude=*.goutputs* --exclude=*.flv --exclude=*.mov --exclude=*.m2ts --exclude=*.cdg --exclude=*.IFO --exclude=*.asf --exclude=*.ite /media/2TB\ Data/data/music/* /media/wd/network_sync/music/

Archive the directory structure under .. directory into dirstructure.tar
find .. -type d -print0 | xargs -0 tar cf dirstructure.tar --no-recursion

Archive the directory structure under backup directory into directory-structure.tar
find backup/ -type d -print0 | xargs -0 tar cf directory-structure.tar --no-recursion

Archive the directory structure under backup directory into directory-structure.tar
find backup/ -type d | tar cf directory-structure.tar -T - --no-recursion

Archive the directory structure under backup directory into directory-structure.tar
find backup/ -type d | xargs tar cf directory-structure.tar --no-recursion

Archive the directory structure under current directory into /somewhereelse/whatever-dirsonly.tar
find . -type d |xargs tar rf /somewhereelse/whatever-dirsonly.tar --no-recursion

Archive the directory structure under current directory into directory-structure.tar
find . -type d -print0 | tar cf directory-structure.tar --null --files-from - --no-recursion

Archive the directory structure under current directory into dirstructure.tar
find . -type d -print0 | tar cf dirstructure.tar --null --files-from - --no-recursion

Archive the entire file system into tarfile.tar.bz2
find / -print0 | tar -T- --null --no-recursive -cjf tarfile.tar.bz2

Archive the entire file system into tarfile.tar.bz2
find / -print0 | xargs -0 tar cjf tarfile.tar.bz2

Archive the list of 1st level subdirectories in /fss/fin to /fss/fi/outfile.tar.gz
tar -czf /fss/fi/outfile.tar.gz `find /fss/fin -d 1 -type d -name "*" -print`

Allow all users to execute "myscript.sh"
chmod a+x myscript.sh

Allow all users to execute '$pathToShell"myShell.sh"'
chmod a+x $pathToShell"myShell.sh"

Allow anyone to run command "Xvfb" as the owner of "Xvfb"
sudo chmod u+s `which Xvfb`

Allow ssh from 127.0.0.1 on port "someport" through "proxy.host" to "host.in.the.remote.net" on port 22
ssh -fL 127.0.0.1:someport:host.in.the.remote.net:22 proxy.host

As root, edit the cron job list of user "apache" using the editor specified by EDITOR environment variable, or default /usr/bin/editor if this variable is not set.
sudo crontab -e -u apache

Assign a name when starting a screen session
screen -S 'name' 'application'

Assign a name when starting a screen session
screen -S foo

Assign a name when starting a screen session
screen -S lynx lynx

Assign a name when starting a screen session
screen -r 'name'

Assign permissions 644 to files in the current directory tree
find . -type f -print0 | xargs -0 chmod 644

Assign permissions 755 to directories in the current directory tree
find . -type d -print0 | xargs -0 chmod 755

Assigns MAC address 00:80:48:BA:d1:30 to interface eth0.
ifconfig eth0 hw ether 00:80:48:BA:d1:30

Assign the alias rm2g to a find command that removes any .tar file larger than 2 gigabytes.
alias rm2g="find / -type f -name *.tar -size +2G -exec rm -i {} \;"

Assign the alias rm5g to a find command that removes any .tar file larger than 5 gigabytes.
alias rm5g="find / -type f -name *.tar -size +5G -exec rm -i {} \;"

Assign the alias rmc to a find command that deletes all core dump files in the currenty directory and below.
alias rmc="find . -iname core -exec rm {} \;"

Reattach a session and if necessary detach it first
screen -dr 14313

Reattach a session and if necessary detach or  even  create first
screen -d -R -S test

Attaches to 'test1' tmux session.
tmux attach -t test1

Attaches to a 'session name' tmux session.
tmux attach -t <session name>

Attach to a not detached screen session. (Multi display mode).
screen -xr 14313

Reattach to a screen session
screen -d -r remote-command

Attempt to connect as root to localhost and copy /home/reportuser/dailyReport.doc to directory /root/dailyReports/20150105/ - this will normally fail because ssh won't accept root connections by default.
scp -p /home/reportuser/dailyReport.doc root@localhost:/root/dailyReports/20150105/

Attempt to connect as root via ssh to host "IP" and copy /root/K to local machine, passing option "StrictHostKeyChecking=no" to the ssh backend - this will normally fail because ssh servers by default don't (and shouldn't) accept root logins.
scp -o StrictHostKeyChecking=no root@IP:/root/K

Attempt to connect as root via ssh to host whose IP address or hostname is specified by environment variable IPADDRESS - this will normally fail because ssh servers normally don't accept root logins.
scp -rp "DAILY_TEST_FOLDER" "root@${IPADDRESS}:/home/root/"

Automatically send "y" to "sudo rpm -Uvh https://mirror.webtatic.com/yum/el6/latest.rpm" to automate installation
yes | sudo rpm -Uvh https://mirror.webtatic.com/yum/el6/latest.rpm

Automatically log into "SOME_SITE.COM" as user "YOUR_USERNAME" using password "YOUR_PASSWORD"
sshpass -p "YOUR_PASSWORD" ssh -o StrictHostKeyChecking=no YOUR_USERNAME@SOME_SITE.COM

Automatically log into "SOME_SITE.COM" on port 2400 as user "YOUR_USERNAME" using password "YOUR_PASSWORD"
sshpass -p "YOUR_PASSWORD" ssh -o StrictHostKeyChecking=no YOUR_USERNAME@SOME_SITE.COM:2400

Automatically spell check file "text.txt" using "aspell" command
yes 1 | script -c 'aspell check text.txt' /dev/null

Automatically spell check file "text.txt" using "ispell" command
yes 0 | script -c 'ispell text.txt' /dev/null

Automatically spell check file "text.txt" using "ispell" command and log the output to "out.txt"
yes 0 | script -c 'ispell text.txt' out.txt

Backup a directory with a zenity progress bar
screen -L bash -c '(while :; do tail ~/screenlog.0 | grep -o "[0-9]*%" | tail -1; done | zenity --progress --auto-close &); 7z a "output.zip" "/path/to/input"'

Backup all of the Java files in the current directory tree by copying them and appending the suffix .bk to each
find . -name "*.java" -exec cp {} {}.bk \;

Backup all PHP files under the current directory tree
find -name "*.php" –exec cp {} {}.bak \;

Backup MySQL database "database" with "username" and "pswd", compress with gzip and add the time stamp before emailing to "me@domain.com"
mysqldump -e --user=username --password=pswd database | gzip | uuencode my-dbbackup.`date +"\%Y-\%m-\%d"`.gz | mail me@domain.com

beginning at the end of the file, prints lines matching /2012/ and exits after first non-matching line
tail -n `tac biglogfile | grep -vnm1 2012 | sed 's/:.*//' | xargs expr -1 +` biglogfile

Brings down network interface eth0.
ifconfig eth0 down

prune all the files in the current directory, only current directory (.) is the output
find . -prune

Build an "svn hotcopy" command for each subdirectory of /usr/local/svn/repos/
find /usr/local/svn/repos/ -maxdepth 1 -mindepth 1 -type d -printf "%f\0" | xargs -0 -I{} echo svnadmin hotcopy /usr/local/svn/repos/\{\} /usr/local/backup/\{\}

Pass "y" to all the prompts for the command "execute_command"
yes | execute_command

Pass a single argument containing a string of numbers from 1 to 100000 to "/bin/true"
/bin/true "$(seq 1 100000)"

Pass a wildcard to scp by escaping it: copy all files with names starting with "files" in directory "/location" on host "server" to current directory on local machine, displaying debug info and preserving timestamps and permissions on copied files.
scp -vp me@server:/location/files\*

Bypass all prompts by sending return to the install script downloaded from "https://raw.github.com/Homebrew/homebrew/go/install"
yes '' | ruby -e "$(curl -fsSL https://raw.github.com/Homebrew/homebrew/go/install)"

Pass all the files from the current directory tree as arguments to a single 'echo' command
find . -exec echo {} +

Pass numbers 1 to 100000 as arguments to "/bin/true"
/bin/true $(seq 1 100000)

Calculate and show md5 sums for every files under current directory tree
find . -type f -exec md5sum \{\} \;

Calculate and show md5 sums for every files under current directory tree
find . | xargs md5sum

Calculate md5 checksum of $KEY, take the 1st to 10th character, append them with the string '/tmp/command_cache.' and save the rsultant string to variable FILE
FILE="/tmp/command_cache.`echo -n "$KEY" | md5sum | cut -c -10`"

Calculate md5 checksum of $line and save to variable 'md5'
md5=$(echo "$line"|md5sum)

Calculate md5 checksum of '/etc/localtime' and save the first space separated part in variable 'checksum'
checksum=`md5sum /etc/localtime | cut -d' ' -f1`

Calculate md5 checksum of the list of all files/dirs in /path recursively including dot files and excluding the patterns 'run', 'sys', 'tmp' and 'proc', then check the checksum against the checksum saved in /tmp/file
ls -alR -I dev -I run -I sys -I tmp -I proc /path | md5sum -c /tmp/file

Calculate md5 checksum of theDirname
cpio -i -e theDirname | md5sum

Calculate MD5 sums for all regular files in the current directory tree and save the result as "MD5SUMS"
find . -type f -exec md5sum {} \; > MD5SUMS

Calculate md5 sums for each files matching 'main.cpp*'
md5sum main.cpp*

Calculate md5 sum of empty string
echo -n "" | md5sum

Calculate md5 sum of empty string
echo -n | md5sum

Calculate md5 sum of the md5 sum of all the sorted files under $path
find "$path" -type f -print0 | sort -z | xargs -r0 md5sum | md5sum

Calculate md5sum of the contents of the archives '/tmp/tst.gz', '/tmp/tst.bz2', '/tmp/tst.lzma' and '/tmp/tst.xz'.
md5sum <(zcat /tmp/tst.gz) <(bzcat /tmp/tst.bz2) <(lzcat /tmp/tst.lzma) <(xzcat /tmp/tst.xz)

Calculate the crc32 of "testring"
echo -n teststring | gzip -1 | pigz -lv

Calculate the crc32 of "testring"
echo -n teststring | gzip -1 | tail -c 8 | head -c 4 | hexdump -e '1/4 "%08x" "\n"'

calculate the disk usage for all the files which have been modified in the last 24 hours in ~/tmp folder and display the file sizes
find ~/tmp -mtime 0 -exec du -ks {} \; | cut -f1

Calculate the factorial of 500
seq -s "*" 1 500 |bc

Calculate the total amount of memory usage of the current user
alias memu="ps -u $(whoami) -o pid,rss,command | awk '{print \$0}{sum+=\$2} END {print \"Total\", sum/1024, \"MB\"}'"

Calculate the total size of all *.jpg files in the directory tree
find . -type f -iname "*.jpg" -ls | awk 'BEGIN {print "0"}; {print $7, "+"}; END {print "p"}' | dc

Calculate the md5 checksum of the current directory structure and save it in variable SUM
SUM=$(tree | md5sum)

Calculate the md5 sum of "a"
echo "a" | md5sum

Calculate the md5 sum of "exampleString"
echo -n 'exampleString' | md5sum

Calculate the md5 sum of "submission.cpp" with less sensitivity to superficial changes like comments or whitespace
cat submission.cpp | astyle -bj | cpp - | md5sum

Calculate the md5 sum of "yourstring"
echo -n "yourstring" |md5sum

Calculate the md5 sum of all ".py" files in "/your/dir" including content and filenames
grep -ar -e . --include="*.py" /your/dir | md5sum | cut -c-32

Calculate the md5 sum of all *.py files in the current directory
cat *.py | md5sum

Calculate the md5 sum of all files in "/your/dir" including content and filenames
grep -ar -e . /your/dir | md5sum | cut -c-32

Calculate the md5 sum of all the file metadata in the current directory tree excluding ".svn"
find . -name '.svn' -prune -o -type f -printf '%m%c%p' | md5sum

Calculate the md5 sum of the contents of all files sorted in directory tree "/path"
find /path -type f | sort -u | xargs cat | md5sum

Calculate the md5 sum of the list of files in the current directory
find . -maxdepth 1 -type f | md5sum

Calculate the md5 sum of the tar archive of "dir"
tar c dir | md5sum

Calculate the md5 sum of the md5 sum of all the files sorted under "$path"
find "$path" -type f -print0 | sort -z | xargs -r0 md5sum | md5sum

Calculate the md5 sum of the output of "du -csxb /path" and compare it against the md5 sum saved in "file"
du -csxb /path | md5sum -c file

Calculate the md5 sum of the file "filename" and print only the hash
md5sum filename |cut -f 1 -d " "

Calculate the md5 sum of hex byte 61
echo -n -e '\x61' | md5sum

Calculate the md5sum of the executable file of command "cc"
md5sum $(which cc)

Calculate the md5sum of the executable file of command "gcc"
md5sum $(which gcc)

Calculate the md5sum of the executable file of command 'c++'
md5sum `which c++`

Calculate the number of bytes of all the files listed in "files.txt"
<files.txt  xargs stat -c %s | paste -sd+ - | bc

Calculate the sha1 sum and md5 sum of "foo"
echo foo | tee >(sha1sum) >(md5sum)

Calculate the SHA1 sum for the contents of the path/to/folder directory tree, including permissions
find path/to/folder -type f -print0  | sort -z | xargs -0 sha1sum; find path/to/folder \( -type f -o -type d \) -print0 | sort -z | xargs -0 stat -c '%n %a' | sha1sum

Calculate the SHA1 sum for the contents of the regular files in the path/to/folder directory tree
find path/to/folder -type f -print0 | sort -z | xargs -0 cat | sha1sum

Calculate the SHA1 sum for the contents of the regular files in the path/to/folder directory tree
find path/to/folder -type f -print0 | sort -z | xargs -0 sha1sum | sha1sum

Calculate the SHA1 sum for the contents of the regular files in the path/to/folder directory tree
find path/to/folder -type f -print0 | xargs -0 sha1sum | sha1sum

Calculate the sum of all the numbers from -5 to 10
seq -5 10 | xargs printf "- - %s" | xargs  | bc

Calculate the sum of all the numbers from -5 to 10
seq -s+ -5 10 | bc

Calculate the sum of all the numbers from 1 to 10
seq 10 | jq -s 'add'

Calculate the sum of all the numbers from 1 to 10
seq 10 | tr '[\n]' '+' | sed -e 's/+/ + /g' -e's/ + $/\n/' | xargs expr

Calculate the sum of all the numbers from 1 to 10
seq 10|jq -s add

Calculate the sum of the 7th column of "ipcs -mb"
ipcs -mb | awk 'NR > 3 { print $7 }' | paste -sd+ | bc

Case-insensitive search all existing environment variables and their values for "shell".
env | grep -i shell

Change all "JPG" filename suffixes in current directory to "jpeg".
rename -v 's/\.JPG/\.jpeg/' *.JPG

Change all directories under "./bootstrap/cache/" to owner "apache" and group "laravel"
sudo find ./bootstrap/cache/ -type d -exec chown apache:laravel {} \;

Change all directories under "./storage/" to owner "apache" and group "laravel"
sudo find ./storage/ -type d -exec chown apache:laravel {} \;

Change all files in "~" which are owned by the group "vboxusers" to be owned by the user group "kent"
find ~ -group vboxusers -exec chown kent:kent {} \;

Change all files in the current directory tree to owner "xx"
find . \( \! -user xx -exec chown -- xx '{}' + -false \)

Change all occurrences of "foo" to "bar" in the file "file.txt"
echo ',s/foo/bar/g; w' | tr \; '\012' | ed -s file.txt

Change all file permissions to 664 and all directory permissions to 775 in directory tree "htdocs"
find htdocs -type f -exec chmod 664 {} + -o -type d -exec chmod 775 {} +

Change all variables containing "gcc.4.2" to containing "gcc64" in the current shell's environment.
source <(export | sed 's/gcc.4.2/gcc64/g')

change cgi files to mode 755
find htdocs cgi-bin -name "*.cgi" -type f -exec chmod 755 {} \;

change cgi files to mode 755 under htdocs or cgi-bin directories
find htdocs cgi-bin -name "*.cgi" -type f -exec chmod 755 {} \;

Change directory to "$dir1" and resolve any symlinks in the resulting path
cd -P "$dir1"

Change directory to "/lib/modules/" of the current kernel release
cd /lib/modules/$(uname -r)/

Change directory to "/path/to/pdf"
cd  /path/to/pdf

Change directory to parent directory and do not resolve any symlinks in the resulting path
cd -L ..

Change directory to the "lib" directory located two parent directories above the path to command "perl"
cd $(dirname $(dirname $(which perl)))/lib

Change directory to the basename of "$1" with ".tar.gz" removed
cd $(basename $1 .tar.gz)

Change directory to the current user's home directory
cd /home/`whoami`

Change directory to the directory containing file path "$1"
cd "$(dirname "$1")"

Change directory to the directory containing the "oracle" executable
cd "$(dirname $(which oracle))"

Change directory to the directory containing the "oracle" executable
cd $(dirname $(which oracle))

Change directory to the directory containing the "oracle" executable
cd $(dirname `which oracle`)

Change directory to the directory containing the current script
cd $(dirname $(which $0) )

Change directory to the directory containing the executable file of command "oracle"
cd $(which oracle | xargs dirname)

Change directory to the download directory specified in the current user's user-dirs.dirs file
cd "$(grep DOWNLOAD $HOME/.config/user-dirs.dirs | cut -f 2 -d "=" | tr "\"" "\n" | tr -d "\n")"

Change directory to the download directory specified in the current user's user-dirs.dirs file
cd "$(grep DOWNLOAD $HOME/.config/user-dirs.dirs | cut -f 2 -d "=" | tr "\"" "\n")"

Change directory to the output of command '~/marker.sh go "$@"'
cd $( ~/marker.sh go "$@" )

Change directory to the parent of the real path of the current script
cd $(dirname $(readlink -f $0))

Change directory to the real path of the current working directory of process "$PID"
cd $(readlink /proc/$PID/cwd)

Change directory to the real path of the directory containing the current script
cd $(readlink -f $(dirname $0))

Change every directory under "/var/www/html/" to have permissions 775
sudo  find /var/www/html/ -type d -exec chmod 775 {} \;

Change every file under "/var/www/html/" to have permissions 664
sudo  find /var/www/html/ -type f -exec chmod 664 {} \;

change group of the file /var/lib/php/session  to group lighttpd
chown -R :lighttpd /var/lib/php/session

change group of the file myfile to group friends
chown :friends myfile

Changes group ownership of '/etc/btsync/[prefered conf name].conf' to 'btsync'.
chgrp btsync /etc/btsync/[prefered conf name].conf

Changes group ownership of '/home/www-user/php_user.sh'  to 'www-data'.
chgrp www-data /home/www-user/php_user.sh

Changes group ownership of '/var/run/fcgiwrap.socket' to 'forge'.
chgrp forge /var/run/fcgiwrap.socket

Changes group ownership of 'logdir' to 'loggroup'.
chgrp loggroup logdir

Changes group ownership of 'myprog' to 'groupb'.
chgrp groupb myprog

Changes group ownership of 'myprogram' to ${USER} (the current user)
chgrp "${USER}" myprogram

Changes group ownership of 'public' and 'private' to 'god'.
chgrp god public private

Changes group ownership of 'public' to 'pub'.
chgrp pub public

Changes group ownership of 'target_directory' to 'target_group'.
chgrp target_group target_directory

Changes group ownership of /sys/class/gpio/export and /sys/class/gpio/unexport to 'gpio'.
sudo chgrp gpio /sys/class/gpio/export /sys/class/gpio/unexport

Change login shell to the full path of "zsh"
chsh -s $(which zsh)

change owner and group  of all files and directory into current directory to user and group apache
find . -maxdepth 1 -not -name "." -print0 | xargs --null chown -R apache:apache

change owner and group of the all files with group owner vboxusers into home directory to user and group kent
find ~ -group vboxusers -exec chown kent:kent {} \;

change owner and group of the current directory and all files into it to user and group andrew
chown -R andrewr:andrewr *

change owner and group of the file "/path/to/yourapp" to root
chown -v root:root /path/to/yourapp

change owner and group of the file "file" to user "user" and group "group"
chown user:group file ...

change owner and group of the file dir1 to user root and group  specialusers
chown root:specialusers dir1

change owner and group of the file script.sh to user root
chown root:root script.sh

change owner and group of the file uid_demo to user and group root
sudo chown root:root uid_demo

Change onwer of "file" to "user_name"
chown user_name file

Change owner of "folder" to "user_name"
chown user_name folder

Change owner of "my_test_expect.exp" to "el"
sudo chown el my_test_expect.exp

change owner of all files into current directory except  files named as  './var/foo*' to user www-data
find . -not -iwholename './var/foo*' -exec chown www-data '{}' \;

Change mode of all files ending with ".php" under the current folder to 755 and write the output to the console and "logfile.txt" file
find . -name '*.php' -exec chmod 755 {} \; | tee logfile.txt

change owner of the file "file" to user user_name
chown user_name file

change owner of the file /home/bob to user root
sudo chown root /home/bob

change owner of the file destination_dir to user "user:
chown user destination_dir

change owner of the file file.sh to user root
$sudo chown root file.sh

change owner of the files into directory dir_to_start except directory dir_to_exclude to user owner
find dir_to_start -name dir_to_exclude -prune -o -print0 | xargs -0 chown owner

change owner of the file process to user root
sudo chown root process

Change owner to "$1" and group to "httpd" of ".htaccess"
chown $1:httpd .htaccess

Change owner to "$FUID" and group to "$FGID" of "$FILE2"
chown $FUID:$FGID "$FILE2"

Change owner to "$user" and group to "$group" of "$file"
chown -- "$user:$group" "$file"

Change owner to "bob" and group to "sftponly" of "/home/bob/writable"
sudo chown bob:sftponly /home/bob/writable

Change owner to "root" and group to "dockerroot" of "/var/run/docker.sock"
sudo chown root:dockerroot /var/run/docker.sock

Change owner to "root" and group to "wheel" of "adbind.bash"
sudo chown root:wheel adbind.bash

Change onwer to "root" and group to "wheel" of "com.xxxx.adbind.plist"
sudo chown root:wheel com.xxxx.adbind.plist

Change owner to "root" and group to "www-data" of "/foobar/test_file"
sudo chown root:www-data /foobar/test_file

Change ownership of "/data/db" to the current user
sudo chown `whoami` /data/db

Change ownership of "/vol" to the current user
sudo chown `whoami` /vol

Change permissions for all PHP files under the current directory tree to 755
find . -name "*.php" -exec chmod 755 {} \;

Change permissions for all PHP files under the current directory tree to 755 and print the number of files changed
find . -name "*.php" -exec chmod 755 {} + -printf '.' | wc -c

Change permissions for all PHP files under the current directory tree to 755 and print the number of files changed
find . -name "*.php" -exec chmod 755 {} \; -exec /bin/echo {} \; | wc -l

change permissions for directories in the entire file system
chmod 751 `find ./ -type d -print`

Change permissions of ".bash_logout", ".bashrc", and ".profile" to 444
chmod 444 .bash_logout .bashrc .profile

Change permissions of ".git/hooks/prepare-commit-msg" to 777
sudo chmod 777 .git/hooks/prepare-commit-msg

Change permissions of "/dvtcolorconvert.rb" to 755
sudo chmod 755 /dvtcolorconvert.rb

Change permissions of "/usr/bin/wget" to 777
chmod 777 /usr/bin/wget

Change permssions of *.cgi files under directories htdocs and cgi-bin to 755
find htdocs cgi-bin -name "*.cgi" -type f -exec chmod 755 {} \;

Change permissions of all directories from the current directory tree to 644
find . -type d -exec chmod 755 {} +

Change permissions of all directories residing under and below ./debian to 755
find ./debian -type d | xargs chmod 755

Change permissions of all files ending ".php" under the current directory to 755 and print a count of modified files
find . -name "*.php" -exec chmod 755 {} + -printf '.' | wc -c

Change permissions of all files ending ".php" under the current directory to 755 with a progress bar based on lines
find . -name "*.php" | pv --line-mode | xargs chmod 755

Change permissions of all files ending in ".php" under the current directory to 755 and print a '+' for each file
find . -name '*.php' -exec chmod 755 {} \; -exec echo '+' \;

Change permissions of all files ending in ".php" under the current directory to 755 and print a count of modified files
find . -name "*.php" -exec chmod 755 {} \; -exec /bin/echo {} \; | wc -l

Change permissions of all regular files from the current directory tree to 644
find . -type f -exec chmod 644 {} +

change permission of all the files in the entire file system which have permissions 777.
find / -type f -perm 0777 -print -exec chmod 644 {} \;

change permission of all the files in the entire file system which have the permissions 777.
find / -type f -perm 0777 -print -exec chmod 644 {} \;

change permissions of all the script files in a directory
find /home/john/script -name "*.sh" -type f -exec chmod 644 {} \;

Change permissions of directory "/home/sshtunnel/" to 555
chmod 555 /home/sshtunnel/

Change permission to 000 of all directories named '.texturedata' under '/path/to/look/in/' directory tree
find /path/to/look/in/ -type d -name '.texturedata' -exec chmod 000 {} \; -prune

Change permission to 000 of all directories named '.texturedata' under '/path/to/look/in/' directory tree
find /path/to/look/in/ -type d -name '.texturedata' -prune -print0 | xargs -0 chmod 000

Change permissions to 0755 for all directories in the /path directory tree
find /path -type d -exec chmod 0755 "{}" \;

Change permissions to 0755 for all directories in the /path directory tree
find /path -type d -exec chmod 0755 {} \;

Change permissions to 0755 for all directories in the /path directory tree
find /path -type d | xargs chmod 0755

Change permissions to 500 for all regular files under and below the current directory
find . -type f -exec chmod 500 {} ';'

Change permissions to 600 for all regular .rb files in the current directory tree
find . -name "*.rb" -type f -exec chmod 600 {} \;

Change permissions to 644 for *.html files under /usr/local
find /usr/local -name "*.html" -type f -exec chmod 644 {} \;

Change permissions to 644 for all directories under and below /path/to/someDirectory/
find /path/to/someDirectory -type d -print0 | xargs -0 sudo chmod 755

Change permissions to 644 for all files in the current directory tree
find . -type f | xargs -I{} chmod -v 644 {}

Change permissions to 644 for all files in the current directory tree
find . -type f | xargs chmod -v 644

Change permissions to 644 for all files showing the respective chmod command
find ./ -type f -print0 | xargs -t -0 chmod -v 644

Change permissions to 644 for all regular files under the /path/to/dir/ tree
find /path/to/dir/ -type f -print0 | xargs -0 chmod 644

Change permissions to 644 for all regular files under the /path/to/dir/ tree unless these permissions are already set
find /path/to/dir ! -perm 0644 -exec chmod 0644 {} \;

Change permissions to 644 for all regular files under the /path/to/dir/ tree unless these permissions are already set
find /path/to/dir/ -type f ! -perm 0644 -print0 | xargs -0 chmod 644

Change permissions to 644 for all subdirectories
find . -type d -print0|xargs -0 chmod 644

Change permissions to 644 of multiple regular files with permissions 755
find . -type f -perm 755 -exec chmod 644 {} \;

Change permissions to 644 recursively for PHP files.
find . -type f -name '*.php' -exec chmod 644 {} \;

Change permissions to 644 recursively only for files
find . -type f -exec chmod 644 {} \;

Change permissions to 700 for directories at the current level and deeper
find . -mindepth 1 -type d | xargs chmod 700

Change permissions to 700 for files and directories deeper than the current directory
find . -mindepth 2 | xargs chmod 700

Change permissions to 755 for all directories in the /path/to/dir directory tree
find /path/to/dir -type d -exec chmod 755 {} \;

Change permissions to 755 for all directories in the current directory tree
find . -type d | xargs chmod -v 755

Change permission to 755 for all directories under $d directory tree
find "$d/" -type d -print0 | xargs -0 chmod 755

Change permission to 755 of all files/directories under current directory tree that have 777 permission
find -perm 777 | xargs -I@ sudo chmod 755 '@'

Change permissions to 777 for all directories in the current directory tree
find . -type d -exec chmod 777 {} \;

Change permissions to u=rw,g=r,o= for all files in the current directory tree
find . -type f -exec chmod u=rw,g=r,o= '{}' \;

Change permissions to u=rw,g=r,o= for all files inside the current directory tree
find . -type f -exec chmod u=rw,g=r,o= '{}' \;

Change permissions to u=rwx,g=rx,o= for all directories in the current directory tree
find . -type d -exec chmod u=rwx,g=rx,o= '{}' \;

Change permissions to u=rwx,g=rx,o= for all directories inside the current directory tree
find . -type d -exec chmod u=rwx,g=rx,o= '{}' \;

Change file owner and group of "/path/to/yourapp" to root and print a diagnostic
chown -v root:root /path/to/yourapp

Change file permissions on all regular files within a directory
find /path/to/directory -type f -exec chmod 644 {} +

change the current working directory to "A" and display all the files in that folder and save the output to the file "tmp.txt"
(cd A && find .) > tmp.txt

change the current working directory to /some/dir and display all normal/regular files
cd "/some/dir" && find . -type f

Change the encoding of all *.java files in a directory and subdirectories from cp1252 to utf-8
find . -type f  -name '*.java' -exec sh -c 'iconv -f cp1252 -t utf-8 "$1" > converted && mv converted "$1"' -- {} \;

change the extension of all the ".abc" files in the folder "/the/path" to ".edefg" and do not change in the sub directories
find /the/path -depth -name "*.abc" -exec rename 's/\.abc$/.edefg/' {} +

change the extension of all the ".abc" files in the folder "/the/path" to ".edefg" and do not change in the sub directories
find /the/path -depth -name "*.abc" -exec sh -c 'mv "$1" "${1%.abc}.edefg"' _ {} \;

change the extension of all the ".abc" files in the folder "/the/path" to ".edefg" and do not change in the sub directories
find /the/path -depth -type f -name "*.abc" -exec sh -c 'mv "$1" "$(dirname "$1")/$(basename "$1" .abc).edefg"' _ {} \;

change the extension of all the ".abc" files in the folder "/the/path" to ".edefg" and do not change in the sub directories. execdir ensures that the command after it is executed only in the folder where the file is found
find /the/path -type f -name '*.abc' -execdir rename 's/\.\/(.+)\.abc$/version1_$1.abc/' {} \;

change the extension of all the ".lst" files in the current folder to "a.lst"
find -name ‘*.lst’ -exec rename .lst a.lst {} \;

change the extension of all the text files from .txt to .txt_bak in current folder
find . -name '*.txt' -exec sh -c 'mv "$0" "${0%.txt}.txt_bak"' {} \;

change the extension of all the files in the current folder to html excluding those html files and those which are present in another disk partition
find . -xtype f \! -iname *.html   -exec mv -iv "{}"  "{}.html"  \;

Change the group of "myfile" to "friends"
chown :friends myfile

change the group of all directories in the current folder
find . -type d -exec chgrp usergroup {} \;

change the group of all regular/normal files in the current directory
find . -type f -exec chgrp usergroup {} \;

change the group of all the files in the file system which belong to the group with the gid 999
find / -group 999 -exec chgrp NEWGROUP {} \;

change the group of all the files in the folder /u/netinst/ to staff
find /u/netinst -print | xargs chgrp staff

change the group of all the files which belong to the user edwarda to pubs
find / -user edwarda -exec chgrp pubs "{}" \;

Changes the group of defined file.
chgrp

change the group to "new_group" and permissions to 770 for all the files in the current folder
find . -name "*" -exec chgrp -v new_group '{}' \; -exec chmod -v 770 '{}' \;

change the group to "new_group" and permissions to 770 for all the files in the current folder
find . -name "*" \( -exec chgrp -v new_group {} \; -o -exec chmod -v 770 {} \; \)

change the group to "new_group" and permissions to 770 for all the files in the current folder, $0 is the input to the sub shell i.e, the name of the file
find . -name "*" -exec sh -c 'chgrp -v new_group "$0" ; chmod -v 770 "$0"' {} \;

Change the group to `temp' for all files in the current directory tree that belong to group `root'
find . -group root -print | xargs chgrp temp

Change the owner and group of "it" to "root"
chown root:root it

Change the owner and group of "testfile.txt" to "root"
sudo chown root:root testfile.txt

Change the owner and group of "uid_demo" to "root"
sudo chown root:root uid_demo

change the owner and group of all the directories in the current folder and /home/admin/data/ to admin & admin
find . /home/admin/data/ -type d -exec chown admin.admin {} \;

change the owner and group of all the files in the folder  /usr/lpp/FINANCIALS
find /usr/lpp/FINANCIALS -print | xargs chown roger.staff

change the owner and group of all the normal/regular files in the current folder and /home/admin/data/ to admin & admin
find . /home/admin/data/ -type f -exec chown admin.admin {} \;

Change the owner of "$JBOSS_CONSOLE_LOG" to "$JBOSS_USER"
chown $JBOSS_USER $JBOSS_CONSOLE_LOG

Change the owner of "/var/www/html/mysite/tmp_file_upload/" to "nobody"
sudo chown nobody /var/www/html/mysite/tmp_file_upload/

Change the owner of "destination_dir" to "user"
chown user destination_dir

Change the owner of "process" to "root"
sudo chown root process

Change the owner of all ".txt" files in directory tree "/mydir" to "root"
find /mydir -type f -name "*.txt" -execdir chown root {} ';'

Change the owner of all files in "/empty_dir/" to "root" using at most 10 files at a time
ls /empty_dir/ | xargs -L10 chown root

Change the owner of all files in "/empty_dir/" to "root" using at most 10 files at a time
ls /empty_dir/ | xargs -n10 chown root

Change the owner of all files in the directory tree "dir_to_start" excluding directory "dir_to_exclude" to "owner"
find dir_to_start -name dir_to_exclude -prune -o -print0 | xargs -0 chown owner

Change the owner of all files in the directory tree "dir_to_start" excluding file "file_to_exclude" to "owner"
find dir_to_start -not -name "file_to_exclude"  -print0 | xargs -0 chown owner

change the owner of all the files in the current directory
find . -exec chown myuser:a-common-group-name {} +

change the owner of all the files in the file system which belong to the user with the uid 999
find / -user 999 -exec chown NEWUSER {} \;

change the owner of all the regular/normal files which belong to the root user to "tom" in the current folder
find .-type f -user root -exec chown tom {} \;

Change the owner of the directory name of "$JBOSS_PIDFILE" to "${JBOSS_USER}" and always return successfully
chown ${JBOSS_USER}: $(dirname $JBOSS_PIDFILE) || true

change the owner of the files which belong to the group 1000 to username and modify only the symbolic link not the originally pointed file
find -gid 1000 -exec chown -h :username {} \;

Change the owner to "hduser" and group to "hadoop" of "{directory path}"
sudo chown hduser:hadoop {directory path}

Change the owner to "owner" and group to "nobody" of "public_html"
chown owner:nobody public_html

Change the owner to "user" and group to "group" of files "file ..."
chown user:group file ...

Change the ownership of "/etc/udev/rules.d/51-android.rules" to "root"
sudo chown root. /etc/udev/rules.d/51-android.rules

Change the ownership of "/home/bob" to "root"
sudo chown root /home/bob

Change the ownership of "file.sh" to "root"
sudo chown root file.sh

Change the ownership of all aluno1's files in the current directory and below to aluno2
find . -user aluno1 -exec chown aluno2 {}

change the ownership of all directories in the current folder
find . -type d -exec chown username {} \;

Change the ownership of all files in the current directory tree from root to www-data
find -user root -exec chown www-data {} \;

Change the ownership of all files in the current directory tree to myuser:a-common-group-name
find . -exec chown myuser:a-common-group-name {} +

change the ownership of all regular/normal files in the current directory
find . -type f -exec chown username {} \;

change the ownership of all regular/normal files in the current directory
find . -type f | xargs chown username

change the ownership of all regular/normal files in the current directory(print0 is used to handle all the files which have spaces or new lines in their names)
find . -type f -print0 | xargs -0 chown username

change the ownership of all regular/normal files in the current directory after users confirmation
find . -type f -ok chown username {} \;

change the ownership of all the files in the file system from edwarda to earnestc
find / -user edwarda -exec chown earnestc "{}" \;

change the ownership of all the files in the file system from edwarda to earnestc
find / -user edwarda -print | xargs chown earnestc

Change the ownership to eva for all files/directories that belong to the user 'george' in the entire file system without traversing to other devices/partitions
find -x / -user george -print0 | xargs -0 chown eva

Change the ownership to the user daisy for all directories under current directory that are owned by harry
find . -type d -user harry -exec chown daisy {} \;

change the permission of all directories in current folder to 755.
find . -type d -exec chmod 755 {} \;

change the permission of all php files in current folder. Plus symbol at the end is used to give multiple files as input to the chmod command
find . -name "*.php" -exec chmod 755 {} +

change the permissions of all regular/normal files in the current directory
find . -type f -exec chmod 664 {} \;

change the permissions of all regular/normal files in the current directory
find . -type f | xargs chmod 664

change the permissions of all regular/normal files in the current directory, print0 is used for handling files with newlines in their file name
find . -type f -print0 | xargs -0 chmod 664

change the permissions of all regular/normal files in the file system
chmod 640 `find ./ -type f -print`

Change the permission of all regular files under current directory tree to 644
find . -type f -exec chmod 644 {} \;

change the permission of all the rpm files in the entire file system to 755
find / -name *.rpm -exec chmod 755 '{}' \;

change the permissions of all the directories in the current folder
chmod 751 `find ./ -type d -print`

change the permissions of all the directories in the current folder
find . -type d -exec chmod 2775 {} \;

change the permissions of all the directories in the current folder
find . -type d | xargs chmod 2775

change the permissions of all the directories in the current folder, print0 is used for handling files with newlines in their file name
find . -type d -print0 | xargs -0 chmod 2775

change the permissions of all the directories in the folder "/path/to/someDirectory" to 755
sudo find /path/to/someDirectory -type d -print0 | xargs -0 sudo chmod 755

change the permissions of all the directories in the folder root_dir to 555
find root_dir -type d -exec chmod 555 {} \;

change the permission of all the directories to 755 in the current folder
find -type d -exec chmod 755 {} \;

change the permissions of all the directories to 755 in the folder "/home/nobody/public_html"
find /home/nobody/public_html -type d -exec chmod 755 {} \;

change the permissions of all the files ending with "fits" in the folder "/store/01"
find /store/01 -name "*.fits" -exec chmod -x+r {} \; \

change the permissions of all the files ending with "fits" in the folder "/store/01" and save the output file names to a log file
find /store/01 -name "*.fits" -exec chmod -x+r {} \; -exec ls -l {} \; | tee ALL_FILES.LOG

change the permission of all the files in the current directory to 664 and change the permission of all the directories  in the current folder to 775.
find . \( -type f -exec sudo chmod 664 "{}" \; \) , \( -type d -exec sudo chmod 775 "{}" \; \)

change the permissions of all the normal files in a directory
find /path/to/dir/ -type f -print0 | xargs -0 chmod 644

change the permission of all the php files in the folder /var/www/ to 700
find /var/www/ -type f -iname "*.php" -exec chmod 700 {} \;

change the permission of all the normal/regular files from 777 to 755 in the folder "/home/user/demo"
find /home/user/demo -type f -perm 777 -print -exec chmod 755 {} \;

change the permissions of all the regular files in the current folder
find . -type f -exec chmod 500 {} ';'

change the permissions of all the regular/normal files in the current folder
chmod 640 `find ./ -type f -print`

change the permissions of all the regular/normal files in the current folder
sudo find . -type f -exec chmod 644 {} +

change the permission of all the regular/normal files in the current folder from 777 to 755
find . -type f -perm 777 -exec chmod 755 {} \;

change the permission of all the regular files in the folder /home to 700
find /home -type f -perm 0777 -print -exec chmod 700 {} \;

change the permissions of all the regular files in the folder root_dir to 444
find root_dir -type f -exec chmod 444 {} \;

change the permission of all the normal/regular files to 644 in the current folder
find -type f -exec chmod 644 {} \;

change the permissions of all the regular/normal files to 644 in the folder /home/nobody/public_html
find /home/nobody/public_html -type f -exec chmod 644 {} \;

change the permissions of all the regular/normal files to 664 in the current folder
find . -type f -exec chmod 664 {} \;

change the permissions of al the directories in the current folder
sudo find . -type d -exec chmod 755 {} +

Change the permissions of every directory in the current directory and all files and directories within them to 700
find . -maxdepth 1 -type d -exec chmod -R 700 {} \;

change the permissions of mp3 files in the folder /var/ftp/mp3 to 644
find /var/ftp/mp3 -name '*.mp3' -type f -exec chmod 644 {} \;

Change the permissions of the current directory and all its subdirectories to 755.
find . -type d -exec chmod 755 {} \;

change the permissions of the directories from 777 to 755 in the folder "/var/www/html"
find /var/www/html -type d -perm 777 -print -exec chmod 755 {} \;

Change the permission to 0644 for all files under current directory
find . -type f -exec chmod 0644 {} +

Change the permission to 0644 for all files under current directory
find . -type f -exec chmod 0644 {} \;

Change the permission to 0755 for all directories under current directory
find . -type d -exec chmod 0755 {} \;

Change the permission to 644 for all files under current directory
find . -type f | xargs -I{} chmod -v 644 {}

Change the permission to 644 for all files under current directory
find . -type f | xargs chmod -v 644

Change the permission to 755 for all directories under current directory
find . -type d | xargs chmod -v 755

Change the user and group of all files and directories under /var/www to www-data:www-data
find /var/www -print0 | xargs -0 chown www-data:www-data

Change the user to daisy for directories and subdirectories owned by harry
find . -type d -user harry -exec chown daisy {} \;

change the word "GHBAG" to "stream-agg" in all the file names in current folder which have the word "-GHBAG-" in their name
find . -name '*-GHBAG-*' -exec bash -c 'mv $0 ${0/GHBAG/stream-agg}' {} \;

change the word "GHBAG" to "stream-agg" in all the file names in current folder which have the word "-GHBAG-" in their name
find . -name '*-GHBAG-*' -exec rename 's/GHBAG/stream-agg/' {} +

change to a directory and search for a file in that directory
cd /nfs//office/ && find . -name '.user.log'

Change to directory 'foo' and print to terminal all received on standard input
cd foo | cat

Change to directory listed in file '$HOME/.lastdir'
cd `cat $HOME/.lastdir`

Change to parent directory and resolve any symlinks in the resulting path, making the physical path the current one.
cd -P ..

Change to the directory containing the "oracle" executable
cd "$(dirname "$(which oracle)")"

Change to the directory of the executable "<file>"
cd `which <file> | xargs dirname`

Change to the directory of the executable "python"
cd `dirname $(which python)`

Changes to the directory where 'ssh' executable is located.
cd $(dirname $(which ssh));

change user and group of the file "/var/run/docker.sock" to user root and group dockerroot
sudo chown root:dockerroot /var/run/docker.sock

change user and group of the file /usr/bin/aws to user amzadm and group root
chown amzadm.root  /usr/bin/aws

change user and group of the file bin to user and group root:wheel
sudo chown root:wheel bin

change user of the direct public_html to user owner and group nobody
chown owner:nobody public_html

Change user ownership to `foo' for files with UID=1005
find / -user 1005 -exec chown -h foo {} \;

Change user to "amzadm" and group to "root" of "/usr/bin/aws"
chown amzadm.root  /usr/bin/aws

Check all .txt files whether they contain "needle"
find . -type f -iname "*.txt" -print | xargs grep "needle"

Check all .txt files whose names may contain spaces whether they contain "needle"
find . -type f -iname "*.txt" -print0 | xargs -0 grep "needle"

Checks compressed file integrity.
bzip2 -t file.bz2

check find version
find --version

Check if "$file" contains DOS line endings
od -t x2 -N 1000 $file | cut -c8- | egrep -m1 -q ' 0d| 0d|0d$'

Check if "/path/to/file" exists on "remote_host"
ssh remote_host test -f "/path/to/file" && echo found || echo not found

Check if "\[$VLABEL\]" is mounted and save the result in variable "AMV"
AMV=$(mount -l | grep "\[$VLABEL\]")

Check if "server1" and "server2" have the same list of RPMs installed
diff <(ssh server1 'rpm -qa | sort') <(ssh server2 'rpm -qa | sort')

Check if "~/mnt/sdc1" is mounted
mount | grep -q ~/mnt/sdc1

Check if $path_in_question is mount point of filesystem
df $path_in_question | grep " $path_in_question$"

Check if *RBENV* variable is defined in tmux session 'sessname' environment.
tmux show-environment -t sessname | grep RBENV

Check if a drive is mounted to nfs
mount |grep nfs

Check if a drive with UUID "$UUID" is mounted
mount | grep $(readlink -f /dev/disk/by-uuid/$UUID )

check if a named screen session already exists
screen -list | awk '{print $1}' | grep -q "$1$"

Check if command "c++" and command "g++" are equal
[ `md5sum $(which c++) | cut -d' ' -f1` == `md5sum $(which g++) | cut -d' ' -f1` ] && echo Yes, equal content || echo No, unequal content

Check if content of all top-level *.txt files in the current directory contain only unique lines
cat *.txt | sort | sort -u -c

Check if current system is running in 64-bit addressing.
uname -m | grep '64'

Check if directory $some_dir is empty
find "$some_dir" -prune -empty -type d | read && echo empty || echo "not empty"

Check if directory $some_dir is empty
find "`echo "$some_dir"`" -maxdepth 0 -empty

Check if files named 'file' in 1 level down the current directory whose status were changed more than 1 hour ago were not found and print old if that's true
[[ "$(find . -maxdepth 1 -cmin +60 -name file)" = "" ]] && echo "old"

check if there any files from the .git folder after excluding it using the prune command
find . -path ./.git -prune -o -print -a \( -type f -o -type l -o -type d \) | grep '.git'

Check if process ID 1 exists (init or systemd) and current user has permission to send it signals.
kill -0 1

Check if RBENV is defined in the current tmux session environment
tmux show-environment | grep RBENV

Check if the $somedir directory is empty
find "$somedir" -maxdepth 0 -empty -exec echo {} is empty. \;

Check if the contents of file "subset" is a subset of file "set"
comm -23 <(sort subset | uniq) <(sort set | uniq) | head -1

check if the file pointed by the symbolic exists or not and display those which are broken
find . -type l -! -exec test -e {} \; -print

Check if the file "somelink" links to exists
ls `readlink somelink`

Check if your/dir is empty or not
[ $(find your/dir -prune -empty) = your/dir ]

Check md5sum of directory /path against the checksum saved in file 'file'
du -csxb /path | md5sum -c file

check readline bindings for "\x61"
bind -p | grep $'"\x61"'

Checks that 'monit' user is in 'www-data' group.
groups monit |grep www-data

Check the environment variables generated by switching to the root account.
sudo env

Check the bit width of static library "libsomefile.a"
readelf -a -W libsomefile.a | grep Class: | sort | uniq

check the file type of all the regular/normal files in the current directory and save the output to the file /tmp/filetypes.log
find . -type f -exec file {} \; > /tmp/filetypes.log

check the previous alias in current list
alias | grep my_previous_alias

Check the syntax of all PHP files under the current directory
find . -type f -name "*.php" -exec php -l {} \;

check the type of files in the folder /usr/bin
find /usr/bin | xargs file

Check whether "/full/path" is a mount point with no output and using the exit code
df /full/path | grep -q /full/path

Check which package the "sort" command belongs to in rpm
rpm -qf `which sort`

Clean directories and subdirectories of the temporary files generated during normal use
find . \( -name a.out -o -name '*.o' -o -name 'core' \) -exec rm {} \;

Clears terminal screen.
echo `clear`

Clean the current directory from all subversion directories recursively
find . -type d -name ".svn" -print | parallel rm -rf

Clean the current directory from all subversion directories recursively
find . -type d -name ".svn" -print | xargs rm -rf

Clear the in-memory history
history -c

Clear the in-memory history and read from the current history file
history -cr

Clear the terminal's search history
history -c

Clean up the output of "unzip -l" and print only the "jar" files
unzip -l some-jars-and-textfiles.zip | tr '[:blank:]' \\t | cut -f 5 | grep jar

Correct permissions for directories in the web directory
find /your/webdir/ -type d -print0 | xargs -0 chmod 755

Correct permissions for files in the web directory
find /your/webdir -type f | xargs chmod 644

(Mac OSX specific) Collect process information and display only lines containing pattern specified by variable "app_name".
top -l 1  | grep $app_name

Combine every two lines of standard input
paste -d "" - -

Compare "current.log" and "previous.log" line by line and print lines containing regex pattern ">\|<"
diff current.log previous.log | grep ">\|<" #comparring users lists

Compare "fastcgi_params" and "fastcgi.conf" line by line, output 3 lines of unified context, and print the C function the change is in
diff -up fastcgi_params fastcgi.conf

Compare "file1" and "file2" line by line with 3 lines of unified context
diff -u file1 file2

Compare *.csv files in the current directory tree with their analogs stored in /some/other/path/
find . -name "*.csv" -exec diff {} /some/other/path/{} ";" -print

Compare *.csv files in the current directory tree with their analogs stored in /some/other/path/ prompting before running `diff'
find . -okdir diff {} /some/other/path/{} ";"

Compare each .xml file under the current directory with a file of the same name in "/destination/dir/2"
find . -name *.xml -exec diff {} /destination/dir/2/{} \;

compare each C header file in or below the current directory with the file /tmp/master
find . -name '*.h' -execdir diff -u '{}' /tmp/master ';'

Compare each C header file in or below the current directory with file /tmp/master
find . -name '*.h' -execdir /bin/diff -u '{}' /tmp/master ';'

Compare each file in "repos1/" and "repos2/", treat absent files as empty, ignore differences in whitespace and tab expansions, and print 3 lines of unified context
diff -ENwbur repos1/ repos2/

Compare text "hello" and "goodbye" line by line
diff <(echo hello) <(echo goodbye)

Compose filepath as folder path where file $SRC is located, and lowercase filename of $SRC file, and save it in 'DST' variable
DST=`dirname "${SRC}"`/`basename "${SRC}" | tr '[A-Z]' '[a-z]'`

Compare files 'file1' and 'file2' and print in three columns strings unique for first file, second file, and common ones
comm abc def

Compare files in "/tmp/dir1" and "/tmp/dir2", treat absent files as empty and all files as text, and print 3 lines of unified context
diff -Naur dir1/ dir2

Compare files in "/tmp/dir1" and "/tmp/dir2", treating absent files as empty and all files as text
diff -Nar /tmp/dir1 /tmp/dir2/

Compare sorted files 'f1.txt' and 'f2.txt' and print in three columns strings unique for first file, second file, and common ones
comm <(sort -n f1.txt) <(sort -n f2.txt)

Compare sorted files 'f1.txt' and 'f2.txt' and print in three columns strings unique for first file, second file, and common ones
comm <(sort f1.txt) <(sort f2.txt)

Compare the contents of "/bin" and "/usr/bin" line by line
diff <(ls /bin) <(ls /usr/bin)

Compare the contents of gzip-ompressed files "file1" and "file2"
diff <(zcat file1.gz) <(zcat file2.gz)

Compare the files in 'FOLDER1' and 'FOLDER2' and show which ones are indentical and which ones differ
find FOLDER1 -type f -print0 | xargs -0 -I % find FOLDER2 -type f -exec diff -qs --from-file="%" '{}' \+

Compares two listings 'ls' and 'ls *Music*', showing only strings that unique for first listing.
comm -23 <(ls) <(ls *Music*)

Decompress "/file/address/file.tar.gz" to standard output
gzip -dc /file/address/file.tar.gz

Compress "Hello world", base64 encode, and save to variable "FOO"
FOO=$(echo "Hello world" | gzip | base64)

Compress "archive.tar"
gzip archive.tar

Uncompress "archive.tar.gz" and extract the archive to "/destination"
gzip -dc archive.tar.gz | tar -xf - -C /destination

Compress "hello world" and save to variable "hey"
hey=$(echo "hello world" | gzip -cf)

Compress "my_large_file" with gzip and split the result into files of size 1024 MiB with prefix "myfile_split.gz_"
gzip -c my_large_file | split -b 1024MiB - myfile_split.gz_

Decompress "path/to/test/file.gz" to standard output and save all lines matching "my regex" to files with a 1000000 line limit
gzip -dc path/to/test/file.gz | grep -P --regexp='my regex' | split -dl1000000 - file

Decompress "path/to/test/file.gz" to standard output and save all lines matching "my regex" to files with a 1000000 line limit
gzip -dc path/to/test/file.gz | grep -P --regexp='my regex' | split -l1000000

Compress $file file using gzip
gzip "$file"

Decompress ${set1[@]} files with gzip
gzip -d ${set1[@]} &

Decompress 'file.gz'
gzip -d file.gz

Decompress 'file.gz' to standard output and execute the output in bash
gzip -d --stdout file.gz | bash

Compress .log files in /var and below
find /var -iname \*.log | xargs bzip -

Compress .log files in /var and below on an individual basis
find /var -iname \*.log -exec bzip {} \;

Compress all ".txt" files in all sub directories with gzip
gzip */*.txt

Compress all ".txt" files in the current directory tree with gzip
find . -type f -name "*.txt" -exec gzip {} \;

Compresses all '*.xml' files under current directory with 'bzip2' utility.
find -name \*.xml -print0 | xargs -0 -n 1 -P 3 bzip2

Compress all *.img files using bzip2
find ./ -name "*.img" -exec bzip2 -v {} \;

Compress all .txt files in the current directory tree to archive "txt.zip"
find . -name '*.txt' | xargs zip -9 txt.zip

Uncompress and unarchive "data.tar.gz"
gzip -dc data.tar.gz | tar -xvf -

Decompress and unarchive "hello-0.2.tar.gz"
gzip -dc hello-0.2.tar.gz | tar -xf -

Compress all directories found in $LOGDIR wherein a file's data has been modified within the last 24 hours
find $LOGDIR -type d -mtime +0 -exec compress -r {} \;

Compress all directories found in directory tree $LOGDIR that have been modified within the last 24 hours
find $LOGDIR -type d -mtime -1 -exec compress -r {} \;

Compress and display the gzipped filenames of every file on the system that is greater than 100000 bytes and ends in ".log"
sudo find / -xdev -type f -size +100000 -name "*.log" -exec gzip -v {} \; 2>&1 | awk '{print $6}'

Compress and display the original filename of every file on the system that is greater than 100000 bytes and ends in ".log"
sudo find / -xdev -type f -size +100000 -name "*.log" -exec gzip {} \; -exec echo {} \;

Decompress and extract '/usr/src/redhat/SOURCES/source-one.tar.gz'
gzip -dc /usr/src/redhat/SOURCES/source-one.tar.gz | tar -xvvf -

Decompress and extract 'archive.tar.gz' into '/destination'
gzip -dc archive.tar.gz | tar -xf - -C /destination

Decompress and extract 'libxml2-sources-2.7.7.tar.gz'
gzip -dc libxml2-sources-2.7.7.tar.gz | tar xvf -

Uncompress all files listed in "list.txt" and send to "./a.out"
zcat $(cat list.txt) | ./a.out

Compresses all files in a current folder (not recursively).
bzip2 *

Compress all files in directory "$PATH_TO_LOGS" that were last modified more than "$SOME_NUMBER_OF_DAYS" days ago
find $PATH_TO_LOGS -maxdepth 1 -mtime +$SOME_NUMBER_OF_DAYS -exec gzip -N {} \;

Compress all files in the "$FILE" directory tree that were last modified 30 days ago
find $FILE -type f -mtime 30 -exec gzip {} \;

Compress all files in the "$FILE" directory tree that were last modified 30 days ago and have not already been compressed with gzip
find $FILE -type f -not -name '*.gz' -mtime 30 -exec gzip {} \;

Compresses all files in the directory 'PATH_TO_FOLDER' without recursion and keeps uncompressed files from deletion.
find PATH_TO_FOLDER -maxdepth 1 -type f -exec bzip2 -zk {} \;

Compresses all files listed in array $*, executing in background.
compress $* &

Compress all files under /source directory tree using gzip with best compression method
find /source -type f -print0 | xargs -0 -n 1 -P $CORES gzip -9

Compress all files under current directory tree with gzip
find . -type f -print0 | xargs -0r gzip

Compress all files with '.txt' extension under current directory
echo *.txt | xargs gzip -9

compress all the non-compressed  files in the current directory.
find . \! -name "*.Z" -exec compress -f {} \;

Compress from standard input and print the byte count preceded with 'gzip.'
echo gzip. $( gzip | wc -c )

Compress from standard input with gzip
gzip

Compress each file in all directories matching pattern "*.1"
find *.1  -exec tar czf '{}.tgz' '{}' --remove-files \;

Compress every file in the current directory that matches "*cache.html" and keep the original file
gzip -k *cache.html

Compress every file in the current directory tree that matches "*cache.html" and keep the original file
find . -type f -name "*cache.html" -exec gzip -k {} \;

Compress every file in the current directory tree that matches "*cache.html" and keep the original file
find . -type f -name "*cache.html" -exec sh -c "gzip < {} > {}.gz" \;

Compress every file in the current directory tree with gzip and keep file extensions the same
find folder -type f -exec gzip -9 {} \; -exec mv {}.gz {} \;

Uncompress file "dbdump.sql.gz" through standard input and pass to "mysql"
cat dbdump.sql.gz | gzip -cd | mysql

Composes full process tree with process id numbers, and prints only those strings that contain 'git'.
pstree -p | grep git

Compress files excluding *.Z files
find . \! -name "*.Z" -exec compress -f {} \;

Compress the file 'file' with 'bzip2' and append all output to the file 'logfile' and stdout
bzip2 file | tee -a logfile

Compresses with compression level 9 all files under the current folder but already compressed '*.bz2' files, performing in background.
find "$1" -type f | egrep -v '\.bz2' | xargs bzip2 -9 &

Concatenate all .txt files residing in the current directory tree
find . -name '*.txt' -not -name "all.txt" | xargs cat > all.txt

Concatenate all files under the current directory and below that contain "test" in their names
find . -iname '*test*' -exec cat {} \;

Concatenate all PDF files under current directory into all.pdf
pdfunite `find . -name "*.pdf" | sort` all.pdf

Concatenate files containing `test' in their names
find . -name '*test*' -exec cat {} \;

Concatenate with a space every other line in "input.txt"
paste -s -d' \n' input.txt

Instantly kill all processes whose command is 'myprocess'.
kill -9 \`pgrep myprocess\`

Constantly write "y" to backingfile as a background process
yes > backingfile &

Convert "/usr/share/man/man1/man.1.gz" to html
zcat /usr/share/man/man1/man.1.gz  | groff -mandoc -Thtml

Convert "1199092913" to dotted decimal IPv4 address
ping -c1 1199092913 | head -n1 | grep -Eow "[0-9]+[.][0-9]+[.][0-9]+[.][0-9]+"

Convert ";" separated list "luke;yoda;leila" to new line separated list
echo "luke;yoda;leila" | tr ";" "\n"

Convert "abc" to a string of hexadecimal bytes
echo abc | od -A n -v -t x1 | tr -d ' \n'

Convert "some random\nbytes" to "%" separated hexadecimal byte values
echo -ne 'some random\nbytes' | xxd -plain | tr -d '\n' | sed 's/\(..\)/%\1/g'

Convert *.au files to *.wav files using `sox'
find -type f -name '*.au' | awk '{printf "%s %s\n",$0,$0".wav" }' | xargs sox

Convert *.doc files in the current directory tree to the .txt format
find . -name '*.doc' | while read i; do antiword -i 1 "${i}" >"${i/doc/txt}"; done

Convert *.doc files in the current directory tree to the .txt format and remove the original files
find . -name '*.doc' | while read i; do antiword -i 1 "${i}" >"${i/doc/txt}" && rm "${i}"; done

Convert all .txt files under and below the current directory from the DOS format to Unix
find . -name *.txt | xargs dos2unix

Convert all DOS files under and below the current directory to the Unix format
find . -type f -exec dos2unix {} \;

Convert all DOS files under and below the current directory to the Unix format
find . -type f -exec dos2unix {} {} \;

Convert all DOS files under and below the current directory to the Unix format
find . -type f -print0 | xargs -0 -n 1 -P 4 dos2unix

Convert all image.pdf files to image.png files under ./polkadots
find ./polkadots -name 'image.pdf' -exec convert -transparent white -fuzz 10% {} image.png \; -print

Convert all m4a sound files in a directory and its subdirectories to mp3 files
find . -type f -name '*.m4a' -exec bash -c 'avconv -i "$0" "${0/%m4a/mp3}"' '{}' \;

Convert all bmp files to png in the current directory tree
find . -name "*bmp" -print0 | xargs -0 -l -i basename "{}" ".bmp" | xargs -0 -l -i convert "{}.bmp" "{}.png"

Connect as ssh user specified by variable USER to host whose IP address or host name is specified by HOST, and copy remote file specified by variable SRC to location on local host specified by variable DEST, disabling progress info but enabling debug info.
scp -qv $USER@$HOST:$SRC $DEST

Connect via ssh to "your.server.example.com" and recursively copy directory "/path/to/foo" on this host to direcotry "/home/user/Desktop" on local host, using "blowfish" cipher algorithm.
scp -c blowfish -r user@your.server.example.com:/path/to/foo /home/user/Desktop/

Convert multiple *.jpg files from JPEG to PDF format
find /path/to/files -iname '*.jpg' -exec mogrify -format pdf {} +

Convert relative path "/x/y/../../a/b/z/../c/d" into absolute path with resolved symbolic links
readlink -f /x/y/../../a/b/z/../c/d

Convert relative symbolic link "$link" to absolute symbolic link
ln -sf "$(readlink -f "$link")" "$link"

Convert standard input into a dump of octal bytes without the first 8 bytes of address and count the unique results
od | cut -b 8- | xargs -n 1 | sort | uniq | wc -l

Convert the contents of "foo.md" to GitHub style markdown and display with "lynx"
cat foo.md | pandoc -f markdown_github | lynx -stdin

Convert the contents of 'var1' variable to lowercase
var1=`echo $var1 | tr '[A-Z]' '[a-z]'`

Convert the first 1024 bytes of "/dev/urandom" to a string of hexadecimal bytes
head -c1024 /dev/urandom | xxd -p | tr -d $'\n'

Convert the first 16 characters in "/dev/random" to a single hexadecimal value
head /dev/random -c16 | od -tx1 -w16 | head -n1 | cut -d' ' -f2- | tr -d ' '

Convert the string "$myArray" into a bash array using ";" delimiters
IFS=';' read -a myArray <<< "$myArray"

Connect to "$USER_AT_HOST" using connection sharing on "$SSHSOCKET" and request the master to exit
ssh -S "$SSHSOCKET" -O exit "$USER_AT_HOST"

Connect to port 1234 of specified IP address or hostname as ssh user "user", and copy all visible files in /var/www/mywebsite/dumps/ on this host to local directory /myNewPathOnCurrentLocalMachine - this directory must already exist on local host.
scp -P 1234 user@[ip address or host name]:/var/www/mywebsite/dumps/* /var/www/myNewPathOnCurrentLocalMachine

Connect to port 2222 of example.com as ssh user "user", and copy local file "/absolute_path/source-folder/some-file" to remote directory "/absolute_path/destination-folder"
scp -P 2222 /absolute_path/source-folder/some-file user@example.com:/absolute_path/destination-folder

Connect to host "$USER_AT_HOST" in master mode in the background without executing any commands and set the ControlPath to "$SSHSOCKET"
ssh -M -f -N -o ControlPath="$SSHSOCKET" "$USER_AT_HOST"

Connect to host "hostname" as user "username", automatically add the host key to the list of known hosts, and execute "pwd; ls" non-interactively
ssh -o StrictHostKeyChecking=no -l username hostname "pwd; ls"

Connect to host "remotehost" as ssh user "user" to copy remote file "/location/KMST_DataFile_*.kms" to current directory on local host.
scp -v user@remotehost:/location/KMST_DataFile_*.kms

Connect to host "server_b" as ssh user "user" and copy local file "/my_folder/my_file.xml" to server_b's directory "/my_new_folder/".
scp -v /my_folder/my_file.xml user@server_b:/my_new_folder/

Connect to host 'hostname' as user 'username' by forcing host key confirmation
ssh -o UserKnownHostsFile=/dev/null username@hostname

Convert Unix `cal` output to latex table code.
cal 02 2012|perl -F'(.{1,3})' -anE'BEGIN{$,="\t&";$\="\t\\\\\n"}$.==1||eof||do{$i//=@F;print@F[map{$_*2-1}(1..$i/2)]}'

Convert Unix `cal` output to latex table code.
cal 02 2012|perl -lnE'$.==1||eof||do{$,="\t&";$\="\t\\\\\n";$l=$_;print map{substr($l,$_*3,3)}(1..5)}'

Continuously send "Y" to input of "command-that-asks-for-input"
yes Y | command-that-asks-for-input

Continuously send "Yes" plus newline to the program "./ittp-update.sh"
yes Yes | ./ittp-update.sh

Continuously send "a" then "b" to "script.py"
yes $'a\nb' | script.py

Continuously send "y" as input to "./MyScript.sh" and ignore standard error
yes 2>/dev/null | ./MyScript.sh

Continuously send "y" to all prompts of command "rm"
yes | rm

Continuously send "y" to input of "command"
yes | command

Continuously send "y" to input of "command-that-asks-for-input"
yes | command-that-asks-for-input

Continuously output "y" at a rate of 10 bytes per second
yes | pv --quiet --rate-limit 10

Continuously print "123456789" and line buffer the output via "grep" for input to "{ head -n 1; head -n 1; }"
yes 123456789 | grep --line-buffered . | { head -n 1; head -n 1; }

Continuously write "Hidden" over the entire "/dev/sdb" disk
yes "Hidden" | dd of=/dev/sdb

Continuously write "Hidden" separated by null terminators over the entire "/dev/sdb" disk
yes "Hidden" | tr '\n' '\0' | dd of=/dev/sdb

Continuously write "Hidden" separated by spaces over the entire "/dev/sdb" disk
yes "Hidden" | paste -d' ' -s - | dd of=/dev/sdb

Continuously write "UUUUUUUUUUUUUUUUU" without newlines to "/dev/to/overwrite"
yes 'UUUUUUUUUUUUUUUUU' | tr -d '\n' > /dev/to/overwrite

converts all absolute symbolic links to relative symbolic links
find . -lname "`pwd`*" -exec sh -c 'ln -snvf `python -c "from os.path import *; print relpath(\"$(readlink {})\",dirname(\"{}\"))"` {}' \;

convert all the normal files in the current folder from dos format to unix format (remove extra characters at the end etc.)
find . -type f -exec dos2unix {} \;

convert all the regular/normal files in the current folder from dos to unix format
find . -name "*" -type f -exec dos2unix {} \;

convert epoch second timestamp to date
date -d @1278999698 +'%Y-%m-%d %H:%M:%S'

Copies ""$project_dir"/iTunesArtwork", to the 'Payload/iTunesArtwork', rewriting files if necessary.
cp -f "$project_dir"/iTunesArtwork Payload/iTunesArtwork

Copies '[MacVim_source_folder]/src/MacVim/mvim' to the  '/usr/local/bin', printing info message on each operation.
cp -v [MacVim_source_folder]/src/MacVim/mvim /usr/local/bin

Copies 'libgtest_main.so' and 'libgtest.so' to '/usr/lib/', preserving all attributes, and copying symlinks as symlinks, without following in source files.
sudo cp -a libgtest_main.so libgtest.so /usr/lib/

Copies 'src' to 'dest' preserving overwriting the existing files.
cp -n src dest

Copies all files like "*FooBar*" under the current directory to the '~/foobar' directory.
find . -name '*FooBar*' -exec cp -t ~/foobar -- {} +

Copies all files like 'lib*.so' to '~/usr/gtest/lib/' directory.
cp lib*.so ~/usr/gtest/lib

Copies all files under the current directory but ones with '*/not-from-here/*' in path to the '/dest/' directory.
find . -type f -not -iname '*/not-from-here/*' -exec cp '{}' '/dest/{}' ';'

Copies all files under the current directory like any-cased '*foobar*' to the '~/foo/bar' directory.
find . -iname "*foobar*" -exec cp "{}" ~/foo/bar \;

Copies all files under the current folder like "file.ext" with "FooBar" in the path to the root of the current folder, preserving mode, ownership and timestamp attributes.
find . -name "file.ext"| grep "FooBar" | xargs -i cp -p "{}" .

Copies all files with "FooBar" in the path under the current directory to the '~/foo/bar' directory.
find . | grep FooBar | xargs -I{} cp {} ~/foo/bar

Copies defined file to the target folder without overwriting existing files.
cp -n

Copies files 'src/prog.js' and 'images/icon.jpg' with fully-defined path to '/tmp/package' directory.
cp --parents src/prog.js images/icon.jpg /tmp/package

Copies newest file under the current folder to the '/tmp/'
cp $(ls -1tr * | tail -1) /tmp/

Copies file '/boot/config-`uname -r`' to the  '.config', printing info message and prompting before owerwriting files.
cp -vi /boot/config-`uname -r` .config

Copies file 'file.dat' to each top-level directory in the current directory.
ls | xargs -n 1 cp -i file.dat

Copies file 'file.txt' to each top-level directory in the current directory.
ls -d */ | xargs -iA cp file.txt A

Copies file 'file1' to each of directories 'dir1', 'dir2', 'dir3'.
echo dir1 dir2 dir3 | xargs -n 1 cp file1

Copies file 'fileName.txt' to each of directories listed in the 'allFolders.txt' list.
cat allFolders.txt | xargs -n 1 cp fileName.txt

Copies file 'index.html' to each top-level directory in the current directory.
find . -mindepth 1 -maxdepth 1 -type d| xargs -n 1 cp -i index.html

Copies file 'index.html' to each top-level directory in the current directory beginning with 'd'.
find . -mindepth 1 -maxdepth 1 -type d| grep \/a |xargs -n 1 cp -i index.html

Mount "/path/to/device" on "/path/to/mount/location" as a loop back device
mount /path/to/device /path/to/mount/location -o loop

Mount "/tmp/loop.img" on "/mnt/image" as a loop back device
mount /tmp/loop.img /mnt/image -o loop

Mount "/windows" using /etc/fstab entry
mount /windows

Mount "device_name" on "mount_point"
sudo mount device_name mount_point

Mount "ext4" filesystem "/dev/xvdf" on "/vol"
sudo mount /dev/xvdf /vol -t ext4

Mount "ext4" filesystem "/dev/xvdf1" on "/vol"
sudo mount /dev/xvdf1 /vol -t ext4

Mount "nifs" filesystem "/dev/mapper/myldm" on "/mnt" as read only
mount -t ntfs -o ro /dev/mapper/myldm /mnt

Mount "ntfs-3g" filesystem "/dev/mapper/myvolume" on "/media/volume"
mount -t ntfs-3g /dev/mapper/myvolume /media/volume

Mount "proc" file system on "/var/snmp3/proc"
mount -t proc none /var/snmp3/proc

Mount "project1/link1" as a bind directed at "/absolute/path/to/some/where/else"
mount --bind /absolute/path/to/some/where/else project1/link1

Mount "tmpfs" filesystem to "/path/to/dir"
mount none -t tmpfs /path/to/dir

Mount "vfat" filesystem "/dev/sda7" to "/mnt/my_partition" with read and write permission, umask of files and directories set to "0000", and save in fstab and allow ordinary users to mount
sudo mount -t vfat -o rw,auto,user,fmask=0000,dmask=0000 /dev/sda7 /mnt/my_partition

Mount a partition in "$IMAGE" with offset "$OFFSET" to "media/$DEST" as read only using a loop device
mount -o ro,loop,offset=$OFFSET -t auto $IMAGE /media/$DEST

Counts all *.mod files in a /boot/grub/ folder.
ls -l /boot/grub/*.mod | wc -l

Count all directories in maximum 1 level down the current directory
find . -maxdepth 1 -type d -exec ls -dlrt {} \; | wc --lines

Count all directories under current directory
find . -type d -exec ls -dlrt {} \; | wc --lines

Mount all filesystems in /etc/fstab
sudo mount -a

Counts all lines in $i file.
cat $i | wc -l

Counts all files in a DIR_NAME folder and subfolders.
find DIR_NAME -type f | wc -l

Counts all files in a current folder and in subfolders one-level lower, and sort folder list by number of files within.
find . -maxdepth 1 -type d -print0 | xargs -0 -I {} sh -c 'echo  $(find {} | wc -l) {}' | sort -n

Counts all files in a current folder and in subfolders one-level lower and sorts result by number of files within.
find . -maxdepth 1 -type d -print0 | xargs -0 -I {} sh -c 'echo -e $(find "{}" -printf "\n" | wc -l) "{}"' | sort -n

Counts all files in a current folder and in subfolders one-level lower, sorts result and pipes to the less pager.
find . -maxdepth 1 -type d -print0 | xargs -0 -I {} sh -c 'echo $(find {} | wc -l) \\t {}' | sort -rn | less

Count all files under "/DIR"
find /DIR -type f -print0 | tr -dc '\0' | wc -c

Count and show the number of lines for each PHP files in the current directory tree
find . -name '*.php' | xargs wc -l

count all the html files having a specifc word in a folder.
find /usr/src -name "*.html" -exec grep -l foo '{}' ';' | wc -l

Count all the lines of all php files in current directory recursively
find -name '*.php' | xargs cat | wc -l

Count all the lines of code in the current directory recursively.
find ./ -type f -exec wc -l {}  \; | cut -d' ' -f1 | paste -sd+ | bc

Count all the mp3 files in the music user's home and subdirs.
find ~music -type f -iname *.mp3 | wc -l

count all the regular files that are present in a directory
find . -type f | wc -l

Counts all top-level files in a current folder.
ls -1 | wc -l

Hunting down files with at least one banana
find . -type f -print0| xargs -0 grep -c banana| grep -v ":0$"

Mount image "test" to loop device "/dev/loop0"
sudo mount -o loop /dev/loop0 test

Count files in $DIR_TO_CLEAN that are older than $DAYS_TO_SAVE days
find "$DIR_TO_CLEAN" -mtime +$DAYS_TO_SAVE | wc -l

Counts lines in each *.cpp, *.c, *.h file.
wc -l `find . -type f \( -name "*.cpp" -o -name "*.c" -o -name "*.h" \) -print`

Counts lines in each *.php file.
find . -name '*.php' -type f | xargs wc -l

Counts lines in each *.php file.
wc -l $(find . -name "*.php")

Counts lines in each *.php file.
wc -l `find . -name "*.php"`

Counts lines in each *.php file.
wc -l `tree -if --noreport | grep -e'\.php$'`

Counts lines in each *.php file, sorted by number of lines, descending.
find . -name '*.php' -type f | xargs wc -l | sort -nr

Counts lines in each *.php file sorted by file path.
find . -name '*.php' -type f | sort | xargs wc -l

Counts lines in each of *.php files in a current folder and subfolders ignoring 'tests' folder and prints total count as well.
find . -name tests -prune -o -type f -name '*.php' | xargs wc -l

Counts lines in each of *.php files in a current folder and subfolders ignoring 'tests*' folders and prints total count as well.
find . -name "*.php" -not -path "./tests*" | xargs wc -l

Counts lines in each of *.php files in current folder with subfolders and prints total count as well.
find . -name '*.php' | xargs wc -l | sort -r

Counts lines in file 'file1' and shows progress bar while doing.
pv file1 | wc -l

Counts lines in file 'filename' ignoring empty lines and lines with spaces only.
cat 'filename' | grep '[^ ]' | wc -l

Counts lines in file file1 and shows progress bar while doing.
bar file1 | wc -l

Counts lines in file file1 and shows progress bar while doing.
tail -n 100 file1 | bar | wc -l

Counts lines in file file1 and shows progress bar while doing.
tail -n 100 file1 | pv | wc -l

Count line numbers on files and record each count along with individual file name.
find /home/my_dir -name '*.txt' | xargs grep -c ^.*

Counts lines of 'command' output.
command | wc -l

Counts lines of 'file' file.
wc -l file

Counts lines of /etc/fstab file.
cat /etc/fstab | wc -l

Counts lines of all *.txt files in a current folder.
cat *.txt | wc -l

count lines of C or C++ or Obj-C code under the current directory
find . \( -name "*.c" -or -name "*.cpp" -or -name "*.h" -or -name "*.m" \) -print0 | xargs -0 wc

count lines of C or C++ or Obj-C or Java code under the current directory
find . \( -name "*.c" -or -name "*.cpp" -or -name "*.h" -or -name "*.m" -or -name '*.java' \) -print0 | xargs -0 wc

Counts lines with all-cased word 'null' in file 'myfile.txt'.
grep -n -i null myfile.txt | wc -l

Counts total lines in all *.php files.
find . -type f -name '*.php' -exec bash -c 'wc -l "$0"' {} \; | awk '{s+=$1} END {print s}'

Counts total line number of all *.php file in a current folder and subfolders.
cat `/gnuwin32/bin/find.exe . -name *.php` | wc -l

Counts total number of all '*.py' files beginning from root folder, and shows 'tqdm' progress bar.
find / -name '*.py' -exec cat \{} \; | tqdm --unit loc --unit_scale True | wc -l

Counts total number of lines in a git repository.
git grep ^ | wc -l

Count total number of lines in all *txt files  in current directory
wc -l `find . -type f -name '*.txt' `

Counts total number of lines in all file under current folder.
find ./ -type f -exec wc -l {}  \; | cut -d' ' -f1 | paste -sd+ | bc

Counts non-blank lines (lines with spaces are considered blank) in all *.py files in a current folder.
grep -v '^\s*$' *.py | wc

Counts number of *.php files in a current folder and subfolders.
find . -name '*.php' | wc -l

Count number of A records of domain '$domain' on nameserver '$server' and save value in 'result' variable
result="$(dig +short @"$server" "$domain" | wc -l)"

Count number of lines for each file containing ASCII text under git repository.
git ls-files | xargs file | grep "ASCII" | cut -d : -f 1 | xargs wc -l

Count number of lines in "Sample_51770BL1_R1.fastq.gz"
zcat Sample_51770BL1_R1.fastq.gz | wc -l

Count number of lines in all files matching "*R1*.fastq.gz"
zcat *R1*.fastq.gz | wc -l

Counts number of lines returned by curl request.
curl yahoo.com --silent | wc -l

Counts number of lines with 'OK' in file 'filename'.
grep "OK" <filename> | wc -l

Count number of occurences of "123" in the string "123 123 123" (ie. 3)
echo "123 123 123" | grep -o 123 | wc -l

Counts number of processors and saves in variable NUMCPU.
NUMCPU=$(grep $'^processor\t*:' /proc/cpuinfo |wc -l)

Mount partition with label "WHITE" on "/mnt/WHITE"
mount -L WHITE /mnt/WHITE

Mount partition with label "WHITE" on "/mnt/WHITE" with read and write permission and have it accessible by user and group "test"
mount -L WHITE /mnt/WHITE -o rw,uid=test,gid=test

Mount remote "cifs" filesystem "//192.168.0.111/serv_share" on "/mnt/my_share" with username "me" and password "mine"
sudo mount -t cifs -o username=me,password=mine //192.168.0.111/serv_share /mnt/my_share

Mount the "vboxsf" filesystem "D:\share_folder_vm" on "\share_folder"
sudo mount -t vboxsf D:\share_folder_vm \share_folder

Count the *.html files residing in the /usr/src directory tree and containing string "foo"
find /usr/src -name "*.html" -exec grep -l foo '{}' ';' | wc -l

Count the *.html files residing in the /usr/src directory tree and containing string "foo"
find /usr/src -name "*.html" | xargs grep -l foo | wc -l

Mount the directory "/etc" on "/tmp/sarnold/mount_point/"
mount -obind /etc /tmp/sarnold/mount_point/

count the lines of java code for all the java files in the current directory
find . -name "*.java" -print0 | xargs -0 wc

Counts the total number of lines in all the files in a git repository.
git ls-files | xargs cat | wc -l

Count the number of "X" characters in "infile"
tr -d -C X <infile | wc -c

Count the number of .gz files in directory tree /home/user1/data1/2012/mainDir
find /home/user1/data1/2012/mainDir -name '*.gz' | wc -l

Count the number of .java files in all folders rooted in the current folder
find . -name "*.java" | wc -l

Count the number of all directories under current directory non-recursively
find . -mindepth 1 -maxdepth 1 -type d | wc -l

Count the number of all directories under directory '/mount/point' non-recursively
find /mount/point -maxdepth 1 -type d | wc -l

Count the number of characters in the list of regular files from the current directory tree
find . -type f | xargs | wc -c

Count the number of differing lines in "file1" and "file2" with 0 lines of unified context
diff -U 0 file1 file2 | grep -v ^@ | wc -l

Count the number of directories in the current directory and below
find . -type f -exec basename {} \; | wc -l

Count the number of directories under directory '/directory/' non-recursively
find /directory/ -maxdepth 1 -type d -print| wc -l

Count the number of equal lines in "file1.txt" and "file2.txt"
comm -12 <(sort file1.txt) <(sort file2.txt) | wc -l

Count the number of equal lines in sorted files "ignore.txt" and "input.txt"
comm -12 ignore.txt input.txt | wc -l

Count the number of non localhost users
who | grep -v localhost | wc -l

Count the number of open files for PID "$PYTHONPID" every 2 seconds
watch "ls /proc/$PYTHONPID/fd | wc -l"

Count the number of files/directories named file1 under current directory
find -name file1 | wc -l

Count the number of files/directories with '.php' extension under current directory tree and change the permissions to 755
find . -name "*.php" -exec chmod 755 {} \; -exec /bin/echo {} \; | wc -l

Count the number of lines in "/dir/file.txt"
cat /dir/file.txt | wc -l

Count the number of lines in "myfile.txt"
cat myfile.txt | wc -l

Count the number of lines in "testfile" wrapped to fit in a width of "$COLUMNS" characters
fold -w "$COLUMNS" testfile | wc -l

Counts the number of lines in *.php and *.inc files in a current folder and subfolders.
find . -name '*.php' -o -name '*.inc' | xargs wc -l

Count the number of lines in all ".php" files in the current directory tree
find . -name '*.php' -type f | xargs cat | wc -l

Count the number of lines in all ".php" files in the current directory tree
wc -l `tree -if --noreport | grep -e'\.php$'`

Count the number of lines in all ".php" files in the current directory tree using bash for Windows
cat `/gnuwin32/bin/find.exe . -name *.php` | wc -l

Count the number of lines in all files in the xargstest/ directory tree that match pattern 'file??'
find xargstest/ -name 'file??' | sort | xargs wc -l

Counts the number of lines in each *.cs file in a git repository.
wc -l $(git ls-files | grep '.*\.cs')

Counts the number of lines in each *.hpp or *.cpp file in a git repository.
git ls-files | grep -P ".*(hpp|cpp)" | xargs wc -l

Counts the number of lines in each *.java file in a git repository.
git ls-files | grep "\.java$" | xargs wc -l

Counts the number of lines in each *.swift or *.mm file in a git repository, escaping any space in filename.
git ls-files | sed 's/ /\\ /g' | grep -E "\.*(swift$|mm$)" | xargs wc -l

Count the number of lines in each .java file in the current directory tree
find . -name "*.java" -exec wc -l {} \;

Counts the number of lines in each file in a git repository.
git ls-files | xargs -d '\n' wc -l

Counts the number of lines in each file in a git repository.
git ls-files | xargs wc -l

Counts the number of lines in each file in a git repository.
wc -l $(git ls-files)

Counts the number of lines in each file in a git repository.
wc -l --files0-from=<(git ls-files -z)

Counts the number of lines in each file in a git repository, if file names may contain spaces.
git ls-files -z | xargs -0 wc -l

Count the number of lines in every regular .rb file in the current directory tree
find . -name "*.rb" -type f -exec wc -l \{\} \;

Count the number of lines in every regular .rb file in the current directory tree
find . -name "*.rb" -type f -print0 | xargs -0 wc -l

Counts the number of lines in only text files in a git repository.
git ls-files | xargs file | grep "ASCII" | cut -d : -f 1 | xargs wc -l

Count the number of files in the /usr/ports directory tree whose names begin with 'pkg-plist' and which contain 'dirrmtry'
find /usr/ports/ -name pkg-plist\* -exec grep dirrmtry '{}' '+' | wc -l

Count the number of files in the /usr/ports directory tree whose names begin with 'pkg-plist' and which contain 'etc/rc.d/'
find /usr/ports/ -name pkg-plist\* -exec grep -l etc/rc.d/ '{}' '+' | wc -l

Count the number of files in the current directory and below
find . -type d -exec basename {} \; | wc –l

Count the number of lines in the current git repository
git ls-files | xargs cat | wc -l

Count the number of files in the directory trees whose pathnames match pattern '/dev/sd*[a-z]'
find /dev/sd*[a-z] -printf . | wc -c

Count the number of files in the directory trees whose pathnames match pattern '/dev/sd*[a-z]'
find /dev/sd*[a-z] | wc -l

Count the number of lines recursively in the current directory
find ./ -type f -exec wc -l {}  \; | cut -d' ' -f1 | paste -sd+ | bc

Count the number of total files and folders under current directory tree
find . -print0 | tr -cd '\0' | wc -c

Count the number of regular files in the current directory that contain a vowel in their names
find . -maxdepth 1 -type f -iname '*[aeiouy]*' -printf ".\n" | wc -l

Count the number of regular files in the current directory tree
find . -type f | wc -l

Count the number of regular files with 755 permission under current directory tree
find . -type f -perm 755 | wc -l

Count the number of regular files with case insensitive name pattern $srchfor under 'teste2' directory tree
find teste2 -type f -iname "$srchfor"|wc -l

Count the number of symbolic links starting from /students
find /students -type l -print 2> /dev/null |wc -l

Count the number of the regular files residing under and below ./randfiles/
find ./randfiles/ -type f | wc -l

Count the number of unique duplicate lines in "file1" and "file2" combined
sort file1 file2 | uniq -d | wc -l

Count the number of users logged in
who | wc -l

Count the occurrence of 2 in the string '1 1 2 2 2 5'
echo "1 1 2 2 2 5" | tr ' ' $'\n' | grep -c 2

Copy "/Users/username/path/on/machine/" to "username@server.ip.address.here:/home/username/path/on/server/" and convert encoding from UTF-8-MAC to UTF-8
rsync --iconv=UTF-8-MAC,UTF-8 /Users/username/path/on/machine/ 'username@server.ip.address.here:/home/username/path/on/server/'

Copy "/home/username/path/on/server/" to "username@your.ip.address.here:/Users/username/path/on/machine/" and convert encoding from UTF-8 to UTF-8-MAC
rsync --iconv=UTF-8,UTF-8-MAC /home/username/path/on/server/ 'username@your.ip.address.here:/Users/username/path/on/machine/'

Copy "/path/to/source" to '/path/to/dest' in remote "username@computer"
rsync -r /path/to/source username@computer:/path/to/dest

Copy "file" from "REMOTE" into local clipboard
ssh USER@REMOTE "cat file"|xclip -i

Copy "fileName.txt" to all directories listed in "allFolders.txt" - names may not contain spaces.
cat allFolders.txt | xargs -n 1 cp fileName.txt

Copy "local_file" to "user@host:remote_file" via ssh protocol, saving partially transferred files, and showing progress
rsync --partial --progress --rsh=ssh local_file user@host:remote_file

Copy "local_file" to "user@host:remote_file" via ssh protocol, saving partially transferred files, and showing progress
rsync -P -e ssh local_file user@host:remote_file

Copy "some_file_name" to "destination_directory" and change ownership to "someuser:somegroup"
echo 'some_file_name' | cpio -p --owner someuser:somegroup destination_directory

Copy "source" recursively to "destination" excluding "path1/to/exclude" and "path2/to/exclude"
rsync -av --exclude='path1/to/exclude' --exclude='path2/to/exclude' source destination

Copy "src/prog.js" and "images/icon.jpg" to "/tmp/package" keeping relative path names
rsync -R src/prog.js images/icon.jpg /tmp/package

Copy "src/prog.js" and "images/icon.jpg" to "/tmp/package/" keeping relative path names
rsync -Rv src/prog.js images/icon.jpg /tmp/package/

Copy %PATH% variable on Windows to clipboard
set %PATH% | clip

Copy '/path/to/source' from remote "username@computer" to local "/path/to/dest"
rsync -r username@computer:/path/to/source /path/to/dest

Copy *.mp3 files to /tmp/MusicFiles
find . -type f -name "*.mp3" -exec cp {} /tmp/MusicFiles \;

Copy *.txt files from the dir/ directory tree along with their parent directories
find dir/ -name '*.txt' | xargs cp -a --target-directory=dir_txt/ --parents

Copy a large sparse file "sparse-1" to "sparse-1-copy"
rsync --sparse sparse-1 sparse-1-copy

Copy a file xyz.c to all directories or over all files matching the letter 'c' at the end of their names under current directory tree
find . -name "*c" -print0 | xargs -0 -n1 cp xyz.c

Copy a file xyz.c to all the .c files present in the C directory and below
find ./C -name "*.c" | xargs -n1  cp xyz.c

Copy a whole directory tree skipping files residing on other files systems to destination_dir
find ./ -mount -depth -print | cpio -pdm /destination_dir

Copy all *.data files under /source_path to /target_path
find /source_path -name *.data -exec cp {} /target_path \;

Copy all *.data files under /source_path to /target_path by appending the parent directory names in the source paths to the beginning of each of the target file names
find /source_path -name \*.data  | while read -r filename; do cp "${filename}" "$(printf "%s\n" "${filename}" | sed "s/^.*[/]\(category[^/]*\)[/]\(.*[.]data\)$/\/target_path\/\1_\2/")"; done

Copy all *.data files under jcho directory to files whose names are constructed by appending the parent directory names at the beginning of their names
find jcho -name '*.data' | while read -r f; do cp "$f" "$(echo "$f" | sed 's~\([^)]*\)/\([^()]*\)$~\1_\2~')"; done

Copy all *.data files under jcho directory to files whose names are constructed by replacing the first '0' to '2' in their names
find jcho -name *.data -exec sh -c 'f="${0}"; d=$(echo ${f} | sed -re 's/0/2/' ); cp ${f} ${d} ' {} \;

Copy all *.mp3 files under the current directory to /tmp/MusicFiles/
find . -type f -name "*.mp3" -exec cp {} /tmp/MusicFiles \;

Copy all *.txt files from the current directory tree to /tmp
find . -name '*.txt' | while read line; do echo "Copying '$line' to /tmp"; cp -- "$line" /tmp; done

Copy all .patch files from the current directory tree to patches/
find -name '*.patch' -print0 | xargs -0 -I {} cp {} patches/

Copy all .pdf files in the ./work/ directory tree with size bigger then 2 MB and modified more than 5 days ago to the ./backup/ directory
find ./work/ -type f -name "*.pdf" -mtime +5 -size +2M  | xargs -r cp -t ./backup/

Copy all .png files from the home directory tree to imagesdir/
find ~/ -name *.png -exec cp {} imagesdir \;

Copy all .txt files from the dir/ directory tree along with their parent directories hierarchy
find dir/ -name '*.txt' | xargs cp -a --target-directory=dir_txt/ --parents

Copy and always overwrite all files in "/zzz/zzz" to "/xxx/xxx"
yes | cp -rf /zzz/zzz/* /xxx/xxx

Copy all directories recursively from "source/" to "destination/" excluding all files
rsync -a --include='*/' --exclude='*' source/ destination/

Copy all directories recursively from "source/" to "destination/" excluding all files
rsync -a -f"+ */" -f"- *" source/ destination/

copy all java files from current folder to another folder
find . -name "*.java" -print0 | xargs -0 -J % cp % destinationFolder

copy all files which do not have execute permission to another folder
cp `find -perm -111 -type f` /usr/local/bin

Copy all files and directories in "/home/" to "/newhome" preserving directory hierarchy and modification time
find /home/ -maxdepth 1 -print | sudo cpio -pamVd /newhome

Copy all files and directories under the current directory into "../new" preserving relative paths
find -print0 | sort -z | cpio -pdv0 ../new

Copy all files below the current directory whose names contain "foobar" (case-insensitive) to directory foo/bar/ in user's home directory.
find . -iname "*foobar*" -exec cp "{}" ~/foo/bar \;

Copy all files from the current directory tree to /path/to/destination/dir preserving their times, permissions, and ownership
find . | cpio -pdumv /path/to/destination/dir

Copy all files ending in ".a" in directory trees matching "folder*" to "/path/to/dest" preserving directory hierarchy
find folder* -name '*.a' -print | cpio -pvd /path/to/dest

Copy all files in "/var/spool/mail" to "/home/username/mail" preserving the directory hierarchy and modification times
find /var/spool/mail -type f | cpio -pvdmB /home/username/mail

Copy all files in current directory that do not match */exlude-path/* in their paths to /destination/ preserving directory structure
find . -type f -not -path '*/exlude-path/*' -exec cp --parents '{}' '/destination/' \;

Copy all files in current directory that do not match */not-from-here/* in their names to /dest
find . -type f -not -iname '*/not-from-here/*' -exec cp '{}' '/dest/{}' ';'

Copy all files in current directory that do not match */not-from-here/* in their paths to /dest
find . -type f -not -path '*/not-from-here/*' -exec cp '{}' '/dest/{}' \;

Copy all files in the current directory except those containing 'Music' to '/target_directory'.
cp `ls | grep -v Music` /target_directory

Copy all files matching "*.sh" in "$from/*" to "root@$host:/home/tmp/" compressing data during transmission
rsync -zvr --include="*.sh" --exclude="*" $from/*  root@$host:/home/tmp/

Copy all files matching "*failed.ipynb" in the current directory tree to "./fails" preserving the directory hierarchy
find . -name "*failed.ipynb" | cpio -pd ./fails

Copy all files matching "file_name.extension" to "/path/to/receiving/folder" preserving directory hierarchy
find . -name 'file_name.extension' -print | cpio -pavd /path/to/receiving/folder

Copy all files named 'script.sh' in directory 'olddir' to directory 'newdir'
find olddir -name script.sh -printf "%p\0" -printf "newdir/%P\0" | xargs -0L2 cp -n

Copy all files that match 'FooBar' in their paths under current directory tree to the '~/foo/bar' directory
find . | grep "FooBar" | tr \\n \\0 | xargs -0 -I{} cp "{}" ~/foo/bar

Copy all files unconditionally and directories in directory tree "myfiles" to "target-dir" preserving directory hierarchy and modification time
find myfiles | cpio -pmud target-dir

Copy all files with '.png' (case insensitive) extension under '/home/mine' directory tree to '/home/mine/pngcoppies/' directory with new names constructed by prepending 'copy' in their names
find  /home/mine -iname "*.png" -printf "%P\n " | xargs  -I % -n1 cp %  /home/mine/pngcoppies/copy%

Copy all files with '.png' (case insensitive) extension under '/home/mine' directory tree to '/home/mine/pngcoppies/copy.' directory
find /home/mine -iname "*.png" -execdir cp {} /home/mine/pngcoppies/copy{} \;

Copy all files with name pattern $j.sh (case insensitive) under '/tmp/2' directory tree to $i directory
find "/tmp/2/" -iname "$j.sh" -exec cp {} "$i" \;

Copy all regular files from the current directory tree to /tmp/
find . -type f -exec sh -c 'cp "$@" /tmp' {} +

Copy all regular files whose names end in "~" from the /path directory tree to ~/backups/
find /path -type f -name '*~' -print0 | xargs -0 -I % cp -a % ~/backups

copy all the log files in the current folder which have not been accessed in the last 30*24 hours to the folder old
find . -type f -mtime +30 -name "*.log" -exec cp {} old \;

copy all the files with the extension ".type" from one folder to a target directory
find "$sourcedir" -type f -name "*.type" -exec sh -c 'for f; do cp "$f" "$0"; done' "$targetdir" {} +

copy all the files with the extension ".type" from one folder to a target directory
find "$sourcedir" -type f -name "*.type" | xargs cp -t targetdir

copy all the mp3 files from current folder to another folder
find . -name '*.mp3' -exec cp -a {} /path/to/copy/stuff/to \;

copy all the regular/normal files from temp folder which have been modified in the last 30*24 hours to /tmp/backup
find /tmp -type f -mtime -30 -exec cp {} /tmp/backup \;

copy all the regular files in the current directory to the temporary diectory.
find . -type f -exec cp {} /tmp +

Copy an entire file structure, creating empty files in the copy instead of copying the actual files.
find src/ -type d -exec mkdir -p dest/{} \; -o -type f -exec touch dest/{} \;

Copy current working directory to clipboard
pwd | tr -d '\n' | pbcopy

Copy current working directory to clipboard
pwd | xsel -i

Copy default SSH public key to "somehost" as user "myname"
ssh-copy-id myname@somehost

Copy directory hierarchy "dir" and all its .txt files to "dir_txt"
find dir/ -name '*.txt' | xargs cp -a --target-directory=dir_txt/ --parents

Copy directory hierarchy from the current working directory to "/path/to/backup/"
find . -type d -exec mkdir -p -- /path/to/backup/{} \;

Copy directory structure from directory 'olddir' to 'newdir'
find olddir -type d -printf "newdir/%P\0" | xargs -0 mkdir -p

Copy directory tree preserving UID and GID and leaving user files alone
find . -depth -print | cpio -o -O /target/directory

Copy entire directory structure from dir1 as a subdirectory of dir2, omitting empty directories, special files (sockets, pipes etc) and any directory named "exclude".
mkdir dir2; find dir1 \( -type l -o -type f \) -not -wholename '*/exclude/*' -exec cp -P --parents '{}' dir2/ \;

Copy entire directory structure from dir1 as a subdirectory of dir2, omitting any file or directory named "exclude".
mkdir dir2; tar cvf - dir1/ --exclude "*/exclude" | tar xvf - -C dir2

Copy files printed by "any_command_what_produces_relative_path_names" to "/new/parent/dir" preserving the directory hierarchy
any_command_what_produces_relative_path_names | cpio -pamVd /new/parent/dir

Copy files, removing digits from the filename (e.g file123 to file or te12345st to test). Do not overwrite any existing file.
find . -type f -execdir bash -c '   dest=${1//[0-9]/}   [[ -f $dest ]] || cp -- "$1" "$dest" ' _ {} \;

(Linux specific) Copy loadable kernel module "mymodule.ko" to the drivers in modules directory matchig current kernel.
sudo cp mymodule.ko /lib/modules/$(uname -r)/kernel/drivers/

Copy local file "file" via ssh to remote "host" path "/directory/"
rsync -e ssh file host:/directory/.

Cut off three last symbols from string '1234567890  *'
echo '1234567890  *' | rev | cut -c 4- | rev

Copy permissions from "version2/somefile" to "version1/somefile"
chmod --reference version2/somefile version1/somefile

Copy recursively "/source/backup" to "/destination" preserving symbolic links, modification times, and permissions
rsync -rtvpl /source/backup /destination

Copy recursively "tata/" to "tata2/" and remove read, write, and execute permission for other
rsync -avz --chmod=o-rwx -p tata/ tata2/

Copy file "exist" from directory "/file/that" to a new file named "file" in "/location/for/new"
cp /file/that/exists /location/for/new/file

Copy file 'src' to 'dest', except if 'dest' already exists.
cp -n src dest

Copy file header.shtml to directories dir1, dir2, dir3, and dir4
find dir1 dir2 dir3 dir4 -type d -exec cp header.shtml {} \;

Copy file in current directory of local host to host "remote", connecting as ssh user matching current local username, and copying the file in home directory on remote host - enable compression during transfer.
scp -C file remote:

Copy file linked to by "bar.pdf" to "bar.pdf"
cp --remove-destination `readlink bar.pdf` bar.pdf

Copy file or directory 'gtest' from directory 'include' in current directory to /usr/include, preserving ownerships and permissions.
sudo cp -a include/gtest /usr/include

Copy file or folder linked to by "file" to "file"
cp -rf --remove-destination `readlink file` file

Copy specific sub-directories "company1/" and "company1/unique_folder1" from "user@server.com:/path/to/old/data/" to "/path/to/new/data" via ssh
rsync -avzn --list-only --include 'company1/' --include 'company1/unique_folder1/***' --exclude '*' -e ssh user@server.com:/path/to/old/data/ /path/to/new/data

Copy src_dir recursively to dest_dir, but without overwriting existing files.
cp -nr src_dir dest_dir

Copy the 3 specified files to /tmp/package, preserving/creating directory structure of each file as specified on command line.
cp --parents src/prog.js images/icon.jpg /tmp/package

Put the absolute directory path to the current script to MY_DIR variable
MY_DIR=$(dirname $(readlink -f $0))

Copy the current directory tree to "newdirpathname" preserving directory hierarchy
find ./ -depth -print | cpio -pvd newdirpathname

Copy the directory hierarchy of the current directory to "destdir"
find . -type d | cpio -pdvm destdir

Copy the directory structure in "src/" to "dest/" with empty files
find src/ -type d -exec mkdir -p dest/{} \; -o -type f -exec touch dest/{} \;

copy the entire contents of the current directory to another directory, while preserving the permissions, times, and ownership of every file and sub-directory
find . | cpio -pdumv /path/to/destination/dir

Copy the entire contents of the current directory preserving ownership, permissions, and times
find . | cpio -pdumv /path/to/destination/dir

Copy the entire directory tree under t1 to t2, do not create a containing t1 directory in t2.
cp -R t1/ t2

Copy the executable "python2.7" in $PATH to "myenv/bin/python"
cp `which python2.7` myenv/bin/python

copy the file header.shtml to those dirs
find dir1 dir2 dir3 dir4 -type d -exec cp header.shtml {} \;

Copy the owner and group from "file.txt" to "$tempfile"
chown --reference=file.txt -- "$tempfile"

Copy the owner and group of "oldfile" to "newfile"
chown --reference=oldfile newfile

Copy the owner and group of "originalfile" to "newfile"
chown `stat -c %U originalfile`:`stat -c %G originalfile` newfile

Copy the file foo.sh into /path/to/cotainer of the docker container
tar -c -C /path/on/local/machine . | docker cp - dvc:/path/on/container

Copy the standard output of a "bash" session to "/var/log/bash.out.log"
bash | tee /var/log/bash.out.log

Create 1000 files each file having a number from 1 to 1000 named "file000" to "file999"
seq 1 1000 | split -l 1 -a 3 -d - file

Create 256 directories named from '00' to 'ff', each containing 256 subdirectories named '00' to 'ff'.
join -j2  <(seq 0 255) <(seq 0 255) | xargs -n256 printf "%02x/%02x\n" | xargs mkdir -p

Create 5 empty .txt files
echo "a.txt b.txt c.txt d.txt z.txt" | xargs touch

Creates 5-letter random file name and saves it in 'rand_str' variable.
rand_str="$(mktemp --dry-run XXXXX)"

Create 6-letter named temporary file in a folder path that is provided as the first positional parameter, and save the path to it in a variable 'tmpfile'
tmpfile=$(mktemp $(dirname "$1")/XXXXXX)

Create 998 directories one inside another with sequential names folder1, folder2, ... folder998 and create an additional folder named 'folder9991000' inside the last 'folder998' directory
mkdir -p folder$( seq -s "/folder" 999 )1000

create a hard link as directory named "new_hard_link" to the directory "existing_dir" as root
sudo  ln  -d  existing_dir  new_hard_link

Create a hard link named "my-hard-link" to "myfile.txt"
ln myfile.txt my-hard-link

create a backup of all normal/regular files in current folder which have been modified between two dates and create a tar.gz file of this backup
find /path/to/files/ -newermt 20131204 -not -newermt 20131205 -type f -print0 | cpio --create --null  --format=ustar  | gzip > /tmp/dec-4.tar.gz

create a backup of all the files in the current folder excluding those that are present in the .snapshot sub directory and excluding the swap files (files ending with  ~)
find . -name .snapshot -prune -o \( \! -name *~ -print0 \) | cpio -pmd0 /dest-dir

create a backup of all the files in the current folder to the floppy and save the file list in the file /tmp/BACKUP.LOG
find . -cpio /dev/fd0 -print | tee /tmp/BACKUP.LOG

create a backup of all the files in the home folder on a partition and save the log to a file
find /home -depth -print | cpio -ov -0 /dev/rmt0 | tee -a tape.log

create a back up of several folder
find etc home apps -depth -print | cpio -ov > dev/rmt0

Create a bzip2 archive `dir_txt.tar.bz2' of all .txt files in the dir/ directory tree
find dir/ -name '*.txt' | tar -c --files-from=- | bzip2 > dir_txt.tar.bz2

Create a bzip2 archive of all .log files from the /var/log directory tree
find /var/log -name '*.log' | tar cv --files-from=- | bzip2 > log.tar.bz2

Create a bzip2 archive of all .txt files from the "dir" directory tree
find dir/ -name '*.txt' | tar -c --files-from=- | bzip2 > dir_txt.tar.bz2

create a compressed archive "compressFileName.tar.gz" with verbose output
tar -zcvf compressFileName.tar.gz folderToCompress

create a compressed archive "filename.tar.gz" with verbose output
tar -cvzf filename.tar.gz folder

Create a compressed archive from "www" and split the contents into files of at most 1073741824 bytes and use prefix "www-backup.tar."
tar czf - www|split -b 1073741824 - www-backup.tar.

create a compressed archive in my_dir directory matching '.[^.]* ..?*' glob pattern
tar -C my_dir -zcvf my_dir.tar.gz .[^.]* ..?* *

create a compressed archive excluding files matching a pattern
tar -czf backup.tar.gz --exclude=PATTERN1 --exclude=PATTERN2 ... /path/to/backup

create a compressed archive excluding the directories containing "exclude.tag"
tar -czf backup.tar.gz --exclude-tag-all=exclude.tag /path/to/backup

Create a compressed archive named 'my_directory.tar.gz' with files inside directory 'my_directory' without including the directory entry 'my_directory' itself
tar -czvf my_directory.tar.gz -C my_directory .

create a compressed archive of a target directory excluding '<dir1>' and '<dir2>'
tar cfvz --exclude='<dir1>' --exclude='<dir2>' target.tgz target_dir

create a compressed archive with files newer than 1st of January 2014, 18:00:00.
tar -N '2014-02-01 18:00:00' -jcvf archive.tar.bz2 files

Create a copy of index.html in all directories in current directory, pausing for confirmation before overwriting any existing files - names may not contain spaces - names may not contain spaces.
find . -mindepth 1 -maxdepth 1 -type d| xargs -n 1 cp -i index.html

Create a copy of index.html in all directories in current directory whose name contains Va, pausing for confirmation before overwriting any existing files - names may not contain spaces.
find . -mindepth 1 -maxdepth 1 -type d| grep \/a |xargs -n 1 cp -i index.html

Create a tar archive of all regular files modified in the last 24 hours
tar cvf - `find . -mtime -1 -type f -print` > $archive.tar

Create a tar archive of files from directory tree "data"
find data/ -print0 | tar --null -T - --create -f archive.tar

Create a tar archive of files from directory tree "data"
find data/ -print0 | tar -T - --null --create -f archive.tar

Create a tar archive with all *.java files under the current directory
find . -type f -name "*.java" | xargs tar cvf myfile.tar

create a tar ball of all pdf files in current folder
find . -name '*.pdf' -print0 | tar czvf pdf.tar --null -T -

create a tar ball of all pdf files in current folder
find . -name *.pdf | xargs tar czvf /root/Desktop/evidence/pdf.tar

create a tar ball of all the files in the current folder
tar cvf - `find . -print` > backup.tar

create a tar ball of current directory
tar cvf - `find . -print` > backup.tar

create a tar file of all the songs on my system that have been modified in the last 180 days (which is essentially six months)
find . -name -type f '*.mp3' -mtime -180 -print0 | xargs -0 tar rvf music.tar

create a tar of all png & jpg images in the current folder
find . \( -iname "*.png" -o -iname "*.jpg" \) -print -exec tar -rf images.tar {} \;

Create a full path symbolic link "$newlink" from a relative path symbolic link "$origlink"
ln -s $(readlink -f $origlink) $newlink

create a list of all files in all subdirectories
find . -type f -exec md5 {} \;

Create a local SSH tunnel from "localhost" port 16379 to "localhost" port 6379 using key "keyfile.rsa" and disables the interactive shell
ssh -i keyfile.rsa -T -N -L 16379:localhost:6379 someuser@somehost

create a md5sum for all the instances of the file MyCProgram.c in current folder
find -iname "MyCProgram.c" -exec md5sum {} \;

create a zip file of all the files in some directory
find $directory -type -f -execdir zip -j $ZipFileName {}\;

create a zip of all the files in the current folder which are bigger than 100Kb and do not go more than 2 levels during search
find . -maxdepth 2 -size +100000 -exec bzip2 {} \;

create a zip of log files in the current directory which have not been accessed in the last 3 days (-p is for parallel processing for a 4 cpu machine)
find . -name '*.log' -mtime +3 -print0 | xargs -0 -P 4 bzip2

create a zip of log files in the current directory which have not been accessed in the last 3 days (-p is for parallel processing for a 4 cpu machine, -n is for maximum work units)
find . -name '*.log' -mtime +3 -print0 | xargs -0 -n 500 -P 4 bzip2

Create a zip file ($zipFile) of all *.log files under $sourcePath
find $sourcePath -type f -name "*.log" | xargs zip $zipFile -@

create a sub shell and search for regular/normal file with the name "myfile" in the entire file system and discard all the errors
sh -c "find / -name myfile -type f -print 2> /dev/null"

create a soft link of the files in the folder /media/movies which have been modified in the last 30 days
find /media/Movies -type f -mtime -30 -exec ln -s {} /media/Movies/New/ \;

Create a named screen session
screen -S main

Create a named screen session
screen -X title mynewtitle

Create a named screen session
screen -x 2073 -p 0 -X title h

Create a named screen session
screen -x main -X title blah

Create a named screen session
screen -x main -p oldwindow -X title blah

Create a new window in an existing screen session and run a script
screen -S demo -p 1 -X screen '/home/aa/scripts/outputs.sh'

Create a rsa key of 2048 bits with comment "michael" and store it in file "key".
ssh-keygen -b 2048 -t rsa -f key -C michael

Create a rsa key with comment specified by variable APP and passphrase specified y SSHKEYPASS.
ssh-keygen -t rsa -C "$APP" -N "$SSHKEYPASS" -f ~/.ssh/id_rsa

create a gzip of all the files in the current folder excluding the already gzipped files
gzip `find . \! -name '*.gz' -print`

create a gzip of all the files in the current folder excluding the already gzipped files.
find . \! -name "*.gz" -exec gzip {} \;

Create a sorted unique list of new or modified files comparing "old/" and "new/"
(rsync -rcn --out-format="%n" old/ new/ && rsync -rcn --out-format="%n" new/ old/) | sort | uniq

Create a ssh key and store it in the file ~/.ssh/apache-rsync
ssh-keygen -f ~/.ssh/apache-rsync

Create a ssh tunnel on local port 2222 through "bridge.example.com" to "remote.example.com" port 22 without executing any commands and run in the background
ssh -N -L 2222:remote.example.com:22 bridge.example.com&

Create a symbolic link in "/bar/tmp/" for each file in directory "/foo" that does not start with "runscript"
find /foo -maxdepth 1 -type f ! -name 'runscript*' -exec ln -s {} /bar/tmp/ \;

Create a symolic link in "/usr/local/bin/" to "/Applications/Sublime\ Text.app/Contents/SharedSupport/bin/subl"
ln -s /Applications/Sublime\ Text.app/Contents/SharedSupport/bin/subl /usr/local/bin/

Create a symolic link in "/usr/local/bin/" to "/Applications/Sublime\ Text\ 2.app/Contents/SharedSupport/bin/subl"
ln -s /Applications/Sublime\ Text\ 2.app/Contents/SharedSupport/bin/subl /usr/local/bin/

create a symbolic link in current directory named "environments" to file "../config/environments"
ln -s "../config/environments"

create a symbolic link in current directory named "my_db" to file "/media/public/xampp/mysql/data/my_db"
ln /media/public/xampp/mysql/data/my_db -s

Create a symbolic link in directory "new" for each file in "original" directory tree
find original -type f -exec ln -s {} new/{} \;

Create a symbolic link in directory "~/newlinks" for each file listed in "results2.txt"
cat results2.txt | xargs -I{} ln -s {} ~/newlinks

Create a symbolic link in target directory "$tmpdir" for each file under the current directory
find $PWD -type f -exec ln -st $tmpdir {} +

Create a symbolic link in target directory "~/newlinks" to "$source"
ln -s "$source" -t ~/newlinks

Create a symbolic link in the current directory for each .jpg file under "dir"
ln -s "$(find dir -name '*.jpg')" .

Create a symbolic link in the current directory for each hidden file or directory in "git-stuff/home/" excluding "." and ".."
ln -s git-stuff/home/.[!.]* .

Create a symbolic link in the current directory for each file .dbf under the directories matching "/home/michael/foxpro/mount/A[1FV]/[12][0-9][0-9][0-9]"
find /home/michael/foxpro/mount/A[1FV]/[12][0-9][0-9][0-9] -name '*.dbf' -type f -exec ln -s {} \;

Create a symbolic link in the current directory for each file under the directories matching "../[12][0-9][0-9]"
find ../[12][0-9][0-9][0-9] -type f -exec ln -s {} \;

Create a symbolic link in the current directory to "$file"
ln -s "$file"

Create a symbolic link in the current directory to "../config/init"
ln -s "../config/init"

Create a symbolic lnk named "$1/link" to "$dir"
ln -s "$dir" "$1/link"

Create a symbolic link named "$1/link" to the current working directory
ln -s "`pwd`" $1/link

Create a symbolic link named "$1/link" to the existing full and real path of "$2"
ln -s "$(readlink -e "$2")" "$1/link"

Create a symbolic link named "$HOME/bin/" to "$HOME/downloads/fnord"
ln -s $HOME/downloads/fnord $HOME/bin/

create a symbolic link named "$ORACLE_HOME/include" to file "/usr/include/oracle/11.2/client"
sudo ln -s /usr/include/oracle/11.2/client $ORACLE_HOME/include

Create a symbolic link named "$tmpdir/bam" to the full path of command "bam2" found in "$PATH"
ln -s "$(which bam2)" "$tmpdir"/bam

Create a symbolic link named "${DESTINATION}${file}" to "${TARGET}${file}"
ln -s  "${TARGET}${file}"  "${DESTINATION}${file}"

create a symbolic link named "-pdf-kundendienst" to "local--pdf-kundendienst" file
ln -s -- ./local--pdf-kundendienst -pdf-kundendienst

Create a symbolic link named ".bash_profile" to ".bashrc"
ln -s .bashrc .bash_profile

Create a symbolic link named ".profile" to "git-stuff/home/profile" without dereferencing ".profile"
ln -sn git-stuff/home/profile .profile

Create a symbolic link named "/lib/libc.so.0" to "/lib/libc.so.6"
ln -s /lib/libc.so.6 /lib/libc.so.0

Create a symbolic link named "/usr/bin/my-editor" to "/usr/share/my-editor/my-editor-executable" and attemp to hard link directories
ln -sF /usr/share/my-editor/my-editor-executable   /usr/bin/my-editor

create a symbolic link named "/usr/bin/my-editor" to file "/usr/share/my-ditor/my-editor-executable"
ln -s /usr/share/my-ditor/my-editor-executable /usr/bin/my-editor

create a symbolic link named "/usr/bin/openssl" to file "/usr/local/ssl/bin/openssl"
ln -s "/usr/local/ssl/bin/openssl /usr/bin/openssl

create a symbolic link named "/usr/lib/jvm/default-java" to file "/usr/lib/jvm/java-7-oracle"
sudo ln -s /usr/lib/jvm/java-7-oracle /usr/lib/jvm/default-java

Create a symbolic link named "/usr/local/bin/subl" to "/Applications/Sublime Text 2.app/Contents/SharedSupport/bin/subl"
sudo ln -s "/Applications/Sublime Text 2.app/Contents/SharedSupport/bin/subl" /usr/local/bin/subl

create a symbolic link named "bar" to file that named is a result of the command `canonical.bash foo`
ln -s `canonical.bash foo` bar

Create a symbolic link named "foo" to "/var/cache/apt/archives/bash_4.3-14ubuntu1_amd64.deb"
ln -s   /var/cache/apt/archives/bash_4.3-14ubuntu1_amd64.deb foo

Create a symbolc link named "latest" to the last modified file or directory in "target-directory"
ln -s target-directory/`ls -rt target-directory | tail -n1` latest

create a symbolic link named "link" in directory named as value of the variable $2 to a file that named as result of the command `cd \`dirname $2\`; pwd`/`basename $2`
ln -s `cd \`dirname $2\`; pwd`/`basename $2` $1/link

Create a symbolc link named "public_html" to "current/app/webroot" under the current working directory
ln -s `pwd`/current/app/webroot public_html

create a symbolic link named "test" to file ".bashrc"
ln -s .bashrc test

Create a symbolic link named "wh" to "$wh"
ln -s "$wh" wh

create a symbolic link named "www" to file "www1"
ln -s www1 www

Create a symbolic link named "~/bin/subl" to "/Applications/Sublime Text.app/Contents/SharedSupport/bin/subl"
ln -s "/Applications/Sublime Text.app/Contents/SharedSupport/bin/subl" ~/bin/subl

Create a symbolic link named the basename of "$file" to "$file"
ln -s $file `basename $file`

Create a symbolic link relative to link location named "$dest_dir/$orig_name" to "$orig_dest"
ln -r -s "$orig_dest" "$dest_dir/$orig_name"

Create a symbolic link to "$file" named "/tmp/allfiles"
ln $file /tmp/allfiles

Create a symbolic link to file "/usr/bin/perl" named with escaped characters "/usr/local/bin/perl\r\n"
sudo ln -s /usr/bin/perl /usr/local/bin/perl`echo -e '\r'`

create a symbolic link with absolute path "/cygdrive/c/Program Files" to file "/cygdrive/c/ProgramFiles"
ln -s "/cygdrive/c/Program Files" /cygdrive/c/ProgramFiles

create a symbolic link with absolute path "/cygdrive/c/Users/Mic/mypics" to file "/cygdrive/c/Users/Mic/Desktop/PENDING - Pics/"
ln -sf '/cygdrive/c/Users/Mic/Desktop/PENDING - Pics/' /cygdrive/c/Users/Mic/mypics

create a tar.gz compress file with all the jpg files in the entire file system
find / -name *.jpg -type f -print | xargs tar -cvzf images.tar.gz

Creae a tarball 'files.tar.gz' containing all regular files under current directory tree that are newer than 2013-12-04 and older than 2013-12-05
find . -type f -name "*" -newermt 2013-12-04 ! -newermt 2013-12-05 | xargs -I {} tar -czvf files.tar.gz {}

create a cpio archive of the entire contents the current directory while preserving the permissions, times, and ownership of every file and sub-directory
find . -depth -print | cpio -o -O /target/directory

Create all directories in the path specified by variable $javaUsrLib as super user
sudo mkdir -p $javaUsrLib

create and list contents of the archive
tar cf - $PWD|tar tvf -

Create hard links of all files and directories matching "test/icecream/cupcake/*" or "test/mtndew/livewire/*" in "test-keep" preserving directory hierarchy
find test -path 'test/icecream/cupcake/*' -o -path 'test/mtndew/livewire/*' | cpio -padluv test-keep

Create master SSH control socket "my-ctrl-socket" in the background with no terminal or command execution with connection forwarding from localhost port 50000 to localhost port 3306 via "jm@sampledomani.com"
ssh -M -S my-ctrl-socket -fnNT -L 50000:localhost:3306 jm@sampledomain.com

create alias subs for command  "du -sch `find ./ -maxdepth 1 -type d`"
alias subs="du -sch `find ./ -maxdepth 1 -type d`"

create an archive and show a progress bar
tar -c --checkpoint=.1000 /var

create an archive and show a progress bar
tar -c --checkpoint=1000 --checkpoint-action=dot /var

create an archive excluding files matching patterns listed in /path/to/exclude.txt
tar -czf backup.tar.gz -X /path/to/exclude.txt /path/to/backup

Create an archive named newArch from the contents of ./test directory
find ./test -printf "././%f\n"| cpio -o -F newArch

create an archive using 'pigz' as a compress program
tar -c --use-compress-program=pigz -f tar.file dir_to_zip

create an archive using 7zhelper.sh as a compress program
tar -I 7zhelper.sh -cf OUTPUT_FILE.tar.7z paths_to_archive

Create an empty index.html, or update its timestamp if it already exists.
touch index.html

Create an empty file "foo" in each directory under the current directory containing a file named "bar".
find -name "bar" -execdir touch foo \;

Create an empty file 'last.check' in directory pointed by variable "log_dir", with specified timestamp.
touch -m 201111301200.00 $log_dir/last.check

Create an empty file called "emptyfile.c"
cp /dev/null emptyfile.c

Create an empty file in each directory named "mydir" under current directory.
find . -type d -name "mydir" -exec touch '{}/abc.txt' \;

Create an empty file (or update timestamp of file) specified by variable "correctFilePathAndName"
touch "$correctFilePathAndName"

Create an empty file with a carriage return character in its name.
echo -e "Icon\\r" | xargs touch

Create an empty file with a carriage return character in its name.
touch $'Icon\r'

create archive "backup.tar.gz" from /path/to/catalog
tar czfP backup.tar.gz /path/to/catalog

create backup of all the text files  present in the current folder
find -name "*.txt" cp {} {}.bkup \;

Create compressed archive from "my_large_file_1" and "my_large_file_2" and split into files of size 1024 MiB with prefix "myfiles_split.tgz_"
tar cz my_large_file_1 my_large_file_2 | split -b 1024MiB - myfiles_split.tgz_

Create compressed archive of all the files in the current directory tree that have been modified in the last 7 days
find . -type f -mtime -7 -print -exec cat {} \; | tar cf - | gzip -9

create directory ".hiddendir"
mkdir .hiddendir

Create directories "/tmp/x/y/z/" on remote host before copying "$source" to "user@remote:/tmp/x/y/z/"
rsync -a --rsync-path="mkdir -p /tmp/x/y/z/ && rsync" $source user@remote:/tmp/x/y/z/

create directory /cpuset
mkdir /cpuset

create directory /data/db
sudo mkdir /data/db

create directory /etc/cron.15sec
mkdir /etc/cron.15sec

create directory /etc/cron.minute
mkdir /etc/cron.minute

create directory /path/to/destination
mkdir /path/to/destination

create directory /tmp/foo
mkdir /tmp/foo

create directory /var/svn as user root
sudo mkdir /var/svn

create directories a b c d e
mkdir a b c d e

create directory aaa/bbb
mkdir aaa/bbb

create directory log into home directory
mkdir ~/log

create directory backup
mkdir backup

create directories bravo_dir and alpha_dir
mkdir bravo_dir alpha_dir

create directory tata
mkdir tata

create directory destdir
mkdir destdir

create directory dir1
mkdir dir1

Create directory dir2
mkdir dir2

create directory dirname with permissions 777
mkdir -m 777 dirname

create directory es if it is not exist and create direcoty LC_MESSAGES
mkdir -p es/LC_MESSAGES

create directory aaa
mkdir aaa

create directory foo
mkdir -p foo

create directory foo
mkdir foo

create directories mnt and point
mkdir mnt point

create directory dir
mkdir -p dir

create directory public_html into home directory
mkdir ~/public_html

create directory temp into home directory
mkdir ~/temp

create directory subdirectory
mkdir subdirectory

create directory TestProject
mkdir TestProject

Treat each line of "list-of-entries.txt" as a value to be put in one cell of the table that "column" outputs
column list-of-entries.txt

Create empty files (or update timestamps if they exist) with names matching each word in variable "correctFilePathAndName"
echo -e "$correctFilePathAndName" | xargs touch

Create empty file (or update timestamp to current date/time if file already exists) named with full timestamp (year/month/day/hour/minute/second).
touch filename_`/bin/date +%Y%m%d%H%M%S`.txt

Create tar archive "dirall.tar" and copy all files from directory tree /tmp/a1 to it
find /tmp/a1 -exec tar -rvf dirall.tar {} \;

Create tar archive "dirall.tar" and copy all files from directory tree /tmp/a1 to it
find /tmp/a1 -print0 | tar --null -T- -cvf dirall.tar

Create tar archive "foo.tar" and copy all files from directory tree /tmp/a1 to it
find /tmp/a1 | xargs tar cvf foo.tar

Creates full path with parents, that matches to folder path extracted from $f variable.
mkdir -p -- "$(dirname -- "$f")"

Create intermediate directories "b and "c" as required and directory "c"
mkdir -p a/b/c

Create intermediate directories "full", "path" as required and directory "to"
mkdir -p `dirname /full/path/to/file.txt`

Create intermediate directories "tmp" as required and directories real_dir1 and real_dir2
mkdir -p tmp/real_dir1 tmp/real_dir2

Create intermediate directories "x" and "p" as required and create "q"
mkdir -p x/p/q

Create intermediate directories as required and directory  /my/other/path/here
mkdir -p /my/other/path/here

Create intermediate directories as required and directory /tmp/test/blah/oops/something
mkdir -p /tmp/test/blah/oops/something

Create intermediate directories as required and directory project/{lib/ext,bin,src,doc/{html,info,pdf},demo/stat/a}
mkdir -p project/{lib/ext,bin,src,doc/{html,info,pdf},demo/stat/a}

Create intermediate directories as required directory{1..3} and subdirectory{1..3} and directories subsubdirectory1 and subsubdirectory2
mkdir -p directory{1..3}/subdirectory{1..3}/subsubdirectory{1..2}

Create intermediate directories foo and bar as required and directory foo/bar/baz
mkdir -p foo/bar/baz

Create intermediate directoriy path2 as required and directories a..z
mkdir -p path2/{a..z}

Create intermediate directories ~/foo/bar/ as required and directories baz, bif, bang
mkdir -p ~/foo/bar/baz ~/foo/bar/bif ~/foo/boo/bang

Create MD5 message digest of "/path/to/source/file" starting at byte 100 until the 250th byte
dd if=/path/to/source/file bs=1 skip=100 count=250 | md5sum

Create new crontab set for user 'test' including $job and only jobs from current crontab of 'test' user that don`t contain $command
cat <(fgrep -i -v "$command" <(crontab -u test -l)) <(echo "$job") | crontab -u test -

Create new crontab set including $job and only jobs from current crontab that don`t contain $command
cat <(fgrep -i -v "$command" <(crontab -l)) <(echo "$job") | crontab -

Creates random file name formatted like expression in variable ${str// /X} and saves it in 'rand_str' variable.
rand_str=$(mktemp --dry-run ${str// /X})

Create script filesPermissions.sh that restores the original permissions of the regular files in the current directory tree
find . -type f | xargs stat -c "%a %n" | awk '{print "chmod "$1" "$2}' > ./filesPermissions.sh

Create script filesPermissions.sh that restores the original permissions of the regular files in the current directory tree
find . -type f |xargs ls -la| awk '{print "chmod "$1" "$NF}'>./filesPermissions.sh

Create six empty files in directory ~/junk
find ~/junk -exec touch ~/junk/cart{1,2,3,4,5,6} {} \; 2> /dev/null

Creates file with random 10-byte size content.
shred -s 10 - > my-file

Create ssh tunnel through "genja.org" connecting localhost port 4444 to "raptor.lan" port 22
ssh -L 4444:raptor.lan:22 genja.org

create symbolic links in current directory to all files located in "dir" directory and have filename extension "jpg"
find dir -name \*.jpg -print0 | xargs -0 -N1 ln -s

create symbolic links in current directory to all files located in directory "/original" and have filename extension ".processname"
find /original -name '*.processme' -exec echo ln -s '{}' . \;

create symbolic links in current directory to all files located in directory "/original" and have filename extension ".processname"
ln -s $(echo /original/*.processme) .

create symbolic links in directory "/usr/local/symlinks " to all files located in directiry "incoming" and that have been modified earlier then 5 days and owned by user "nr"
find /incoming -mtime -5 -user nr -exec ln -s '{}' /usr/local/symlinks ';'

create symbolic links in directory "/your/dest/dir/" to all files located in "/your/source/dir/" and have filename extension "txt.mrg"
find /your/source/dir/ -iname '*.txt.mrg' -exec ln -s '{}' /your/dest/dir/ \;

create symbolic links in directory "folder2" to all files located in current directory that filename not started with "."
(IFS=$'\n'; for t in `find -type f -name "*txt*" | sed 's|.*/||'`; do ln -s $t ../folder2/$t; done)

Create symbolic links in the current directory for all files excluding "CONFIGFILE" located in "/your/project"
find /your/project -maxdepth 1 ! -name "CONFIGFILE" -exec ln -s \{\} ./ \;

Create symbolic links in the current directory for all files excluding "CONFIGFILE" located under "/your/project" directory tree
find /your/project -type f ! -name 'CONFIGFILE' -exec ln -s \{\} ./ \;

Create symbolic links in the current directory for all files located in directory "/path/with/files" with a name containing "txt"
find /path/with/files -type f -name "*txt*" -exec ln -s {} . ';'

Create symbolic links in the current directory for all files under "bar1" that are not directories and do not end in ".cc"
find bar1 -name '*foo*' -not -type d -not -name '*.cc' -exec ln -s $PWD/'{}' bar2/ \;

Create symbolic link "$1/link" to the absolute path of "$2"
ln -s "$(readlink -e "$2")" "$1/link"

Create symlinks to all  /home/folder1/*.txt files and 'folder1_' directory with the same name in a target directory named '+'
find /home/folder1/*.txt -type f -exec ln -s {} "folder1_" +\;

Create symlinks to all  /home/folder1/*.txt files and 'folder2_' directory with the same name in a target directory named '+'
find /home/folder1/*.txt -type f -exec ln -s {} "folder2_" + \;

Create symlinks to all  /home/folder2/*.txt files with the same name in current directory
find /home/folder2/*.txt -type f -exec ln -s {} \;

Create tar.gz files older than one day logs
find /home/testuser/log/ -mtime +1 | xargs  tar -czvPf  /opt/older_log_$(date +%F).tar.gz

Creates temporary directory in '/tmp/' folder and saves path to it in 'my_tmp_dir' variable.
my_tmp_dir=$(mktemp -d --tmpdir=/tmp)

Creates temporary directory with name formatted like .daemonXXXXXXX in /tmp/ folder, and saves path to it in 'TMPDIR' variable.
TMPDIR=$(mktemp -p /tmp -d .daemonXXXXXXX)

Creates temporary folder, and saves current folder path   joined with created temporary folder path in 'tdir' variable.
tdir="$(pwd)/$(mktemp -d)"

Creates temporary folder and saves path to it in 'other' variable.
other="$(mktemp --directory)"

Creates temporary folder and saves path to it in 'td' variable.
td=$( mktemp -d )

Creates temporary folder and saves path to it in a 'tempd' variable.
tempd=`mktemp -d`

Creates temporary folder and save path to that in a TMPDIR variable.
TMPDIR=$(mktemp -d)

Creates temporary folder in /tmp/ (by default) with 10-letter suffux.
mktemp -d -t

Creates temporary folder in a $temp_dir folder with name pattern defined by $template, and stores path to created folder in 'my_temp' variable.
$ my_temp_dir=$(mktemp -d --tmpdir=$temp_dir -t $template)

Creates temporary folder in a TMPDIR folder or /tmp folder if TMPDIR doesn`t defined, with folder name like current shell name and 10-letter suffix, and saves created path in 'mydir' variable.
mydir=$(mktemp -d "${TMPDIR:-/tmp/}$(basename $0).XXXXXXXXXXXX")

Creates temporary folder in TMPDIR (if defined) or in '/tmp/', and stores path to created folder in 'dir' variable.
dir=$(mktemp -d)

Creates temporary folder in TMPDIR (if defined) or in '/tmp/', and stores path to created folder in 'tmpdir' variable.
tmpdir=$(mktemp -d)

Creates temporary folder relative to directory '/path/to/dir'.
mktemp -d -p /path/to/dir

Creates temporary folder like '/tmp/tardir-XXXXXX' with 6-letter suffix and saves its path in 'tmpdir' variable.
tmpdir=$(mktemp -d /tmp/tardir-XXXXXX)

Creates temporary folder within a $mnt_dir folder and saves path to it in a 'rsync_src' variable.
rsync_src=`mktemp -d -p $mnt_dir`

Creates temporary folder within TMPDIR, with name like current shell name and 10-letter suffix.
mktemp -dt "$(basename $0).XXXXXXXXXX"

Creates temporary file and saves path to it in 'content_dir1' variable.
content_dir1=$(mktemp)

Creates temporary file and saves path to it in 'content_dir2' variable.
content_dir2=$(mktemp)

Creates temporary file and saves path to it in 'fif2' variable.
fif2=$(mktemp -u)

Creates temporary file and saves path to it in a 'tmpfile' variable.
tmpfile=$(mktemp)

Creates temporary file and saves path to it in a 'tmpfile' variable.
tmpfile=`mktemp`

Creates temporary file by template provided in option '-t'.
mktemp -t identifier.XXXXXXXXXX

Creates temporary file in $appdir variable with name formatted like expression in variable ${template}, and saves path to it in 'launcherfile' variable.
launcherfile=$(mktemp -p "$appdir" "$template")

Creates temporary file in a current folder and saves path to it in 'f' variable.
f=`mktemp -p .`

Creates temporary file in a current folder with name formatted like 'templateXXXXXX', and saves path to it in 'tempfile' variable.
tempfile=$(mktemp $(pwd)/templateXXXXXX)

Creates temporary file in a TMPDIR folder or /tmp folder if TMPDIR doesn`t defined, with file name like current shell name and '-XXXXX'-formatted suffix, and saves created path to the 'tempFile' variable.
tempFile="$(mktemp "${TMPDIR:-/tmp/}$(basename "$0")-XXXXX")"

Creates temporary file in a TMPDIR folder with name like tmp.XXXXXXXXXX.
mktemp

Creates temporary file in TMPDIR folder or /tmp/ if TMPDIR is not defined, named by template ${tempname}.XXXXXX, and saves path to new file in  a TMPPS_PREFIX variable.
TMPPS_PREFIX=$(mktemp "${TMPDIR:-/tmp/}${tempname}.XXXXXX")

Creates temporary file name and saves path to it in 'TMP_FILE' variable.
TMP_FILE="$(mktemp -t)"

Creates temporary file, replacing XXXXXXXXXXXXXXXXXXXXXXX with equal length suffix.
mktemp /tmp/banana.XXXXXXXXXXXXXXXXXXXXXXX.mp3

Creates temporary file with appended suffix '.cmd' and saves path to it in 'LGT_TEMP_FILE' variable.
LGT_TEMP_FILE="$(mktemp --suffix .cmd)"

Creates temporary file with name formatted like '.script.XXXXXX' in '/tmp/' folder and saves path to it in 'script1' variable.
script1=`mktemp /tmp/.script.XXXXXX`;

Creates temporary file with name formatted like '.script.XXXXXX' in '/tmp/' folder and saves path to it in 'script2' variable.
script2=`mktemp /tmp/.script.XXXXXX`;

Creates temporary file with name formatted like 'emacs-manager.XXXXXX' in '/tmp/' folder and saves path to it in 'tmp_file' variable.
tmp_file=`mktemp --tmpdir=/tmp emacs-manager.XXXXXX`

Creates temporary file with name formatted like expression in variable ${PROG}, and saves path to it in 'mytemp' variable.
mytemp="$(mktemp -t "${PROG}")"

Creates temporary file with file name formatted like /tmp/gnuplot_cmd_$(basename "${0}").XXXXXX.gnuplot and saves path to it in a variable 'gnuplotscript'.
gnuplotscript=$(mktemp /tmp/gnuplot_cmd_$(basename "${0}").XXXXXX.gnuplot)

create the compressed tar archive images.tar.gz containing all jpg files found under /
find / -name *.jpg -type f -print | xargs tar -cvzf images.tar.gz

Create the directory '.npm-global' in the user's home directory(~).
mkdir ~/.npm-global

Create the directory '.npm-packages' in the user's home directory($HOME)
mkdir "${HOME}/.npm-packages"

Create thumbnails from the first page of each PDF files under /path/to/dir
find /path/to/dir -name '*.pdf' -exec convert -thumbnail x80 {}[0] {}-thumb.png \;

From a script, output the name of the script itself, without containing directories.
basename $0

From a script, output the name of the script itself, without containing directories - from a shell, output the name of the shell.
basename -- $0

From another terminal, detach process $PID from its terminal and run it in the background.
kill -20 $PID; kill -18 $PID

Clone the permissions of "$srcdir" to "$dstdir" on OSX
chown $(stat -f%u:%g "$srcdir") "$dstdir"

Runs `file' on every file in or below the current directory.
find . -type f -exec file '{}' \;

Runs 'mpv' command for each *.mpv and *.flv file in a current folder.
mpv --no-audio \`ls ~/Down/other/*.{mp4,flv} --color=never\`

Runs 'tty' command in a subshell that is opened by built-in function 'true'.
true | echo `tty | sed 's:/dev/::'`

Cuts off last part from the path $dir, and deletes resulted folder if empty.
rmdir "$(dirname $dir)"

Cuts off last two parts from the path $dir, and deletes resulted folder if empty.
rmdir "$(dirname $(dirname $dir))"

Runs programs and prints formatted summary of system resource usage.
\time -f "%E real,%U user,%s sys" ls -Fs

Runs programs and prints formatted summary of system resource usage.
command time -f "%E real,%U user,%s sys" ls -Fs

Puts working directory into clipboard, stripping newlines
echo -n $(pwd) | pbcopy

Puts working directory into clipboard, stripping newlines
printf $(pwd) | pbcopy

Puts working directory into clipboard, stripping newlines
pwd | tr -d '\n' | pbcopy

date --date="222 days ago" +"%m"
Prints what month it was 222 days ago

Decompresses each of "*bz2" files under the current folder, redirecting output to the standard out, and prints only fourth of comma-separated fields.
find . -name "*.bz2" -print0 | xargs -I{} -0 bzip2 -dc {} | cut -f, -d4

Decompresses file 'xac.bz2', redirecting output to standard out.
bzip2 -dc xac.bz2

Delete "\n\r" from "yourfile.txt"
tr -d "\n\r" < yourfile.txt

Delete 'string_to_find' from all files under current directory
find . -type f | xargs grep 'string_to_find' -sl | xargs perl -pi -w -e 's/string_to_find//g;'

delete a hard link and create a symbolic link to file named "$link"
ln -sf "$(readlink -f "$link")" "$link"

Delete all ".DS_Store" files/directories under test directory
find test -name ".DS_Store" -delete

Delete all '-' character from $1 and save the resultant string to variable 'COLUMN'
COLUMN=`echo $1 | tr -d -`

Delete all *.zip files under current directory that are older than 2 days
find . -name "*.zip" -mtime +2 -print0 | xargs -0 -I {} rm {}

Delete all *.zip files under current directory that are older than 2 days
find . -name "*.zip" -mtime +2 orint0 | xargs -0 rm

Delete all *txt files under current directory
find . -name "*txt" -type f -print | xargs rm

Delete all .bam files in the current directory tree
find . -name "*.bam" | xargs rm

Delete all .pyc files in the current directory tree
find . -name "*.pyc" | xargs -0 rm -rf

Delete all .pyc files in the current directory tree
find . -name "*.pyc" | xargs rm -rf

Delete all .svn directories under current directory
find . -type d -name .svn -print0|xargs -0 rm -rf

Delete all .svn files/directories under current directory
find . -depth -name .svn -exec rm -fr {} \;

Delete all .svn files/directories under current directory
find . -name .svn -delete

Delete all .svn files/directories under current directory
find . -name .svn -exec rm -rf '{}' \;

Delete all .svn files/directories under current directory
find . -name .svn -exec rm -rf {} +

Delete all .svn files/directories under current directory
find . -name .svn -exec rm -rf {} \;

Delete all .svn files/directories under current directory
find . -name .svn -exec rm -v {} \;

Delete all .svn files/directories under current directory
find . -name .svn | xargs rm -fr

Delete all .svn files/directories under current directory
find . -name .svn |xargs rm -rf

Delete all .svn subdirectories under current directory
rm -rf `find . -type d -name ".svn"`

Delete all 1US* (case insensitive) files under current directory
find . -iname "1US*" -exec rm {} \;

Delete all __temp__* directories under maximum 1 level down the current directory tree
find . -maxdepth 1 -type d -name '__temp__*' -print0 | xargs -0 rm -rf

Delete all but the most recent 5 files
ls -tr | head -n -5 | xargs rm

Delete all but the most recent X files in bash
(ls -t|head -n X;ls)|sort|uniq -u|xargs rm

Delete all broken symbolic links under '/usr/ports/packages' directory tree
find -L /usr/ports/packages -type l -exec rm -- {}	+

Delete all contents (including new lines) form the files that contain the regex 'string' in maximum 1 level down the / directory excluding other partitions
find / -maxdepth 1 -xdev -type f|xargs grep -l 'string'| xargs perl -pi -e 's/.*\n//g'

Delete all contents form the files that contain the regex 'string' in maximum 1 level down the / directory excluding other partitions
find / -maxdepth 1 -xdev -type f|xargs grep -l 'string'| xargs perl -pi -e 's/.//g'

Delete and count files in $DIR_TO_CLEAN that are older than $DAYS_TO_SAVE days
find "$DIR_TO_CLEAN" -mtime +$DAYS_TO_SAVE -exec bash -c 'printf "Total: %d\n" $#; rm "$@"' _ {} +

Delete and count files in $DIR_TO_CLEAN that are older than $DAYS_TO_SAVE days
find "$DIR_TO_CLEAN" -mtime +$DAYS_TO_SAVE -exec bash -c 'printf "count=0; for f; do rm "$f" && (( count++ )); done; printf "Total: %d\n" $count' _ {} +

Delete and count files in $DIR_TO_CLEAN that are older than $DAYS_TO_SAVE days
find "$DIR_TO_CLEAN" -type -f -mtime "+$DAYS_TO_SAVE" -exec rm {} \; -exec printf '.' \; | wc -c

Delete and count files in $DIR_TO_CLEAN that are older than $DAYS_TO_SAVE days
find "$DIR_TO_CLEAN" -type -f -mtime "+$DAYS_TO_SAVE" -exec rm {} \; -printf '.' | wc -c

Delete all directories found in $LOGDIR that are more than a work-week old
find $LOGDIR -type d -mtime +5 -exec rm -rf {} \;

Delete all directories in the /myDir directory tree
find /myDir -type d -delete

Delete all directories in the TBD directory that were modified more than 1 day ago
find /TBD -mtime +1 -type d | xargs rm -f -r

Delete all directories under '.cache/chromium/Default/Cache' directory tree that are at least 1 level deep and are bigger than 100 MB in size
find .cache/chromium/Default/Cache/ -mindepth 1 -type d -size +100M -delete

Delete all directories under <directory_name> that contain directories named 'test' and 'live'
find <directory_name> -type d -exec sh -c "cd {} && [ -d live ] && [ -d test ] && cd ../ && echo \"Deleting {}\" && rm -rvi {} " {} \;

Delete all empty directories and directories that contain only empty directories under current directory
find -type d -empty -exec rmdir -vp --ignore-fail-on-non-empty {} +

Delete all empty directories and directories that contain only empty directories under current directory
find -type d -empty -exec rmdir -vp --ignore-fail-on-non-empty {} `;`

Delete all empty directories in minimum 2 levels down the root directory
find root -mindepth 2 -type d -empty -delete

Delete all empty directories in the "test" directory tree
find test -depth -type d -empty -delete

Delete all empty directories in the current directory tree
find -type d -empty -exec rmdir -vp --ignore-fail-on-non-empty {} +

Delete all empty directories in the current directory tree
find -type d -empty -exec rmdir -vp --ignore-fail-on-non-empty {} `;`

Delete all empty directories under current directory
find -type d -empty

Delete all empty directories under test directory
find test -depth -type d -empty -delete

Delete all empty directories under root
find root -type -d -empty -delete

Delete all empty files and directories in the "test" directory tree
find test -depth -empty -delete

Delete all empty files/directories under test directory
find test -depth -empty -delete

Delete all empty files in the current directory tree
find . -type f -empty -delete

delete all empty files in the current directory ( empty file = size 0 bytes )
find . -empty -exec rm '{}' \;

delete all text files from current folder
find . -type f ! -iname "*.txt" -delete

delete all text files in the entire file system
find / -type f -name "*.txt" -print | xargs rm

delete all text files in the home folder after user confirmation
find $HOME/. -name "*.txt" -ok rm {} \;

Delete all files and directories
find -delete

Delete all files/directories older than 48 hours in /path/to/files* paths
find /path/to/files* -mtime +2 -delete

Delete all files/directories in minimum 2 levels down the root directory
find root -mindepth 2 -delete

Delete all files/directories named 'FILE-TO-FIND' under current directory tree
find . -name "FILE-TO-FIND" -exec rm -rf {} \;

Delete all files/directories named 'sample' (case insensitive) under '/home/user/Series/' directory tree as super user
sudo find /home/user/Series/ -iname sample -print0 | sudo xargs -0 rm -r

Delete all files/directories named test under maximum 2 level down the current directory
find . -maxdepth 2 -name "test" -exec rm -rf {} \;

Delete all files/directories taken by the glob pattern * except the ones with the name 'b'
find * -maxdepth 0 -name 'b' -prune -o -exec rm -rf '{}' ';'

Delete all files/directories taken by the glob pattern * except the ones with the name 'b'
find * -maxdepth 0 -name 'b' -prune -o -exec rm -rf {} \;

Delete all files/directories under current directory
find -delete

Delete all files/directories under current directory tree with '.$1' extension where $1 expands as the first positional parameter
find . -name "*.$1" -delete;

Delete all files/directories with inode number 117672808 under current directory tree
find -inum 117672808 -exec rm {} \;

Delete all files/directories with node number $inum under current directory tree
find . -inum $inum -exec rm {} \

Delete all files in directory $DIR that have not been accessed in at least 5 days
find "$DIR" -type f -atime +5 -exec rm {} \;

Delete all files in the "${S}/bundled-libs" folder except "libbass.so"
find "${S}/bundled-libs" \! -name 'libbass.so' -delete

Delete all files in the $DIR directory that have not been accessed in 5 or more days.
find "$DIR" -type f -atime +5 -exec rm {} \;

Delete all files in the /TBD directory that were modified more than 1 day ago
find /TBD/* -mtime +1 -exec rm -rf {} \;

Delete all files in the /myDir directory tree that were last modfied 7 days ago
find /myDir -mindepth 1 -mtime 7 -delete

Delete all files in the /myDir directory tree that were last modfied 7 days ago
find /myDir -mindepth 1 -mtime 7 -exec rm -rf {} \;

Delete all files in the /myDir directory tree that were last modified 7 days ago
find /myDir -mtime 7 -exec rm -rf {} \;

Delete all files in the /myDir directory tree that were last modfied more than 7 days ago
find /myDir -mindepth 1 -mtime +7 -delete

Delete all files in the TBD directory that were modified more than 1 day ago
find /TBD/* -mtime +1 | xargs rm -rf

Delete all files in the current directory.
find . -exec /bin/rm {} \;

Delete all files in the current directory tree whose names end with ~
find . -name "*~" -delete

Delete all files in the current directory tree whose names end with ~
find . -name "*~" -exec rm {} \;

Delete all files in the current user's home directory and its sub-directories that have not been accessed for more than 100 days.
find ~ -atime +100 -delete

Delete all files named "filename" in the current directory tree, except the one with path ./path/to/filename
find . -name "filename" -and -not -path "./path/to/filename" -delete

Delete all files named "filename" in the current directory tree, except those with paths ending in "/myfolder/filename"
find . -name "filename" -and -not -path "*/myfolder/filename" -delete

Delete all files named '-F' under current directory tree
find . -name "-F" -exec rm {} \;

Delete all files named 'Waldo' under ~/Books directory tree where '~' expands to user's home directory
find ~/Books -type f -name Waldo -exec rm {} \;

Delete all files (files, directories, links, pipes...) named 'core' under current directory
find . -name "core" -exec rm -f {} \;

Delete all files named 'sample' (case insensitive) under '/home/user/Series' directory tree with superuser privilege
sudo find /home/user/Series/ -iname sample -exec rm {} \;

Delete all files not owned by valid users
find / -nouser | xargs -0 rm

Delete all files that have not been accessed in the last 30 days
find . -type f -atime +30 -exec rm {} \;

Delete all files that were modified more than 60 days ago under '/path-to-directory' tree
find /path-to-directory -mtime +60 -exec rm -f {} \;

Delete all files throughout the entire filesystem that are no longer owned by a valid user.
find / -nouser | xargs -0 rm

Delete all files under $DESTINATION directory tree that were modified more than 7 days ago
find $DESTINATION -mtime +7 -exec rm {} \;

Delete all files under $INTRANETDESTINATION/monthly directory tree that were modified more than 366 days ago
find $INTRANETDESTINATION/monthly -mtime +366 -exec rm {} \;

Delete all files under $INTRANETDESTINATION/weekly directory tree that were modified more than 32 days ago
find $INTRANETDESTINATION/weekly -mtime +32 -exec rm {} \;

Delete all files under '/home/backups' directory tree with '.tgz' or '.gz' extension (case insensitive) that were modified more thant 60 days ago
find /home/backups -type f -iregex '.*\.t?gz$' -mtime +60 -exec rm {} \;

Delete all files under /path/to/files that are not newer than dummyfile
find /path/to/files -type f ! -newer dummyfile -delete

Delete all files under and below the current directory
find -mindepth 1 -delete

Delete all files under root whose status were changed more than 30 minutes ago
find root -type -f -cmin +30 -delete

Delete all files under user's home directory tree that were accessed more than 365 days after their status was changed
find ~ -used +365 -ok rm '{}' ';'

Delete all files with ' .o' extension in the entire filesystem
find project / src / -name "* .o" -exec rm -f {} \;

Delete all files with '.old' extension under current directory tree
find . -name “*.old” -exec rm {} \;

Delete all files with '.old' extension under current directory tree
find . -name “*.old” -print | xargs rm

Delete all files with inode number 804180
find -inum 804180 -exec rm {} \

Delete all files with indoe number $inum under current directory tree
find . -inum $inum -exec rm {} \;

delete all files in $DIR that have not been accessed in at least 5 days
find "$DIR" -type f -atime +5 -exec rm {} \;

delete all files in the home directory which ahve the name core in them
find ~/ -name 'core*' -exec rm {} \;

delete all files that have the extension "bam" in current directory
find . -name "*.bam" | xargs rm

Delete all non digits from index "$i" in bash array "depsAlastmodified" and print the hex dump as characters
echo "${depsAlastmodified[$i]}" | tr -cd '[[:digit:]]' | od -c

Delete all hidden files/directories under $some_directory
find "$some_directory" -name '.*' ! -name '.' ! -name '..' -delete

Delete all hidden files/directories under $some_directory including $some_directory
find $some_directory '.*' -delete

Delete all hidden files in the directory tree given as variable $FOLDER
find $FOLDER -name ".*" -delete

Delete all hidden files under $some_directory
find "$some_directory" -type f -name '.*' -delete

Delete all hidden files under $some_directory
find "$some_directory" -type f -name '.*' -exec rm '{}' \;

Delete all hidden files under $some_directory
find "$some_directory" -type f -name '.*' | xargs rm

Delete all HTML files under tree ~/mydir
find ~/mydir -iname '*.htm' -exec rm {} \;

Delete all in the current directory tree
find . -delete

delete all instances of the file "bad" if its size is 0 bytes
find . -name bad -empty -delete

Delete all lines in "file" that contain "pattern", using "temp" as temporary working file (ie. shouldn't exist).
grep -v "pattern" file > temp && mv temp file

Delete all MP3 files under /tmp
find /tmp -iname '*.mp3' -print0 | xargs -0 rm

Delete all regular files under $DIR directory tree that have been modified before file $a
find "$DIR" -type f \! -newer "$a" -exec rm {} +

Delete all regular files under current directory
find . -type f -print0 | xargs -0 /bin/rm

Delete all regular files named 'FILE-TO-FIND' under current directory tree
find . -type f -name "FILE-TO-FIND" -exec rm -f {} \;

Delete all regular files named 'IMAGE1806.jpg' under current directory tree
find . -type f -name 'IMAGE1806.jpg' -delete

Delete all regular files that reside in directory $OUTPUTDIR and below, and were last modified more than 7 days ago
find $OUTPUTDIR -type f -mtime +7 -delete

Delete all regular files that have not been modified in the last 31 days under '/path/to/junk/files' directory tree
find /path/to/junk/files -type f -mtime +31 -exec rm -f {} \;

Delete all regular files that have not been modified in the last 60 weeks under $DIR directory tree
find $DIR -type f -mtime +60w -exec rm {} \;

Delete all regular files that start with 'sess_' in their names, are at least 1 level deep and were modified more than $gc_maxlifetime minutes ago under $save_path directory tree
find -O3 "$save_path" -depth -mindepth 1 -name 'sess_*' -ignore_readdir_race -type f -cmin "+$gc_maxlifetime" -delete

Delete all regular files with '.cache' extension that were accessed more than 30 days ago under $HOME/Library/Safari/Icons directory tree
find $HOME/Library/Safari/Icons -type f -atime +30 -name "*.cache" -print -delete

Delete all regular files with '.txt' extension that were modified in more than 25 minutes ago in maximum 1 level down the directory '/home/u20806/public_html'
find /home/u20806/public_html -daystart -maxdepth 1 -mmin +25 -type f -name "*.txt" \ -exec rm -f {} \;

Delete all regular files with '.txt' extension that were modified in more than 25 minutes ago in maximum 1 level down the directory '/home/u20806/public_html'
find /home/u20806/public_html -maxdepth 1 -mmin +25 -type f -name "*.txt" -delete

Delete all regular files with inode number 314167125 under current directory tree
find . -type f -inum 314167125 -delete

delete all normal/regular files in the current folder which are empty
find . -type f -empty -delete

Delete all shared memory and semaphores for the current user on sun
ipcs | nawk -v u=`whoami` '/Shared/,/^$/{ if($6==0&&$3==u) print "ipcrm shm",$2,";"}/Semaphore/,/^$/{ if($3==u) print "ipcrm sem",$2,";"}' | /bin/sh

delete all the ".bak" or swap files in kat folder
find kat -type f \( -name "*~" -p -name "*.bak" \) -delete

delete all the ".doc" files in the current folder
find . -name '*.doc' -exec rm "{}" \;

delete all the "wmv" "wma" files in the currnet folder,
find . \( -name '*.wmv' -o -name '*.wma' \) -exec rm {} \;

Delete all the .c files present in the current directory and below
find . -name "*.c" | xargs rm -f

delete all the log files in the current folder
find -name '*.log' -delete

delete all the log files in the current folder
find ./ -name '*.log' -print0 | xargs -0 rm

delete all the log files in the current folder
find ./ -name '*.log' | xargs rm

delete all the log files which have not been modified in the last 5 days after user confirmation
find . — name "*.LOG" — mtime +5 -ok rm {} \;

delete all the broken symbolic links from the folder /usr/ports/packages
find -L /usr/ports/packages -type l -exec rm -- {} +

delete all the core files in the folder /prog which are bigger than 1KB
find /prog -type f -size +1000 -print -name core -exec rm {} \;

delete all the directories empty directories in the current folder
find . -type d -empty -delete

delete all the empty directories in the current folder
find . -type d -empty -exec rmdir {} \;

delete all the empty files in the current directory
find . -empty -exec rm {}\;

delete all the empty files in the current directory only if they are ok and the user has the permission to delete them
find . -empty -ok rm {}\;

delete all the empty files(files with size 0 bytes) in the current folder
find . -empty -delete -print

delete all the empty in the current folder and all its sub directories
find . -depth -type d -empty -exec rmdir {} \;

delete all the empty in the current folder do not search in sub directories
find . -maxdepth 1 -type d -empty -exec rm {} \;

delete all the text files from the current folder after user confirmation
find . -name "*.txt" -ok rm {} \;

delete all the text files starting with the name "oldStuff" in the file system
find / -name "oldStuff*.txt" -delete

Delete all the files found in the current directory tree whose names begin with "heapdump"
find . -name heapdump* -exec rm {} \ ;

Delete all the files found in the current directory tree whose names begin with "heapdump"
find . -name heapdump*|xargs rm

delete all the files ending with "~" in current folder
find -name '*~' -delete

delete all the files ending with "~" in current folder
find -name '*~' -print0 | xargs -0 rm

delete all the files ending with "~" in current folder
find . -name "*~" -print | xargs rm

delete all the files in the current folder which are bigger than 1KB
find . -size +1024 ?print|xargs -i rm \;

delete all the files in the current folder which have been modified in the last 14*24 hours
find . -mtime -14 -print|xargs -i rm \;

delete all the files in the current folder  which do not belong to any user
find / -nouser -exec rm {}\;

delete all the files in the current folder which do not belong to any user
find . -nouser | xargs rm

delete all the files in the file system which belong to the user edwarda
find / -user edwarda -exec rm "{}" \;

delete all the files in the file system which belong to the user edwarda after user confirmation
find / -user edwarda -ok rm "{}" \;

delete all the files which start with "Tes" in the current folder
find . -type f -name "Tes*" -exec rm {} \;

delete all the normal files in the current folder and do not delete those in the subfolders
find . -maxdepth 1 -type f -delete

delete all the hidden in the folder Musica after user confirmation
find Música/* -type f -name ".*" -exec /usr/bin/rm -i {} \;

delete all the mp3 files in the current folder.
find . -type f -name "*.mp3" -exec rm -f {} \;

delete all the mp3 files in the home folder
find /home/ -exec grep -l “mp3” {} \; | xargs rm

delete all the mp4 files in the folder /home which are bigger than 10MB
find /home -type f -name *.mp4 -size +10M -exec rm {} \;

delete all the tmp files ( files with the extension tmp ) in the /tmp folder
find /tmp -name "*.tmp" | xargs rm

delete all the tmp files ( files with the extension tmp ) in the /tmp folder. Print0 is used to display all those files which have newline in their names or files whose name is only spaces.
find /tmp -name "*.tmp" -print0 | xargs -0 rm   find /tmp -name "*.tmp" -print0 | xargs -0 rm

delete all the php files in the folder /var/www
find /var/www/*.php -type f -exec rm {} \;

delete all the normal/regular files in the current folder
find . -type f -print -delete

delete all the regular files in the temp folder which have not been modified in the last 24 hours
find /tmp/ -type f -mtime +1 -delete

delete all the regular files in the temp folder which have not been modified in the last 24 hours
find /tmp/ -type f -mtime +1 -exec rm {} \;

delete all the regular files in the temp folder which have not been modified in the last 24 hours
find /tmp/ -type f -mtime +1 -print0 | xargs -0 -n1 rm

delete all the regular files in the temp folder which have not been modified in the last 24 hours + at the end gives bulk input to the rm command
find /tmp/ -type f -mtime +1 -exec rm {} +

delete all the trace files (".trc") which have not been been accessed in the last 30*24 hours
find /dirpath \( -name \*.trc -a -mtime +30 \) -exec rm {} \;

Delete characters in columns 36 through 40 from the output of "finger"
finger |  cut --complement -c36-40

Delete current cron job list, and use those in yourFile.text
crontab yourFile.text

Delete empty directories
find . -type d -empty -delete

Delete empty files and print their names
find . -empty -delete -print

Deletes empty folder 'nonsense_dir'.
rmdir nonsense_dir

Delete everything except the control characters in "foobar\n\337" and dump the remaining characters
printf 'foobar\n\377' | tr -d '\0-\176' | od -t c

Delete everything in the current directory
find -mindepth 1 -maxdepth 1 -print0 | xargs -0 rm -rf

Delete files "*doc copoy" in directory tree /mnt/zip
find /mnt/zip -name "*doc copy" -execdir rm "{}" \;

Delete files containing whitespaces
find . -name "* *" -exec rm -f {} \;

Delete files containing whitespaces without recursion
find . -name '*[+{;"\\=?~()<>&*|$ ]*' -maxdepth 0 -exec rm -f '{}' \;

Delete files older than 31 days
find ./ -mtime +31 -delete

Delete files in $DIR_TO_CLEAN older than $DAYS_TO_SAVE days
find "$DIR_TO_CLEAN" -mtime +$DAYS_TO_SAVE -exec rm {} \;

Delete files in $DIR_TO_CLEAN that are older than $DAYS_TO_SAVE days
find "$DIR_TO_CLEAN" -mtime +$DAYS_TO_SAVE | while read FILE; do rm "$FILE"; done

Delete files in the DIR directory tree whose names begin with "2015" and contain "album" or "picture"
find DIR \( -name 2015\* -a \( -name \*album\* -o -name \*picture\* \) \) -delete

Delete files under $LOCATION that match $REQUIRED_FILES in their names and were modified more than 1 day ago
find $LOCATION -name $REQUIRED_FILES -type f -mtime +1 -delete

Delete files under $LOCATION that match $REQUIRED_FILES in their names and were modified more than 360 minutes ago
find $LOCATION -name $REQUIRED_FILES -type f -mmin +360 -delete

Delete files with inode number specified by [inode-number] under current directory
find . -inum [inode-number] -exec rm -i {} \;

Deletes folder like /tmp/*/* or deeper, older than +7 days if they don`t contain files or other folders.
find /tmp/*/* -mtime +7 -type d -exec rmdir {} \;

Delete history entry at offset, defined in first argument of executed script
history -d "$1"

Delete in the background all files in /var/tmp/stuff1 and below that have not been modified in over 90 days
find /var/tmp/stuff1 -mtime +90 -delete &

Delete interactively all the files/directories with inode number 782263 under current directory tree
find . -inum 782263 -exec rm -i {} \;

Delete line 2 in numbered file "file" and renumber
grep -v '^2 ' file | cut -d' ' -f2- | nl -w1 -s' '

Delete orphan vim undo files in the current directory tree
find . -type f -iname '*.un~' | while read UNDOFILE ; do FILE=$( echo "$UNDOFILE" | sed -r -e 's/.un~$//' -e 's&/\.([^/]*)&/\1&' ) ; [[ -e "$FILE" ]] || rm "$UNDOFILE" ; done

Delete recursively empty files named 'bad'
find . -name bad -empty -delete

delete recursively, without prompting, any files or directories under the current directory that case insensitively match the filename ".svn"
find . -iname .svn -exec rm -rf {} \;

delete recursively, without prompting, any files or directories under the current directory that case insensitively match the filename ".svn"
find . -iname .svn -print | xargs rm -rf

delete recursively, without prompting, any files or directories under the current directory that case insensitively match the filename ".svn"
find . -iname .svn -print0 | xargs -0 rm -rf

Delete file with inode number 314167125
find . -type f -inum 314167125 -delete

Delete the files under the current working directory with inode numbers specified on standard input
xargs -n 1 -I '{}' find "$(pwd)" -type f -inum '{}' -delete

Delete the oldest file with '.tgz' or '.gz' extension under '/home/backups' directory tree
ls -tr $(find /home/backups -name '*.gz' -o -name '*.tgz')|head -1|xargs rm -f

To descend at most one levels of directories below the command line arguments pass the -maxdepth 1 option. This will avoid deleting nested directories:
find .  -maxdepth 1 -type d -iname ".[^.]*" -print0 | xargs -I {} -0 rm -rvf "{}"

Descend into every directory under /etc and print the file/directory names with relative paths
find /etc -execdir echo "{}" ';'

Determine if /full/path exists on a mounted file system.
df /full/path | grep -q /full/path

Determine if the kernel is 32 bit or 64 bit
lshw -class cpu|grep "^       width"|uniq|awk '{print $2}'

Determine if user "$USER" is logged in
who | grep $USER

Determine the user associated with stdin
who -m

Disables shell option 'compat31'.
shopt -u compat31

Disables shell option 'dotglob'.
shopt -u dotglob

Disables shell option 'nullglob'.
shopt -u nullglob

Disable X11 forwarding and execute "cd yourRemoteDir; ./yourRemoteScript.sh </dev/null >/dev/null 2>&1" in the background on "remoteServer"
ssh -x remoteServer "cd yourRemoteDir; ./yourRemoteScript.sh </dev/null >/dev/null 2>&1 & "

discard all the errors and search for the file "program.c" in the entire file system
find / -name 'program.c' 2>/dev/null

lists txt or html files older than 5 days, null separated
find . \( -name '*.txt' -o -name '*.html' \) -mtime +5 -print0

Display "/tmp/file" as a table of width 30 with columns filled before rows
column -x -c 30 /tmp/file

Display "infile" as printable characters or backslash escapes
cat infile | od -c

Display 'file.txt' all occurrences of "foo" replaced by "bar", letting the user interactively page through the result.
cat file.txt | perl -ne 's/foo/bar/g;' | less

Display 12345 backwards
echo 12345 | rev

Display 798 backwards
echo 798|rev

display a long list and delete all the regular/normal files in the current folder starting with the word k which have been modified in the last 4 hours(360 minutes)
find . -type f -name “k*.*” -mmin -360 -exec ls -l ‘{}’ ; | xargs -0 /bin/rm -f

display a long list of all the directories which have files ending with ".todo"
find "$STORAGEFOLDER" -name .todo -printf '%h\n' | uniq | xargs ls -l

display a long list of all the directories which have files ending with ".todo"
find "$STORAGEFOLDER" -name .todo -printf '%h\n' | xargs ls -l

Display a long list of all the files/directories named ".todo" under $STORAGEFOLDER directory tree
find $STORAGEFOLDER -name .todo  -exec ls -l {} \;

display a long list of all the files in the directory "/mydir" which have not been modified in the last 20*24 hours or which have not been accessed in the last 40*24 hours
find /mydir \(-mtime +20 -o -atime +40\) -exec ls -l {} \;

display a long list of all the files that are bigger than 10KB in current folder
find . -size +10k -exec ls -l {} \;

display a long list of all the files that are bigger than 10KB in current folder and save the output to the file myLogTxt.text
find . -size +10k -type f -maxdepth 1 -exec ls -lh {} \; > myLogFile.txt

display a long list of the files in the current folder which have the word fuddel in all the files in the current folder and then search for the word fiddel in the previously matched files
find -exec grep -q fuddel {} ";" -exec grep -q fiddel {} ";" -ls

Display a long listing of all directories under '/nas' directory tree
find /nas -type d -ls

Display a long listing of all files/directories that are bigger than 10MB under '/var/' directory tree
find /var/ -size +10M -ls

display a long listing of all files in the entire file system which are bigger than 1MB
find / -size +1000k -exec ls -l {} \; -print

Display a long listing of all regular files that are less than 50 bytes in size under '/usr/bin' directory tree
find /usr/bin -type f -size -50c -exec ls -l '{}' ';'

display a long listing of all normal/regular files in a folder which have not been modified in the last 60 days and save the output to a file
find /path-to-directory -type f -mtime +60 -exec ls -l {} \; > /path-to-directory/filenames.txt

display a long listing of all regular/normal files in current directory which have been changed in the last 7 days and save the output to new.files
find ./ -type f -ctime -7 -exec ls {} \; > new.files

display a long listing of all regular files  in current folder which have been modified in the last 60 minutes
find . -mmin -60 -type f -exec ls -l {} \;

display a long listing of all regular files  in current folder which have been modified in the last 60 minutes
find . -mmin -60 -type f -ls

display a long listing of all regular files  in current folder which have been modified in the last 60 minutes
find . -mmin -60 -type f | xargs ls -l

display a long listing of all the "Trash" files in the folder /home
find /home -name Trash -exec ls -al {} \;

display a long listing of all the xls or csv files in the entire file system
find / -regex ".*\.\(xls\|csv\)"

display a long listing of all the xls or csv files in the entire file system
find / -type f \( -name "*.xls" -o -name "*.csv" \) -exec ls -l {} \;

display a long listing of all the directories in the entire file system
find / -print0 -type d | xargs -0 ls -al

display a long listing of all the empty files in the entire file system which are empty
find / -type f -size 0 -exec ls -l {} \;

display a long listing of all the java files in the current folder in sorted order
find . -type f -name '*.java' -ls | sort -k +7 -r

Display a long listing of all the files/directories under current directory tree that are newer than the file 'Nov' by modification time
find . -newer Nov -ls

display a long listing of all the files in the current directory
find . -name  * -exec ls -a {} \;

display a long listing of all the files in the current folder
find . — type f -exec ls -1 {} \;

display a long listing of all the files in the current folder in sorted order, which are bigger than 10KB
find . -size +10k -exec ls -ls {} \+ | sort -nr

dispaly a long listig of all the files in the current folder which are bigger than 100KB
find . -size +100000 -ls

display a long listing of all the files in the current folder which are bigger than 10KB
find . -size +10k -exec ls -lh {} \+

display a long listing of all the files in the current folder which have spaces in their names and save the output to the file log.txt
find . -name "filename including space" -print0 | xargs -0 ls -aldF > log.txt

dispaly a long listing of all the files in the current folder which have been modified in the last 14 days
find . -mtime -14 -ls

display a long listing of all the files in the current folder which have been modified in the last 24 hours
find . -mtime -1 -ls

display a long listing of all the files in the current folder which have been modified in the last 24 hours
find . -mtime -1 | xargs ls -ld

display a long ilsting of all the files in the file system which are bigger than 1KB and which have not been modified in the last 30*24 hours
find / -size +1000 -mtime +30  -exec ls -l {} \;

display a long listing of all the files in the home folder which are bigger than 200MB
find /home -size +200M -exec ls -sh {} \;

display a long listing of all the files that begin with the name "Metallica" in the entire file system
find / -name 'Metallica*' -exec ls -l {} \;

Display a long listing of all the regular files under current directory tree that are newer than ‘Apr 18 23:59:59 EDT 2013’ and older than ‘Apr 20 00:00:00 EDT 2013’ by modification time
find . -type f -newermt ‘Apr 18 23:59:59 EDT 2013’ ! -newermt ‘Apr 20 00:00:00 EDT 2013’ -exec ls -l ‘{}’ \;

Display a long listing of all the regular files owned by the user 'bluher' in the entire filesystem
find / -type f -user bluher -exec ls -ls {}  \;

display a long listing of all the normal/regular files in the current folder (print0 is used to handle files which have newlines in their names or files with the name only as spaces )
find . -type f -print0 | xargs -0 ls -l

display a long listing of all the regular/normal files in the current folder
find . -type f -ls

display a long listing of all the regular/normal files in the current folder along with their md5sum
find . -type f -exec sh -c 'printf "%s %s \n" "$(ls -l $1)" "$(md5sum  $1)"' '' '{}' '{}' \; | awk '{$8=""; print $0}'

display a long listing of all the regular/normal files in the current folder along with their md5sum
find . -type f -exec sh -c 'printf "%s %s \n" "$(ls -l $1)" "$(md5sum $1)"' '' '{}' '{}' \;

display a long listing of all the regular/normal files in the file system which have set uid bit or set gid bit enabled.
find / -type f \( -perm -4000 -o -perm -2000 \) -exec ls -l {} \;

Display a long listing of the files/directories with human readable sizes (100M, 10G etc..) under '/var' directory tree which are bigger than 10MB
find /var/ -size +10M -exec ls -lh {} \;

display a long listing of the files all non emoty files in current folder which have been modified 60 minutes ago
find . -mmin 60 -print0 | xargs -0r ls -l

display a long listing of the files in current folder which have been modified in the last 60 minutes
find . -mmin -60 -type f -exec ls -l {} +

display a long listing of the files in current folder which have been modified in the last 60 minutes
find . -mmin -60 |xargs ls -l

Display a long listing of the oldest file under '/hom/backups' directory tree
find /home/backups -printf "%T@ %p\n" | sort -n | head -1 | cut -d" " -f2- | xargs ls -al

Display a binary file as a sequence of hex codes
od -t x1 file|cut -c8-

Display a character dump of "oldfile"
od -c oldfile

Display a count of regular files in each directory at the current level.
find -P . -type f | rev | cut -d/ -f2- | rev | cut -d/ -f1-2 | cut -d/ -f2- | sort | uniq -c

Display a dump of "file" as floating point values of double size
od -t fD file

Display a garbled ascii-art of a cow saying "hello" backwards
cowsay "hello" | rev

display a list of all files in the folder passed as argument to a script
find $@ -ls

display a list of all regular/normal files in the current folder
find . -type f -ls

dispaly a list of all the files in the file system which belong to a specific user  and exclude searching in the folder proc
find / -path /proc -prune -o -user <account> -ls

display a list of all the files in the file system which do not belong to any group and search only in jfs and jfs2 file systems
find / -nogroup \( -fstype jfs -o -fstype jfs2 \) -ls

display a list of all the files in the file system which do not belong to any user and search only in jfs and jfs2 file systems
find / -nouser \( -fstype jfs -o -fstype jfs2 \) -ls

display a list of all the files  in the home folder which have been modified today
find ~ -type f -mtime 0 -ls

display a list of all the normal/regular files in the file system ,excluding the folder proc which have the suid or sgid bit set
find / -path /proc -prune -o -type f -perm +6000 -ls

Display a list of files with sizes in decreasing order of size of all the regular files under $dir directory tree that are bigger than $size in size
find $dir -type -f size +$size -print0 | xargs -0 ls -1hsS

Display a list of files with sizes in decreasing order of size of all the regular files under '/your/dir' directory tree that are bigger than 5 MB in size
find /your/dir -type f -size +5M -print0 | xargs -0 ls -1Ssh

Display a named character dump of "test.sh"
od -a test.sh

Display a sorted count of all the characters in "filename"
fold -w1 filename | sort | uniq -c | sort -nr

Displays a tree of all process alongside their command line arguments.
pstree -a

(Linux-specific) Display a tree-like view of USB devices, letting the user page through it with the arrow keys, with the Q key to quit.
sudo lsusb -t|less

Display all available header information for the executable file of command "tail"
objdump -x `which tail`

display all directories in a folder
find /etc -type d -print

display all directories in current folder and do not search in sub directories
find . -maxdepth 1 -mindepth 1 -type d

display all directories in current folder excluding those that are present in .git folder
find . -iregex '.*/.git/.*' -prune -o -type d -name 'CVS'

display all directories in current folder excluding those which do not have read permission to all users and save the output to a file
find . -type d ! -perm -g+r,u+r,o+r -prune -o -print > files_and_folders

display all directories in vim folder do not search in sub directories
find .vim/ -maxdepth 1 -type d

display all directories in the current folder
find -type d

display all directories in the entire file system
find / -type d -print

display all directories in the folder "$ORIG_DIR"
find "$ORIG_DIR" -name "*" -type d

display all directories in the folder "/myfiles"
find /myfiles -type d

display all directories in the folder "PROD" and do not search in the sub directories
find /PROD -maxdepth 1 -type d

display all directories in the folder Symfony
find Symfony -type d

display all directories which have not been accessed in the last 24*3 hours
find -type d -and -atime +3

display all empty files(files with sisze 0 bytes) in home folder
find ~ -empty

display all empty files in the current folder
find . -size 0k

display all text files in current folder
find . -name "*.txt"

display all text files in current folder
find . -name ".txt"

display all text files in the current folder
find . -type f -name "*.txt"

display all text files in the folder /home/you which have been modified in the last 60*24 hours(case insensitive search)
find /home/you -iname "*.txt" -mtime -60 -print

display all text files in the folder /tmp/1
find "/tmp/1" -iname "*.txt"

display all text files in the folder /tmp/1 excluding those which do not have spaces in their names
find /tmp/1 -iname '*.txt' -not -iname '[0-9A-Za-z]*.txt'

display all text files in the folder /user/directory which have been modified in today
find /user/directory/* -name "*txt" -mtime 0 -type f

display all text, mpg, jpg files  in the folder /Users/david/Desktop
find /Users/david/Desktop -type f \( -name '*.txt' -o -name '*.mpg' -o -name '*.jpg' \)

Display all files in a folder
find /usr/X11/man/man5 -print

Display all files in a folder
find man5 -print

Display all files in the current directory tree that match "*foo"
tree -P "*foo"

Display all files in the folder home which are owned by the group test.
find /home -group test

display all files ending with ".ext" in current folder and append the file contents of list.txt and sort them based on name and display only uniq items
find . -name \*.ext | cat - list.txt | sort | uniq -u

display all files in a folder
find "/proc/$pid/fd"

display all files in current directory and save the output to a file
find . > files_and_folders

display all files in current directory discard any errors and save the output to a file
find . 2>&1 | grep -v 'permission denied' > files_and_folders

display all files in current directory discard any errors and save the output to a file
find . 2>/dev/null > files_and_folders

display all files in current folder and follow the symbolic links and display the pointed file
find -L .

display all files in current folder ending with "~" or "#" using regular expression
find -regex "^.*~$\|^.*#$"

display all files in current folder excluding current folder (.)
find . \! -name '.'

display all files in current folder excluding those that have the word "git" in their name and display files that have git in their path names
find . ! -name '*git*' | grep git

display all files in current folder using regular expression
find -regex "$rx"

display all files in current folder which are bigger than 1 MB
find . -size +1M

display all files in current folder which are bigger than 100KB but are less than 500KB
find . -size +100k -a -size -500k

display all files in current folder which have not been modified in the last 60 minutes
find -mmin +60

display all files in current folder which have been modified in the last 60 minutes
find -mmin 60

display all files in current folder, with each file name displayed twice on same line
find . | xargs -I{} printf "%s%s\n" {} {}

display all files in current folder with NULL separating each file
find . -print0

displays all files in the current directory
find .

display all files in the current directory excluding those that are present in the directories whose name starts with "efence" and do not search in the sub directories
find * -maxdepth 0 -name "efence*" -prune -o -print

display all files in the current folder
find .

display all files in the current folder
find . -print

display all files in the current folder ($@ contains the variables passed as argument to the function)
find . -iname "*$@*" -or -iname ".*$@*"

display all files in the current folder and do not search in the sub directories
find . -maxdepth 0

display all files in the current folder after pruning those in the current folder ( dot is the output of this command )
find . -prune -print

display all files in the current folder expect text files
find . -name "*.txt" -prune -o -print

display all files in the current folder that have been modified in the last 24 hours whose name has only 1 letter
find . -name \? -mtime -1

display all files in the current folder which are not empty
find . ! -size 0k

display all files in the current folder which end with extension "myfile" followed by one digit or two digits
find . -\( -name "myfile[0-9][0-9]" -o -name "myfile[0-9]" \)

display all files in the current folder which end with extension "myfile" followed by one digit or two digits
find . -regextype sed -regex '.*myfile[0-9]\{1,2\}'

display all files in the current folder which do not belong to the user john
find . ! -user john

display all files in the current folder which do not match the regular expression
find . -not -regex ".*test.*"

display all files in the current folder which start with met
find -name met*

display all files in the directory "dir" which have been accessed in the last 60 minutes
find /dir -amin -60

display all files in the directory "dir" which have been changed in the last 60 minutes
find /dir -cmin -60

display all files in the entire file system
find /

display all files in the entire file system excluding the directories /proc,/sys,/dev and those files which are writable and which are not symbolic links and which are not sockets and which do not have the sticky bit set
find / -noleaf -wholename '/proc' -prune -o -wholename '/sys' -prune -o -wholename '/dev' -prune -o -perm -2 ! -type l  ! -type s ! \( -type d -perm -1000 \) -print

display all files in the entire file system excluding those that are in the transfer directory
find / -name /transfer -prune -o -print

display all files in the file system which are bigger than 50MB and having size "filename" in them
find / -size +50M -iname "filename"

display all file in the folder /dir/to/search except ".c" files
find /dir/to/search/ -not -name "*.c" -print

display all file in the folder /dir/to/search except ".c" files
find /dir/to/search/ \! -name "*.c" print

display all files in the folder /usr and its sub directory(do not search beyond the sub directory)
find /usr -maxdepth 1 -print

display all files in the folder /usr/src excluding those ending with ",v"
find /usr/src ! \( -name '*,v' -o -name '.*,v' \) '{}' \; -print

display all files in the folder bar only in the path /foo/bar/myfile (no output is generated)
find bar -path /foo/bar/myfile -print

display all files in the boot directory prepending each filename with STDERR, STDOUT accordingly
(find /boot | sed s'/^/STDOUT:/' ) 3>&1 1>&2 2>&3 | sed 's/^/STDERR:/'

display all file in the home folder except ".c" files
find $HOME -not -iname "*.c" -print

display all file in the home folder except ".c" files
find $HOME \! -iname "*.c" print

dsisplay all files inthe current folder
find .

display all file names in current folder
find . -printf '%p '

display all files which have been modified between two dates in current folder
find . -type f -newermt "2014-01-01" ! -newermt "2014-06-01"

display all non empty directories in current folder
find . \! -empty -type d

display all normal / regular files in current folder in reverse order
find . -type f | tac

display all hidden files in the current folder
find . -type f -name ".*"

display all html files  in  current folder
find -name "*.htm" -print

display all html files in current folder and replace some pattern in all these files
find -name "*.htm" | while read file; do sed "s|<title>sometext</title>|<title>${file##*/}</title>|g" -i $file; done

display all instances of the .profile file in the entire file system
find / -name .profile -print

display all instances  of the file tkConfig.sh in the folder /usr
find /usr -name tkConfig.sh

Display all lines contiaining 'funcname' in system map file matching current kernel.
cat /boot/System.map-`uname -r` | grep funcname

display all pdf files in the current folder
find . -name *.pdf

display all php,xml and phtml files in current folder
find . -name '*.php' -o -name '*.xml' -o -name '*.phtml'

display all regular/normal files in a directory
find $directory -type f

display all normal/regular files in a folder
find /home/the_peasant -type f

display all normal/regular files in a folder
find teste1 -type f

display all normal/regular files in current directory
find . -type f

display all normal/regular files in current directory
find . -type f -print0

display all normal/regular files in current  folder
find . -type f

display all normal/regular files in current folder
find . -type f

display all normal/regular files in current folder
find . -type f -print0

display all regular/normal files in current folder
find . -type f

display all normal/regular files in current folder in sorted order
find . -type f print0 | sort -r

display all regular files in current folder excluding search in the directories that are ending with "git,svn"
find . \( -type d -regex '^.*/\.\(git\|svn\)$' -prune -false \) -o -type f -print0

display all regular files in current folder which are atleast 1 level deep and search in the alphabetical order of the directories
find -ds . -mindepth 1 -type f -print0; printf '\0';

display all normal/regular files in current folder which have readable permission
find . -type f -readable

display all regular files in current folder which have spaces in their name
find -type f -name "* *"

display all regular/normal files in the current folder ending with the word ummy
find -type f -name *ummy

display all regular/normal files in the current folder that were accessed exactly 7*24 hours back
find . -type f -atime 7

display all regular/normal files in the current folder which are not accessed in the last 7*24 hours
find . -type f -atime +7

display all regular/normal files in the current folder with the name dummy
find -type f -name dummy

display all regular/normal files in the entire file system with the name dummy and discard all the errors
find / -type f -name dummy 2>/dev/null

display all regular/normal files in the folder "dir" and display the filename along with file size
find dir -type f -printf "f %s %p\n"

display all normal/regular files in the folder "pathfolder"
find pathfolder -type f

display all regular/normal files in the folder /Users/david/Desktop/
find /Users/david/Desktop/-type f

display all regular files in the folder image-folder
find image-folder/ -type f

display all regular/normal files in the folder Symfony
find Symfony -type f

display all normal/regular files or directories in the folder "$ORIG_DIR"
find "$ORIG_DIR" -name "*" -type d -o -name "*" -type f

display all regular/normal files which have been modified in the last 30 minutes
find -type f -and -mmin -30

display all scala files in the directory "src/main"
find . -path "*src/main*" -type f -iname "*\.scala*"

display all scala files in the directory "src/main"
find . -type f -path "*src/main/*\.scala"

display all scala files in the directory "src/main"
find . -type f -regex ".*src/main.*\.scala$"

display all shell scripts in current folder
find . -name "*.sh"

display all sqlite files in the current directory along with their timestamp
find ./ -name "*.sqlite" -printf '%Tc %p\n'

Display all symlinks and their targets in the current directory tree
find -P . -type l -exec echo -n "{} -> " \; -exec readlink {} \;

display all the ".c" files in the current directory
find . -name \*.c -print

display all the ".c" files in the current folder excluding those that are present in all the sub directories
find . \( ! -name . -prune \) -name "*.c" -print

display all the ".c" files in the current folder excluding those that are present in the .svn sub folder
find .  -name .svn -prune -o -name "*.c" -print

display all the ".c" files in the folder "/home/david" which have been accessed in the last 48 hours
find /home/david -atime -2 -name '*.c'

display all the ".c" files which have been modified in the last 10 minutes
find /home/david -amin -10 -name '*.c'

display all the ".mov" files in the current folder
find . -name "*.mov"

display all the ".sh" files in the current folder
find -name *.sh

display all the "C" files in the current folder
find . -name "*.c"

display all the .sh scripts and perl files in the current folder
find . -type f \( -iname "*.sh" -or -iname "*.pl" \)

display all the .sh scripts and perl files in the current folder
find . -type f \( -name "*.[sS][hH]" -o -name "*.[pP][lL]" \)

display all the .sh scripts in the folder /usr
find /usr -name '*.sh'

display all the .sh scripts in the folder /usr
find /usr -name \*.sh

display all the log files in the folder /var/log, print0 is used to handle files with only spaces in their names or which have newlines in their names and discard all the errors
find /var/log -name "*.log" -print0 2>/dev/null

display all the C, CPP, Header files in the kat folder
find kat -type f \( -name "*.c" -o -name "*.cpp" -o -name "*.h" \)

display all the c files and the header files in the path /some/dir and do not search in sub directories
find /some/dir -maxdepth 1 \( -name '*.c' -o -name '*.h' \) -print

display all the C files or Python files in the folder "euler"
find euler/ -iname "*.c*" -exec echo {} \; -or -iname "*.py" -exec echo {} \;

display all the configuration files in the current folder which are in the current tree structure
find .  -path '*/*config'

display all the configuration files in the etc folder
find /etc -name '*.conf'

display all the directories in specific path ( saved in $x ) excluding those that are present in a path and save the ouput to a file
find $x -type d -wholename '*' ! -wholename */@eaDir* > /tmp/mediaindex/$nn.dir

display all the directories in the current folder for the files which have not been accessed in the last 48 hours
find . -type d -atime +2

display all the directories in the current folder excluding those that are present in the .svn directory tree
find -type d -path '.svn' -prune -o -print

display all the directories in the current folder excluding those that are present in the aa directory tree
find . -type d -name aa -prune

display all the directories in the current folder excluding those that are present in the aa directory tree
find . -type d -name aa -prune -o -print

display all the directories in the current folder excluding those that are present in the folder secret
find . -name secret -type d -prune -o -print

display all the directories in the current folder which are atleast one level deep
find . -mindepth 1 -type d -print0

display all the directories in the current folder which start with processor followed by digit and ends with .1 or .2
find . -type d -regextype posix-egrep -regex '\./processor[0-9]*/10\.(1|2)'

display all the directories in the current folder which start with processor followed by digit and ends with .1 or .2
find . -type d -regextype posix-egrep -regex '\./processor[[:digit:]]*/10\.(1|2)'

display all the directories in the folder /path/to/dest except tmp directory
find /path/to/dest -type d \( ! -name tmp \) -print

display all the directories in the folder master-
find master -type d | sort

display all the empty files in the current folder( files of size 0 bytes)
find . -empty

display all the empty files in the entire file system
find / -size 0 -print

display all the empty files in the folder /opt (file size 0 bytes)
find /opt -type f -empty

dispaly all the empty regular/normal files in the current folder
find . -type f -empty

display all the java, xml and action scripts (.as) files in a directory
find dir1 -type f -a \( -name "*.java" -o -name "*.as" -o -name "*.xml" \)

display all the java script files in a folder
find src/js -name '*.js'

display all the java script files in the current folder
find . -name "*.js"

display all the text and pdf files in the current folder
find . -regex ".*\(\.txt\|\.pdf\)$"

display all the text files and hidden files in the home folder
find ~ -name "*.txt" — print -o -name ".*" — print

display all the text files and pdf files in the current folder
find . \( -name "*.txt" -o -name "*.pdf" \)

display all the text files from the current folder and skip searching in skipdir1 and skipdir2 folders
find . \( -name skipdir1 -prune , -name skipdir2 -prune -o -name "*.txt" \) -print

display all the text files in a folder
find $1 -type f -name '*'$n'.txt'

display all the text files in current folder
find . -name "*.txt"

display all the text files in current folder
find . -name "*.txt" -printf "%f\n"

display all the text files in current folder and save the output to a file
find . -name "*.txt" -printf "%f\n" > /tmp/a

display all the text files  in the current folder
find . -name "*.txt" -print

display all the text files in the current folder
find -name “*.txt”

display all the text files in the current folder  and do not search in the bin directory
find . -name bin -prune -o -name "*.txt" -print

display all the text files in the current folder except readme files
find . -type f -name "*.txt" ! -name README.txt -print

display all the text files in the current folder which have been modified in the last half minute ( 30 seconds )
find . -mmin 0.5

display all the text files in the home folder
find /home -name "*.txt"

display all the text files in the home folder ( case insensitive search )
find /home -iname "*.txt"

Display all the files/directories under '/home/bozo/projects' directory tree that have been modified within the last day
find /home/bozo/projects -mtime -1

display all the files ending with ".foo" including those that are in the directory ".snapshot", this is the wrong way of using prune.
find . \( -name .snapshot -prune -o -name '*.foo' \) -print

display all the files ending with ".user" in /var/adm/logs/morelogs/ and excluding all regular files
find /var/adm/logs/morelogs/* -type f -prune -name "*.user" -print

display all the files ending with .c in the current folder
find . -name \*.c -print0

display all the files having spaces in the current folder
find . -name "filename including space"

display all the files having spaces in the current folder
find . -name "filename including space" -print0

display all the files having the word "searched phrasse" in their name in the current folder excluding those from the paths "/tmp/" and "./var/log"
find . -type f -name "*searched phrasse*" ! -path "./tmp/*" ! -path "./var/log/*"

display all the files in current folder
find .

display all the files in current folder which have not been modified in the last 7 days
find . -mtime +7

display all the files in current folder which have write permission to all the users
find . -perm /222

display all the files in current folder which have been accessed in the last 15 days
find . -atime -15

display all the files in current folder which have been changed in the last 2-6 days
find . -cmin +2 -cmin -6

display all the files in current folder which have been changed in the last 24 hours
find . -ctime -1 -print

display all the files in current folder which start with "file2015-0"
find . -name "file2015-0*"

display all the files in the kat folder
find kat -printf "%f\n"

display all the files in the current directory and do not search in sub directories
find . -maxdepth 1 -print0

display all the files in the current directory and do not search in the sub directories
find . -maxdepth 0 -print

display all the files in the current directory excluding the paths "targert", "tools", "git"
find . \( ! -path "*target*" -a ! -path "*tools*" -a ! -path "*.git*" -print \)

display all the files in the current directory excluding those that are in the 'secret' directory
find . -name 'secret' -prune -o -print

display all the files in the current folder
find .

display all the files in the current folder
find . -print

display all the files in the current folder
find . | xargs echo

display all the files in the current folder
find ./

display all the files in the current folder.
find .

displays all the files in the current folder
find .

display all the files in the current folder and do not search in sub directories and move them to the directory /directory1/directory2.
find . -maxdepth 1 -type f | xargs -I ‘{}’ sudo mv {} /directory1/directory2

display all the files in the current folder and traverse from the sub directories
find . -type d -depth

display all the files in the current folder along with the change time and display file names of the last 10 changed files
find . -type f -printf "%C@ %p\n" | sort -rn | head -n 10

display all the files in the current folder along with the hidden files with the depth
find . — name "*" — print -о -name ".*" — print -depth

display all the files in the current folder along with the modification time and display file names of the last 10 modified files
find . -type f -printf '%T@ %p\n' | sort -n | tail -10 | cut -f2- -d" "

display all the files in the current folder along with their timestamps and sort them and save them in the file1
find -printf '%p %T@\n' | sort > file1

display all the files in the current folder expect perl shell and python fiels
find . -not -name "*.pl" -not -name "*.sh" -not -name "*.py"

display all the files in the current folder for the files which have not been accessed in the last 24 hours
find . -type f -atime +1

display all the files in the current folder for the files which have been accessed in the last 24 hours
find . -type f -atime -1

display all the files in the current folder excluding search in the paths containing the folder having the word "mmm"
find . ! -path *mmm*

display all the files  in the current folder excluding the current folder and do not search in the sub directories
find . -maxdepth 1 -type d \( ! -name . \)

display all the files  in the current folder excluding the perl files
find . -not -name "*.pl"

display all the files in the current folder excluding those ending with ".disabled" in sorted order
find /target/ | grep -v '\.disabled$' | sort

display all the files in the current folder excluding those that are present in the folder "secret"
find . \( -name 'secret' -a -prune \) -o -print

display all the files in the current folder excluding those that are present in the sub directory aa and display those files that start with the word "file"
find . \( -type d -name aa -prune \) -o \( -type f -name 'file*' -print \)

display all the files in the current folder excluding those that are present in the path "./etc"
find . ! -wholename "./etc*"

display all the files in the current folder excluding those which are in the path of ".git"
find . ! -path  "*.git*" -type f -print

display all the files  in the current folder excluding those which are present in "./src/emacs" folder
find  .  -path  './src/emacs'  -prune  -o -print

display all the files in the current folder that have been modified in the last 24 hours
find  -mtime -1

display all the files in the current folder that end with ".ksh"
find . -name "*.ksh" -prune

display all the files in the current folder which are bigger than 100MB and save the output list to the file /root/big.txt
find \( -size +100M -fprintf /root/big.txt %-10s %p\n \)

display all the files in the current folder which are in the path "./sr*sc"
find . -path './sr*sc'

display all the files in the current folder which are in the path ending with the folder f
find .  -path '*f'

display all the files in the current folder which are present in the path "./sr*sc"
find . -path './sr*sc'

display all the files in the current folder which are present in the path "./src/emacs"
find . -path './src/emacs' -prune -o -print

display all the files in the current folder which have are bigger than 1KB
find . -size +1024 -print

display all the files  in the current folder which have colon in their name
find . -name "*:*"

display all the files in the current folder which have not been modified in the last 7 days and which are not in the list "file.lst"
find -mtime +7 -print | grep -Fxvf file.lst

display all the files in the current folder which have not been modified in the last 7 days and which are not in the list "file.lst" and save the output to a file
find -mtime +7 -print | grep -vf file.lst > found.lst

display all the files in the current folder which have the permissions 777 and which have been modified in the last 24 hours.
find . -perm 777  -mtime 0 -print

display all the files in the current folder which have the permissions 777 and which have been modified in the last 24 hours.
find . -perm 777 -a -mtime 0 -a -print

display all the files in the current folder which have the word "bills" in their name
find . -name '*bills*' -print

display all the files in the current folder which have been accessed in the last 60 minutes
find . -amin -60

display all the files in the current folder which have been modified after the files "/bin/sh"
find . -newer /bin/sh

display all the files in the current folder which have been modified in one hour ago
find .  -newermt "1 hour ago"

display all the files in the current folder which have been modified in the last 14*24 hours
find . -mtime -14 -print

display all the files in the current folder which have been modified in the last 2 days
find . -mtime -2

display all the files in the current folder which have been modified in the last 24 hours excluding all directories
find . \( -type d ! -name . -prune \) -o \( -mtime -1 -print \)

display all the files in the current folder which have been modified in the last 5*24 hours
find . -mtime -5

display all the files in the current folder which contains form feed (^L) and does not contain NULL
find . | xargs grep -PL "\x00" | xargs grep -Pl "\x0c"

display all the files in the current folder which do not belong to any group
find . -nogroup

display all the files in the current folder which do not belong to any user
find . -nouser

display all the files in the current folder which start with either "fileA_" or "fileB_"
find . -name 'fileA_*' -o -name 'fileB_*'

display all the files in the directory modules
find . -name modules

display all the files in the entire file system
find / -name "*" — print

display all the files in the entire file system
find / -type f -exec echo {} \;

display all the files in the entire file system which are bigger than 10MB
find / -size +10000k

display all the files in the entire file system which begin with "apache-tomcat"
find / -name "apache-tomcat*"

display all the files in the file system excluding all the ".c" files
find / \! -name "*.c" -print

display all the files in the file system which are present in nfs system
find / -fstype nfs -print

display all the files in the file system which have been modified in the last 10 minutes
find / -mmin -10

display all the files in the file system which belong to no user
find / -nouser -print

display all the files in the file system which belong to the user "wnj" and which are modified after the file "ttt"
find / -newer ttt -user wnj -print

display all the files in the file system which belong to the user "wnj" or which are modified after the file "ttt"
find / \( -newer ttt -or -user wnj \) -print

display all the files in the file system which belong to the user with the id 1005
find / -uid 1005

display all the files in the file system which do not belong to the user "wnj" and which are modified before the file "ttt"
find / \! \( -newer ttt -user wnj \) -print

display all the files in the folder "$ORIG_DIR"
find "$ORIG_DIR"

display all the files in the folder "/Users/Me/Desktop" which belong to the user "popo" and which have the permission 777
find /Users/Me/Desktop -user popo -perm 777

display all the files in the folders /etc /srv excluding the paths /etc/mtab and  /srv/tftp/pxelinux.cfg
find /etc /srv \( -path /srv/tftp/pxelinux.cfg -o -path /etc/mtab \)  -prune -o -print

display all the files in the folder /etc /srv excluding those that are present in the path of ./srv/tftp/pxelinux.cfg* and /etc/mtab
find /etc /srv \! -path "./srv/tftp/pxelinux.cfg*" -a \! -name /etc/mtab

display all the files in the folder /home which have the setuid bit enabled
find /home -perm /u=s

display all the files in the folder /home which do not belong to the group test
find /home ! -group test

display all the files in the folder /home which do not belong to the group test
find /home -not -group test

display all the file in the folder /home/david/ which start with the word "index"
find /home/david -name 'index*'

display all the file in the folder /home/david/ which start with the word "index" ( case insensitive search)
find /home/david -iname 'index*'

display all the files in the folder /mp3-collection which are bigger than 10MB or which start with the name "Metallica"
find /mp3-collection -name 'Metallica*' -or -size +10000k

display all the files in the folder a
find a

display all the files in the home folder
find $HOME -print

display all the files in the home folder excluding directories which have been modified in the last 24 hours
find /home/ -mtime -1 \! -type d

display all the files in the home folder that have been modified in the last 24 hours
find $HOME -mtime -1

display all the files in the home folder which are smaller than 500 bytes
find $HOME -size -500b

display all the files in the home folder which are smaller than 500 bytes
find ~ -size -500b

display all the files in the home folder which have not been modified in the last 365*24 hours
find $HOME -mtime +365

display all the files in the home folder which begin with "arrow"
find ~ -name 'arrow*'

display all the files in the home folder which begin with "arrow" and end with "xbm"
find ~ -name 'arrow*.xbm'

display all the files in the usr folder and those that are in the path local
find /usr/ -path "*local*"

display all the files in the usr folder which have been modified after Feburary 1st
find /usr -newermt "Feb 1"

display all the files in the user folder which have been modified after the files /tmp/stamp$$
find /usr -newer /tmp/stamp$$

display all the files on the current folder excluding those that are present in the folder "./src/emacs"
find . -path ./src/emacs -prune -o -print

display all the files only in the path "./sr*sc"
find . -path "./sr*sc"

display all the files with the names "name1" and "name2" in the current folder and do not search in the sub directories
find . -maxdepth 1 -name "name1" -o -name "name2"

display all the tex files in the current folder
find . -name "*.tex"

display all the tex files in the current folder
find . -name \*.tex

display all the header files  and cpp files in the current folder
find . -name \*.h -print -o -name \*.cpp -print

display all the header files  and cpp files in the current folder
find . -regex '.*\.\(cpp\|h\)'

display all the header files  and cpp files in the current folder
find \( -name '*.cpp' -o -name '*.h' \) -print

display all the hidden directories in the directory "/dir/to/search/"
find /dir/to/search -path '*/.*' -print

display all the hidden files in the folder /home
find /home -name ".*"

display all the html files in the current folder
find . -name "*.html" -print

display all the html files in the current folder
find . -name \*.html

display all the html files in the current folder excluding search in the path ./foo
find . -path "./foo" -prune -o -type f -name "*.html"

display all the html files in the current folder that have not been modified in the last 7*24 horus
find . -mtime +7 -name "*.html" -print

display all the html files in the current folder that have been modified exactly 7*24 hours ago
find . -mtime 7 -name "*.html" -print

display all the html files in the current folder that have been modified in the last 7*24 hours
find . -mtime -7 -name "*.html" -print

display all the html files in the folder /var/www
find /var/www -type f -name "*.html"

display all the ip addresses in all the files that are present in /etc folder
find /etc -exec grep '[0-9][0-9]*[.][0-9][0-9]*[.][0-9][0-9]*[.][0-9][0-9]*' {} \;

display all the ip addresses in all the files that are present in /etc folder
find /etc -type f -exec cat '{}' \; | tr -c '.[:digit:]' '\n' | grep '^[^.][^.]*\.[^.][^.]*\.[^.][^.]*\.[^.][^.]*$'

display all the jpg files in the current folder and do not search in sub directories
find . -maxdepth 1 -mindepth 1 -iname '*.jpg' -type f

display all the jpg files in the current folder which belong to the user nobody
find . -name *.jpg -user nobody

display all the jpg images in current folder
find . -type f -iregex '.*\.jpe?g'

display all the soft links in a  folder which are not broken
find -L /target ! -type l

display all the home folder which end with the extension "sxw" and which have been accessed in the last 3*24 hours and which belong to the user bruno
find /home -type f -name "*.sxw" -atime -3 -user bruno

display all the pdf files in a folder which start with a specific word along with their timestamp in sorted order of time and save output to a in remote server
find "/path/to/pdfs/" -type f -name "$1*.pdf" -printf "%TY/%Tm/%Td %TH:%TM %p\n"      | sort -n -k1.1,1.2 -k1.3,1.4 -k1.6,1.7 -k1.9,1.10 -k2.1,2.2 -k2.4,2.5 -k3  > remoteuser@remoteserver:/u/tmp/CustTmp/zzz_pdfs.txt

display all the php files in the current folder which do not have the permission 644
find . -type f -name "*.php" ! -perm 644

display all the php files in the entire file system
find / -name "*.php"

display all the regular/normal files ending with ".mod" in a folder
find "$dir" -name "*.mod" -type f -print0

display all the regular/normal files in a folder and save errors to a log file
find ./subdirectory -type f 2>>error.log

display all the regular/normal files in current directory
find -type f -printf '"%p"

display all the regular/normal files in current directory
find . -type f

display all the regular files in current folder
find . -type f

display all the regular/normal files in current folder
find . -type f -name \*

display all the regular/normal files in current folder
find . -type f -print0

display all the regular files in current folder that belong to the user "tom"
find . -type f -user tom

display all the regular/normal files in the /root folder which are bigger than 500MB
find /root -type f -size +500M -printf "The %p file is greater than 500MB\n"

display all the regular/normal files in the current directory
find . -type f

display all the regular/normal files in the current directory which are atleast 2 levels deep
find . -mindepth 2 -type f

display all the normal/regular files in the current folder
find . -type f

display all the regular files in the current folder and do not search in sub folders
find "$dir" -maxdepth 1 -type f

display all the normal/regular files in the current folder and do not go beyond 3 levels
find . -maxdepth 3 -type f

display all the regular/normal files in the current folder excluding the files "bbb" and "yyy"
find . \( -name bbb -o -name yyy \) -prune -o -type f -print

display all the regular/normal files in the current folder excluding the files with the name mmm
find . -name mmm -prune -o -type f -print

display all the regular files in the current folder excluding those that are present in the path "git"
find . -path "*.git" -prune -o -type f -print

display all the regular files in the current folder excluding those that are present in the path "git"
find . -path "*.git*" -prune -o -type f -print

display all the regular files in the current folder that are bigger than 10KB
find . -type f -size +10k

display all the regular files in the current folder that are exactly 10KB
find . -type f -size 10k

display all the regular files in the current folder that are less than 10KB
find . -type f -size -10k

display all the regular/normal files in the current folder that are not accessed in the last 10 minutes
find . -type f -amin +10

display all the normal/regular files in the current folder which are empty
find . -type f -empty

display all the regular/normal files in the current folder which are modified after a file
find . -type f -newer "$FILE"

display all the regular files in the current folder which have the permission 777
find . -type f -perm 777

display all the regular/normal files in the current folder which have been modified after a specific time stamp and do not search in the sub directories
find -maxdepth 1 -type f newermt "$timestamp"'

display all the regular/normal files in the current folder which have been modified in the last 24 hours
find . -mtime 0 -type f

display all the regular files in the current folder which dont not have the permission 777
find . -type f ! -perm 777

display all the normal/regular files in the directory FOLDER1
find FOLDER1 -type f -print0

display all the regular/normal files in the entire file system
find / -type f -exec echo {} \;

display all the regular files in the folder "$(FOLDER)" which are modified in the last $(RETENTION)*24 hours and excluding hidden files
find ${FOLDER} -type f ! -name \".*\" -mtime -${RETENTION}

display all the regular/normal files in the home folder that have been modified in the last 1 day (from the start of day ie, from 00:00 )
find ~/ -daystart -type f -mtime 1

display all the regular/ normal files in a folder
find src/js -type f

display all the statistics of the files in the current folder and discard the errors
find . -type f -exec stat {} \; > /dev/null

display all the statistics of the files in the current folder and discard the errors. ( + symbol at the end is used to give stat bulk input than a single file )
find . -type f -exec stat {} + > /dev/null

display all the symbolic links in the current folder
find . -type l

display all the symbolic links in the current folder
find ./ -type l

display all the users in the current folder that belong to the group "sunk"
find . -type f -group sunk

display all the users in the current folder which do not belong to the user root
find . ! -user root

display all the trace files (".trc") from the folder $DBA/$ORACLE_SID/bdump/ which have not been accessed in the last 7*24 hours
find $DBA/$ORACLE_SID/bdump/*.trc -mtime +7

display all the jars in the current folder
find . -iname '*.jar'

display long list of all the files in the folder /home/peter which belong to no user and change the owner,group of all these files (after user confirmation) to "peter","peter"
find /home/peter -nouser -exec ls -l {} \; -ok chown peter.peter {} \;

display long list of all the perl files in the current folder
find . -name "*.pl" -ls

display long listing of all normal/regular files in the current directory which have been modified in the last 2 days.
find . -mtime -2 -type f -name "t*" -exec ls -l '{}' \;

display long listing of all regular/normal files whose size is less than 50 bytes.
find /usr/bin -type f -size -50c -exec ls -l '{}' ';'

display long listing of all the empty files in the current folder
find . -empty -exec ls -l {} \;

display long listing of all the text files in the current folder
find . -name "*.txt" -exec ls -la {} \;

display long listing of all the text files in the current folder (plus at the end executes quickly by sending bulk data as input to the command in exec)
find . -name "*.txt" -exec ls -la {} +

display long listing of all the text files in the current folder and then execute the script myScript.sh by passing the output of previous exec as input
find . -name "*.txt" -exec ls -la {} \; -exec ./myScript.sh {} \;

Display long listing of all the files/directories owned by the user 'me' under '/tmp' directory tree
find /tmp -user me -ls

display long listing of all the files in the folder "/myfiles"
find /myfiles -exec ls -l {} ;

display long listing of all the files in the root folder which are bigger than 3KB
find / -dev -size +3000 -exec ls -l {} ;

display long listing of all the files that have been changed in the last 4 days, daystart is used to compare from the starting of day i.e, at 00:00
find . -daystart -ctime 4 -ls -type f

display long listing of all the regular hidden files in the folder Musica
find Música/* -type f -name ".*" -exec ls -l {} \;

display long listing of all the symbolic links in the current folder
find . -type l -exec ls -l {} \;

display long listing of first 10 directories in the current folder
find . -type d -ls | head

display long listing of top ten biggest regular/normal files in the folder /usr/share/man (discard errors during search)
find /usr/share/man/ -type f -exec ls -S {} + 2>/dev/null | head

Displays calendar for a previous, current and next month.
cal -3

(Linux specific) Display current running kernel's compile-time config file.
cat /boot/config-`uname -r`

Display current system's kernel name, kernel release and version, and machine architecture
uname -srvm

Displays details about package 'zsh'.
yum info zsh

Display differences between /destination/dir/1 and /destination/dir/2 excluding files that match any pattern in file "exclude.pats".
diff /destination/dir/1 /destination/dir/2 -r -X exclude.pats

Display differences between /destination/dir/1 and /destination/dir/2 excluding files with names ending with extensions '.foo', '.bar' and '.baz'
diff -x '*.foo' -x '*.bar' -x '*.baz' /destination/dir/1 /destination/dir/2

Display differences between /destination/dir/1 and /destination/dir/2 excluding XML files.
diff /destination/dir/1 /destination/dir/2 -r -x *.xml

Display differences between /tmp/test1 and /tmp/test2.
diff /tmp/test1  /tmp/test2

Display differences between /tmp/test1 and /tmp/test2 side-by-side.
diff -y /tmp/test1  /tmp/test2

Display differences between directories dir1 and dir2.
diff -r dir1 dir2

Display differences between directories dir1 and dir2.
diff -r dir1/ dir2/

Display differences between directories dir1 and dir2, treating absent files as empty.
diff -Naur dir1/ dir2/

Display differences between directories repos1 and repos2, ignoring changes due to tab expansion, white spaces and treating absent files as empty.
diff -ENwbur repos1/ repos2/

Display differences between files "a.txt" and "b.txt" side-by-side and do not output common lines.
diff -a --suppress-common-lines -y a.txt b.txt

Display differences between files dir1.txt and dir2.txt.
diff dir1.txt dir2.txt

Display differences between file1 and file2 side-by-side.
diff -y file1 file2

Display differences between list of files in /bin and /usr/bin.
diff <(ls /bin) <(ls /usr/bin)

Display difference between one.txt and two.txt side-by-side.
diff -y one.txt two.txt

Display differences between output of two programs, 'a' and 'b', residing in the current working directory.
diff <(./a) <(./b)

display files ending with ".ext" in current folder excluding those that are present in the list list.txt
find -type f -name '*.ext' | grep -vFf list.txt

display files ending with ".ext" in current folder excluding those that are present in the list list.txt
find . -type f -name "*.ext" $(printf "! -name %s " $(cat list.txt))

display files ending with ".ext" in current folder excluding those that are present in the list list.txt
find . -type f -name "*.ext" -exec grep -v "^{}$" list.txt && echo {} \;

display files in current folder ending with "pdf" or "PDF"
find . -name '*.pdf' -or -name '*.PDF'

(Linux-specific) Display all lines containing UTRACE in the current kernel's compile-time config file.
grep UTRACE /boot/config-$(uname -r)

Display hardware platform, ie. x86_64 even if current kernel uses 32-bit addressing.
uname -i

Displays Homebrew’s install path.
brew --prefix

Display hostname.
uname -n

Display human-readable file type description of ascii.txt
file ascii.txt

Display human-readable file type description of utf8.txt
file utf8.txt

display in a list of all the files that are bigger than 10KB in current folder
find . -size +10k -ls

Display in an optimized way file status for all regular files in the current directory tree suppressing error messages
time find . -type f -exec stat {} + > /dev/null

Display infinite scroll of random ASCII art
yes 'c=(╱ ╲);printf ${c[RANDOM%2]}'|bash

Display infinite scroll of random ASCII art
yes 'printf \\u$[2571+RANDOM%2]'|bash

Displays info about users currently in system.
\w

(GNU specific) Display info on most CPU-intensive processes once and exit.
top -n 1

Displays information about all network interfaces in system, including inactive ones.
ifconfig -a

(GNU specific) Display information about number of processes in various states.
top -bn1 | grep zombie

Displays information about grc formula.
brew info grc

Display IP address and login time of the current user's session
last -i | grep $(whoami) | grep 'still logged in'

Display who is logged on and what they are doing
w

Display kernel name, release, and version.
uname -s -r -v

display list of all the C files ( fuiles with ".c" extension ) in current folder
find . -name '*.c' -ls

display list of all the files in the /tmp folder
find /tmp/ -exec ls "{}" +

display list of all the files in the current directory
find | xargs ls

display list of all the files in the current directory (print0 handles file names with newlines or spaces)
find -print0 | xargs -0 ls

display list of all the files in the current folder which are empty.
find . -size 0 -ls

display list of all the hidden directories in the directory "/dir/to/search/"
find /dir/to/search -path '*/.*' -ls

display list of all the hidden directories in the directory "/dir/to/search/"
find /dir/to/search/ -type d -iname ".*" -ls

display list of all the hidden files in the directory "/dir/to/search/"
find /dir/to/search/ -name ".*" -ls

display list of all the hidden files in the folder $HOME/projects/ and save the output to the file foo.txt
find $HOME/projects/ -name ".*" -ls > foo.txt

display list of all the hidden files in the home folder
find $HOME -name ".*" -ls

display list of all the hidden regular/normal files in the directory "/dir/to/search/"
find /dir/to/search/ -type f -iname ".*" -ls

display list of all the regular/normal files in the home folder which are exactly 6579 bytes
find /home/ -type f -size 6579c -exec ls {} \;

Display list of files ending with '.txt' in the current folder to the terminal twice and output it to the text file "txtlist.txt"
ls *.txt | tee /dev/tty txtlist.txt

Displays line count in 'filename' every 2 seconds.
watch wc -l <filename>

Display total apparent size of a file
du -sb

Display machine architecture, ie. x86_64
uname -m

Display mimetype of myfile.txt.
file --mime myfile.txt

Display name and value of 'variable' if it exists.
env | grep '^variable='

Display non-hidden files in the current directory with the given output format
find . -maxdepth 1 -name '[!.]*' -printf 'Name: %16f Size: %6s\n'

Display only first and second dot-separated numbers of kernel version, ie. 4.4
uname -r | cut -d. -f1-2

Display only mimetype of myfile.txt, without the filename.
file -bi myfile.txt

display only the file names of all the files which end with ".deb"
find . -name '*.deb' -printf "%f\n"

Display operating system type, ie. GNU/Linux
uname -o

Display permissions, user, group, and full path for each file in the current directory tree
tree -p -u -g -f

Display permissions, user, group, and full path for each file in the current directory tree as a list
tree -p -u -g -f -i

display top 11 files along with the last access date for all the files in the file system
find / -type f -printf "\n%AD %AT %p" | head -n 11

Display PHP info one page at a time, pausing for user interaction after each page.
php -i | more

(BSD specific) Display process information twice, waiting one second between each, filtering out the header line.
top -b -d2 -s1 | sed -e '1,/USERNAME/d' | sed -e '1,/^$/d'

(GNU specific) Display process information (batch mode, display once) with full command lines.
top -b -n1 -c

Displays process tree of 'pppd' process.
pstree -p `pgrep pppd`

Displays process tree of a process with id 'PID', showing parent process and processes id.
pstree -p -s PID

Display file type description of 'file-name' based on contents.
file file-name

Display file type information for all instances of "file" in the current PATH.
which file | xargs file

Display mime type of file specified by variable "file"
file -ib "$file"

Display file status for all regular files in the current directory tree
find . -type f -exec stat {} + > /dev/null

Display file status for all regular files in the current directory tree suppressing error messages
find . -type f -exec stat {} \; > /dev/null

Display file status for each regular file in the current directory tree
find . -type f -exec stat {} \; > /dev/null

Display smbios/DMI information, pausing for user interaction between pages of output.
dmidecode | more

Display standard input as octal bytes
cat | od -b

Display summary of each specified file in human readable form
du --summary --human-readable *

Display summary of each specified file in human readable form
du -sh *

Display system information: kernel name, hostname, kernel release and version, machine architecture, processor type, hardware platform, and operating system type.
uname -a

display table of files with their name, owner, and size in bytes.
find . -printf 'Name: %f Owner: %u %s bytes\n'

Display the 5 largest files in the current directory and its sub-directories.
find . -type f -exec ls -s {} \; | sort -n -r | head -5

Display the 5 smallest files in the current directory and its sub-directories.
find . -type f -exec ls -s {} \; | sort -n  | head -5

Display the 5 smallest files in the current directory and its sub-directories ignoring any empty files.
find . -not -empty -type f -exec ls -s {} \; | sort -n  | head -5

display the long listing detials of all the files in the folder junk which is in home folder.
find ~/junk   -name "*" -exec ls -l {} \;

display the long listing of all files in /var/log which were modified 60 days or more ago.
find /var/log/ -mtime +60 -type f -exec ls -l {} \;

Display the biggest file sizes only
find -type f -exec du -Sh {} + | sort -rh | head -n 5

display the commands to force delete all jpg files in current directory which are less than 50KB and do not search in the sub directories
find . -maxdepth 1 -name "*.jpg" -size -50k | xargs echo rm -f

Display the contents of "file" formatted into a table, removing duplicate lines where the first 12 characters are duplicates, and display the number of occurrences at the beginning of each line.
column -t file | uniq -w12 -c

Display the contents of "myfile" located in the current directory.
cat myfile

Display the contents of "text"
cat text

display the contents of all java script files in a folder and save the output to a file
find src/js -type f -name "*.js" -exec cat {} >> ${jsbuild}$@ \;

display the contents of all the text files in the current directory
find . -name  '*.txt' -exec cat {} \;

display the contents of all the text files in the current folder and save the output to all.txt.
find . -type f -name "*.txt" -exec cat {} \;> all.txt

display the contents of all the files ending with ".fq" and perform a control check on this raw sequence of data and display the output to the screen
find . -name "*.fq"  -exec cat '{}' ';' | fastqc  /dev/stdin

display the contents of all the files in the current folder which have the name "dummy" and discard all the errors while searching
find / -type f -name dummy 2>/dev/null -exec cat {} \;

display the contents of all the files in the current folder which start with test ( case insensitive search )
find . -iname '*test*' -exec cat {} \;

display the contents of all the files in the current folder which start with test (case insensitive search)
find . -iname '*test*' -exec cat {} \;

display the content of all the instances of the file "lilo.conf" in the file system and discard any errors in encountered during the search and display) and save the output to the file "lilo.txt"
find / -type f -name lilo.conf 2>/dev/null -exec cat {} \; >lilo.txt

display the contents of  all the regular files in a folder in the sorted order of their depth
cat $(find src/js -type f -name "*.js" -printf "%d\t%p\n" | sort -n | sed -e "s|[0-9]*\t||")>min.js

display the contents of all the regular files in the current folder and save the output to out.txt
cat `find . -type f` > out.txt

display the contents of all the regular files in the current folder and save the output to out.txt
find . -type f -exec cat {} \; > out.txt

display the contents of all the regular files in the current folder and save the output to out.txt
find . -type f -print0 | xargs -0 cat > out.txt

display the contents of all the regular files in the current folder and save the output to out.txt
find . -type f | xargs cat > out.txt

display the contents of all the regular/normal files in the entire file system with the name dummy and discard all the errors
find / -type f -name dummy 2>/dev/null -exec cat {} \;

Display the content of file "f" in home directory if it exists and is executable
cat `which ~/f`

display the content of the files in the file system with the name "lilo.conf" and save the output to the file lilo.txt
find / -type f -name lilo.conf 2>/dev/null -exec cat {} \; >lilo.txt

display the count of all directories in a folder excluding hidden files
find /path/to/directory -type d \! -name . -prune -exec printf x \; | wc -c

display the count of all normal/regular files in current directory
find . -type f | wc -l

display the count of all the directories in the current folder
find . -type d –print | wc -l

display the count of all the directories present in a folder
find /mount/point -type d | wc -l

display the count of all the normal/ regular files in the current directory
find . -type f |wc -l

display the count of number html files in the current folder
find . -name "*.html" -print | xargs -l -i wc {}

display the count of number of files in the current folder
find | wc -l

Displays the count of of each unique line read from standard input
sort | uniq -c

Display the count of regular files for which the owner has read and execute permission under 'home/magie/d2' directory tree
find home/magie/d2 -type f -perm -u+rx | wc -l

Display the count of regular files under 'home/magie/d2' directory tree which have execute permission to all the users
find home/magie/d2 -type f -perm +111 | wc -l

display the count of regular/normal files in the current folder do not search in sub directories
find . -maxdepth 1 -type f |wc -l

display the count of regular/normal files in the folder "/path/to/dir"
find /path/to/dir -type f -exec printf %.sX {} + | wc -c

display the count of total number of empty files in the current folder
find . -type f -empty | wc -l

display the count of total number of text files in the folder /home/you which have been modified in the last 60*24 hours
find /home/you -iname "*.txt" -mtime -60 | wc -l

display the count of total number of non empty files in the current folder
find . -type f -not -empty | wc -l

display the directory name along with the modified time  for all the files /var
find /var -maxdepth 2 -type d -printf "%p %TY-%Tm-%Td %TH:%TM:%TS %Tz\n"

display the directory name along with the modified time for all the files /var
find /var -maxdepth 2 -type d -exec stat  -c "%n %y" {} \;

display the base name(name without extension) of all the ".flac" files in the current folder
find . -name "*.flac" -exec basename \{\} .flac \;

Display the files/directories under current directory tree matching the regex '/$prefix$ypatt' where $prefix and $ypatt expands in the current shell
find . -print | grep "/${prefix}${ypatt}"

display the files along with the size of all the files in the current which are bigger than 100MB
find . -size +100M -exec ls -s {} \;

display the files modified between last 18 to 24 months in the format filename, file size, Last access date, modification date and save the output to the file /dir/dir/output.csv
find /dir/dir -type f -mtime +540 -mtime -720 -printf \”%p\”,\”%s\”,\”%AD\”,|”%TD\”\\n > /dir/dir/output.csv

display the filenames which do not have begin with dot (.)
find . -maxdepth 1 -name '[!.]*' -printf 'Name: %16f Size: %6s\n'

Display the first 32 bytes in "foo" as printable characters with 16 characters per line
od -c foo |head -2

Display what flags mount points are mounted with
mount -l

display the help of find command
find --help

display the html, javascript and text files in the current folder
find . -type f \( -name "*.htm*" -o -name "*.js*" -o -name "*.txt" \) -exec sh -c 'echo "$0"' {} \;

display the html, javascript and text files in the current folder (print0 is used to preserve the filenames of all the files which have newlines in their names)
find . -type f \( -name "*.htm*" -o -name "*.js*" -o -name "*.txt" \) -print0 | xargs -0 -n1 echo

Display the last colon-separated field of variable 'var'
echo "$var" | rev | cut -d: -f1 | rev

Display the last slash-separated part of each filename path in file.txt
rev file.txt | cut -d/ -f1 | rev

Display the last slash-separated part of path, in this case "example".
basename /usr/local/svn/repos/example

Display the last space-separated field of each line in file.txt
rev file.txt | cut -d ' ' -f1 | rev

display the list of all the text files present in the current directory excluding the search in certain paths.
find . -type f -name "*.txt" ! -path "./Movies/*" ! -path "./Downloads/*" ! -path "./Music/*" -ls

display the list of all the files in the current directory which have been accssed in the last 500 days exluding hidden files
find . -type f \( ! -iname ".*" \) -mtime +500 -exec ls {} \;

display the manual page of find
man find

Display the host's ECDSA fingerprint using the sha256 hasing algorithm.
ssh-keygen -l -f /etc/ssh/ssh_host_ecdsa_key.pub

Display the named characters in "line1\r\nline2"
echo -e "line1\r\nline2" | od -a

display the names without extensions of all the data files in current folder and do not search in sub folders and which have not been changed in the last 60 mins
find . -maxdepth 1 -name '*.dat' -type f -cmin +60 -exec basename {} \;

display the names without extensions of all the data files in current folder which have not been changed in the last 60 mins
find . -prune -name "*.dat"  -type f -cmin +60 |xargs -i basename {} \;

display the names without extensions of all the data files in current folder which have not been changed in the last 60 mins
find ./ -name "*.dat" -type f -cmin +60 -exec basename {} \;

Display the number of lines in all regular files under current directory tree and also show the total count
find . -type f -exec wc -l {} +

display the number of lines in all the ".c" files in the current folder
find . -name "*.c" -exec wc -l {} \;

display the number of lines in all the ".c" files in the current folder
find . -name "*.c" -print | xargs wc -l

display the number of lines in all the ".c" files in the current folder
find . -name "*.c" -print0 | xargs -0 wc -l

display the number of lines in all the files in the current folder
find . -exec wc -l {} \;

display the number of lines in all the files in the current folder
find . -name '*' | xargs wc -l

display the number of lines in all the header files in the current folder
find . -name "*.h" -print | xargs wc -l

Display the number of regular files under current directory tree
find . -type f -exec echo {} \; | wc -l

Display the number of regular files under current directory tree
find . -type f -print0 | tr -dc '\0' | wc -c

Display the output of "ls" for an 80 character wide display
ls | column -c 80

Displays what package provides value 'zsh'.
yum provides zsh

display the top 20 biggest files in the current folder which are present in the same partition as that of the current folder
find . -xdev -printf ‘%s %p\n’ |sort -nr|head -20

display the amount of disk space used by all the log files in the folder /usr/local/apache/logs/
find /usr/local/apache/logs/ -type f -name "*_log"|xargs du -csh

Display the sizes and filepaths of all files/directories sorted in ascending order of size
du -a --max-depth=1 | sort -n

Display the sizes and filepaths of all files/directories sorted in descending order of size
du -a -h --max-depth=1 | sort -hr

Display the sizes and filepaths of all files/directories with '.undo' extension under current directory tree
find -name *.undo -print0 | du -hc --files0-from=-

Display the file type description of /bin/bash, ie. symbolic link, ELF executable, etc.
$ file /bin/bash

display the size of all the files in the folder "${START_DIR}" which  have been modified in the last "${DAYS}"*24 hours
find ${START_DIR} -mtime -${DAYS} |xargs stat -c "%s"|awk '{sum += $1}END{print sum}'

Display the file size of file '/data/sflow_log' in bytes
du -sb /data/sflow_log | cut -f1

display the three largest files by size in current folder
find . -type f -exec ls -s {} + | sort -n -r | head -3

display the three smallest files by size in a folder.
find /etc/ -type f -exec ls -s {} + | sort -n | head -3

display the version of find
find --version

display the version of find command
find --version

display the version of find command
find -version

display ten files in the current directory
find | head

display ten files in the tmp directory
find /tmp  | head

Display which package the command "command" belongs to in dpkg
dpkg -S `which command`

Join colon-separated information in 3 files LN.txt PH.txt and AD.txt in a cascade fashion: join LN.txt and PH.txt, then join the result with AD.txt
join -t':' <(sort LN.txt) <(sort PH.txt) | join -t':'  - <(sort AD.txt)

Join columns in "file1" and "file2" if their first field matches and format the output as a table
join file1 file2 | column -t

Join comma-separated data in file1 and file2, including extra non-matching information in both files.
join -t, -a1 -a2 <(sort file1) <(sort file2)

Join comma-separated information in 4 files
join -t, <(sort test.1) <(sort test.2) | join -t, - <(sort test.3) | join -t, - <(sort test.4)

Join comma-separated information in 4 files - files must be sorted.
join -t, test.1 test.2 | join -t, - test.3 | join -t, - test.4

Join data in "file1" sorted by the second word of each line with data in "file2" sorted by the first word of each line, keeping the same order as it is found in "file1"
join -1 2 -2 1 <(sort +1 -2 file1) <(sort +0 -1 file2)

Join lines in file "A" with lines in file "B" if the lines share a common first word
join <(sort -n A) <(sort -n B)

Join lines in file "aa" with lines in file "bb" if the lines share a common first word
join <(sort aa) <(sort bb)

Join lines of 'file': fields 1 and 2 of lines discarding adjascent lines ignoring first 3 fields, with fields 3 to end of line discarding adjascent lines ignoring 3 last fields.
paste <(uniq -f3 file | cut -f1,2) <(tac file | uniq -f3 | tac | cut -f3-)

Download "Louis Theroux's LA Stories" using rsync over ssh
rsync -ave ssh '"Louis Theroux"''"'"'"'"''"s LA Stories"'

Download "http://www.multitran.ru/c/m.exe?CL=1&s=hello&l1=1" and convert encoding to "windows-1251" and print only printable characters
curl 'http://www.multitran.ru/c/m.exe?CL=1&s=hello&l1=1' | iconv -f windows-1251 | tr -dc '[:print:]'

Download "https://s3.amazonaws.com/sampletest/sample.tar.gz", unzip it, and untar it replacing filenames with "old" to "new"
curl https://s3.amazonaws.com/sampletest/sample.tar.gz | gunzip | pax -r -s "/old/new/"

Download 10 web pages "http://example.com/?page${i}.html" at most 2 at a time with "${i}" ranging from 1 to 10
seq 1 10 | xargs -n1 -P2 bash -c 'i=$0; url="http://example.com/?page${i}.html"; curl -O -s $url'

Download 10000 web pages "https://www.example.com/page{}.html" 100 at a time where "{}" ranges from 1 to 10000
seq 10000 | parallel -j100 wget https://www.example.com/page{}.html

download content from "http://127.0.0.1:8000" and output to "index.html"
curl http://127.0.0.1:8000 -o index.html

download content from "http://page.that.serves.json.com/json/" and format it as json
curl -s http://page.that.serves.json.com/json/ | json_xs

download content from "http://search.twitter.com/search.json?q=node.js" and format it as json
curl -s http://search.twitter.com/search.json?q=node.js | json

download contents from  "http://url" using a proxy server
curl -x http://proxy_server:proxy_port --proxy-user username:password -L http://url

download contents from "http://www.example.com" using a proxy server
curl http://www.example.com --proxy http://125.119.175.48:8909

download contents from "https://www.npmjs.com/install.sh" and execute
curl https://www.npmjs.com/install.sh | sh

download contents from website "www.example.com" using URL-encoding "paramName=param"
curl --data-urlencode "paramName=param" www.example.com

download contents of a website "http://example.com/"
curl http://example.com/

download contents of a website "https://get.scoop.sh"
curl -L https://get.scoop.sh

Try to determine the type of contents in "myfile" located in user's home directory.
file ~/myfile

Dry run making directories in "/TARGET_FOLDER_ROOT/" for each ".mov" file in the current directory tree
find . -type f -iname \*.mov -printf '%h\n' | sort | uniq | xargs -n 1 -d '\n' -I '{}' echo mkdir -vp "/TARGET_FOLDER_ROOT/{}"

Dump "/dev/ttySomething" in both hex and text
od -t x1 -t a /dev/ttySomething

Dump "FILENAME" as 2 byte wide hexadecimal numbers
od -tx2 FILENAME

Dump "a\0b" as hexadecimal bytes
printf "a\0b" | od -tx1

Dump "file" as ASCII characters
od -t c file

Dump "myDB" via "pg_dump" and compress to "myDB.sql.gz"
pg_dump -U myUser myDB | gzip > myDB.sql.gz

Dump "testscript.sh" as 2 byte hexadecimale, printable characters, and octal values
od -xcb testscript.sh

Dump a MySQL database over a compressed SSH tunnel and use it as input to mysql
mysqldump –add-drop-table –extended-insert –force –log-error=error.log -uUSER -pPASS OLD_DB_NAME | ssh -C user@newhost “mysql -uUSER -pPASS NEW_DB_NAME”

Dump all MySQL databases over an ssh tunnel to "user@yoursever.com" and use it as input to mysql
mysqldump --all-databases | ssh user@yourserver.com mysql

Dump the character output of 'echo `echo "Ho ho ho"`'
echo `echo "Ho ho ho"` | od -c

Duplicate directory tree under /mnt/usr/lib to /usr but creating symlinks to files instead of copying them.
cp -rs /mnt/usr/lib /usr/

Dynamically defines tmux session name to attach to.
tmux attach -t "$(echo stuff)"

Search "file1" for lines matching regex patterns listed in "file2" and list the unique results (sorted alphabetically)
grep -f file2 file1 | sort -u

Search "file1" for lines matching regex patterns listed in "file2" and list the unique results (sorted alphabetically)
grep -f file2 file1 | sort | uniq

Search "input.txt" for regex patterns only matching those listed in "ignore.txt", list the unique lines and prefix with the number of occurrences
grep -of ignore.txt input.txt | sort | uniq -c

Search "inputfile" for lines starting with "t:" and group the results in files with at most 200 lines each
cat inputfile | grep "^t\:" | split -l 200

Search "mygzfile.gz" for "string to be searched"
gunzip -c mygzfile.gz | grep "string to be searched"

Search "whatyousearchfor" in history and print 3 lines before and 4 lines after
history | grep -A 4 -B 3 whatyousearchfor

Search $MYGROUP in /etc/group, take the 4th colon (':') separated field, replace comma (',') with newline and save the result to variable 'MYUSERS'
MYUSERS=`grep $MYGROUP /etc/group | cut -d ":" -f4| tr "," "\n"`

Fetch 'stackoverflow.com' domain IP addresses from dig DNS lookup
dig stackoverflow.com | grep -e "^[^;]" | tr -s " \t" " " | cut -d" " -f5

Search *.txt files under and below /directory/containing/files for "pattern_to_search"
find /directory/containing/files -type f -name "*.txt" -exec grep -H 'pattern_to_search' {} +

Search *.x files from the current directory tree for string "fred"
find . -name ‘*.x’ -print0 | xargs -0 grep fred

Search .c and .h files in the current directory tree for "expr"
find . -name '*.[ch]' | xargs grep -E 'expr'

Search /dev/shm and /tmp for regular files not changed in two weeks
find /dev/shm /tmp -type f -ctime +14

Search /etc for files modified within the last 10 minutes
find /etc -type f -mmin -10

Search /etc for files modified within the last day
find /etc -type f -ctime -1

Search /path/to/your/directory for *.avi and *.flv files
find /path/to/your/directory -regex '.*\.\(avi\|flv\)'

Search /public/html/cosi for files whose name is "wiki.phtml"
find /public/html/cosi -name "wiki.phtml"

Search /some/directory for files that are owned by the user "joebob"
find /some/directory -user joebob -print

Search /tmp/ for files smaller than 100 bytes
find /tmp -size -100c

Search /usr, /home, /tmp for *.jar files
find /usr /home  /tmp -name "*.jar"

Search /usr, /home, /tmp for *.jar files suppressing error messages
find /usr /home  /tmp -name "*.jar" 2>/dev/null

Search /usr/bin for regular files that were last accessed more than 100 days ago
find /usr/bin -type f -atime +100

Search /usr/bin for regular files that have been modified within the last 10 days
find /usr/bin -type f -mtime -10

Search /usr/local for subdirectories whose names end with a number 0-9
find /usr/local -maxdepth 1 -type d -name '*[0-9]'

Search /usr/local recursively for directories whose names end with a number 0-9
find /usr/local -type d -name '*[0-9]'

Search /usr/src for filenames not ending in "*,v"
find /usr/src ! \( -name '*,v' -o -name '.*,v' \) '{}' \; -print

Search /var/log for logs larger than 10 megabytes
find /var/log -size +10M -ls

Search /var/tmp for files larger than 30 MB modified 31 days ago
find /tmp /var/tmp -size +30M -mtime 31 -ls

search a url in all regular/normal files in a folder.
find ./ -type f -exec grep https://www.ksknet.net {} \;

Search all *.c files from the current directory tree for "hogehoge"
find . -name \*.c -exec grep hogehoge {} \;

Search all *.c files from the current directory tree for "hogehoge"
find . -name \*.c -print | xargs grep hogehoge

Search all *.c files from the current directory tree for "hogehoge"
find . -name \*.c -print0 | xargs -0 grep hogehoge /dev/null

Search all *.txt files under ~/documents for the word "DOGS"
find ~/documents -type f -name '*.txt' -exec grep -s DOGS {} \; -print

Search all .c and .h files in the current directory tree for string "e"
find . -name "*.[ch]" -exec grep --color -aHn "e" {} \;

Search all .c files from the current directory tree for "keyword", ignoring the case
find . -name "*.c" -exec grep -i "keyword" {} ";"

Search all .java files residing in the current directory tree and modified at least 7 days ago for string "swt"
find . -name '*.java' -mtime +7 -print0 | xargs -0 grep 'swt'

Search all .pdf files  from directory tree ~/.personal/tips for "hot"
find ~/.personal/tips -type f -iname "*.pdf"  -exec pdftotext '{}' - ';'  | grep hot

Search all .py files in the current directory tree for "some_function"
find . -name \*.py | xargs grep some_function

search  all block spacial files called backup from /usr directory downwards and print them .
find /usr -type b -name backup -print

Search  all directory from /usr downwards for files whose inode number is 1234 and print them .
find /usr -inum 1234 -print

Search  all files & directoy from root directory which  are greater then 100M and delete them .
find /  -size +100M -exec rm -rf {} \;

Search all files and   directories either of the directory /home/oracle and  /home/databse which  contain the "zip"  anywhere in the files or directory name .
find /home/oracle /home/database -name '*zip*'

Search all files from the /tmp directory tree for the string "search string"
find /tmp -type f -exec grep 'search string' '{}' /dev/null \+

Search all files in the current directory tree, except *.html and *.svn*, for "SearchString"
find . ! -name '*.html' ! -name '*.svn*' -exec grep 'SearchString' {} /dev/null \;

Search all files in the current directory tree, except GIT files, for "string-to-search"
find . -name .git -prune -o -print | xargs grep "string-to-search"

Search all files in the current directory tree for "SearchString", ignoring .html files and skipping .svn directories
find . \( -name '*.svn*' -prune  -o ! -name '*.html' \) | xargs -d '\n' grep -Hd skip 'SearchString'

Search all files in the current directory tree that are named "whatever" for "whatever"
find . -name whatever -print | xargs grep whatever

Search all files in the current directory tree that are named "whatever" for "you_search_for_it"
find -name whatever -exec grep --with-filename you_search_for_it {} \;

Search all files in the current directory tree whose names contain "." for "SearchString"
find . -name '*.*' -exec grep 'SearchString' {} /dev/null \;

Search all files under and below /etc for IP addresses
find /etc -exec grep '[0-9][0-9]*[.][0-9][0-9]*[.][0-9][0-9]*[.][0-9][0-9]*' {} \;

search all files in the current folder which match the regular expression
find . -regex ".*/my.*p.$" -a -not -regex ".*test.*"

search and unzip all the ".fq.gz" files and perform a control check on this raw sequence of data and display the output to the screen
find . -name "*.fq.gz"  -exec gunzip -c  '{}' ';' | fastqc  /dev/stdin

search all html files in the current folder and remove all the empty lines
find ./ -type f -name '*.html' | xargs sed -i '/^$/d

search all undo files(ending with .undo) in the current folder and calculate the total size of them
find -name '*.undo' -exec wc -c {} + | tail -n 1

search all undo files(ending with .undo) in the current folder and calculate the total size of them
find -name '*.undo' -exec wc -c {} + | tail -n 1 | cut -d' ' -f 1

search all jpg files in current folder
find . -type f -name "*.jpg"

search all jpg images in current folder and rename them
find . -type f -name "*.jpg" -print0 | xargs -0 rename "s/Image_200x200_(\d{3})/img/"

search all mp3 files in the folder "/home/you" which have been modified yesterday (from the start of day 00:00 to 23:59)
find /home/you -iname "*.mp3" -daystart -type f -mtime 1

Search all PDFs from the current directory tree for "keyword", ignoring the case
find . -iname '*.pdf' -exec pdfgrep -i keyword {} +

Search all of /usr for any directory named 'My Files', for each directory found, copy it to /iscsi preserving full paths and attributes, then remove it.
find /usr -type d -name 'My Files' -exec rsync -avR '{}' /iscsi \;  -exec rm -rf '{}'\;

Search all Python files in the current directory tree for string "import antigravity"
find . -name "*.py" | xargs grep 'import antigravity'

Search all regular files from the current directory tree for lines containing "California" and "surfboard", and save the output as SurfsUp.txt
find . -type f -exec grep California {} \; -print | grep surfboard > SurfsUp.txt

Search all regular files in the /var/log directory tree for string "19:26"
find /var/log/ -type f -exec grep -H ‘19:26′ {} \;

Search all regular files in the current directory tree for "example"
find -type f -print0 | xargs -r0 grep -F 'example'

Search all regular files in the current directory tree for "string"
find . -type f -exec grep string {} \;

Search all regular files in the current directory tree for "string"
find . -type f | xargs -d '\n' grep string

search all the ".sh" files in the /usr folder and follow the symbolic links to their original file
find /usr -follow -name '*.sh'

Search all the *.pl files in the current directory and subdirectories, and print the names of any that don't have a line starting with 'use strict'
find . -name '*.pl' | xargs grep -L '^use strict'

search all the files in the current folder and assign them to a variable
files=`find .`

search all the files in the current folder excluding those that are present in the folder test and using regex
find . -name test -prune -regex ".*/my.*p.$"

search all the files in the current folder using name patterns
find . -name 'a(b*' -print

search all the files in the current folder using regex
find . -regex ".*/my.*p.$"

search all the files in the current folder using regex excluding those that are present in the folder test
find . -name test -prune -o -regex ".*/my.*p.$"

search all the files in the folder "myfiles" which have the word "blue" in their name
find /myfiles -name '*blue*'

search all the lines that start with the word malloc in the files ending with .c or .h or .ch
grep ^malloc `find src/ -name '*.[ch]'`

Search all the regular files from the current directory tree for "search string"
find . -type f -print -exec grep --color=auto --no-messages -nH "search string" "{}" \;

Search all the regular files in the current directory for "example"
find -maxdepth 1 -type f | xargs grep -F 'example'

Search all the regular files in the current directory tree for "example"
find -type f -print0 | xargs -r0 grep -F 'example'

Search appended data in "logfile.log" for "something" with a timeout of 3 seconds
read -t 3 variable < <( tail -f logfile.log | grep "something" )

Search appended data in "logfile.log" for "something" with a timeout of 3 seconds
tail -f logfile.log | grep --line-buffered "something" | read -t 3

search  character special files called ' backup '  from  /usr directory downwards and print them .
find /usr -type c -name backup -print

Search decompressed "filename.gz" for case-insensitive "user-user"
zcat filename.gz | grep -i user-user

Search directory $CURR_DIR for regular files that were changed, accessed, or modified $FTIME days ago
find ${CURR_DIR} -type f \( -ctime ${FTIME} -o -atime ${FTIME} -o -mtime ${FTIME} \) -printf "./%P\n"

Search directory $dirname for regular files and save the result to $tempfile
find $dirname -type f  > $tempfile

Search directory /Users/david/Desktop/ recursively for regular files
find /Users/david/Desktop/ -type f

Search directory /Users/david/Desktop/ recursively for regular files with extensions .txt, .mpg, .jpg
find /Users/david/Desktop -type f \( -name '*.txt' -o -name '*.mpg' -o -name '*.jpg' \)

Search directories /opt, /usr, /var for regular file foo
find /opt /usr /var -name foo -type f

Search directory /path/to/check/ for regular files
find /path/to/check/* -maxdepth 0 -type f

Search directories /path/to/directory/folder{1..50} for .txt files
find /path/to/directory/folder{1..50} -name '*.txt'  2>/dev/null

Search directories /path/to/directory/folder{1..50} for .txt files, outputting only the names of the matched files
find /path/to/directory/folder{1..50} -name '*.txt' -exec basename {} \; 2>/dev/null

Search directories /path/to/directory/folder{1..50} for .txt files, outputting only the names of the matched files stripped of the .txt suffix
find /path/to/directory/folder{1..50} -name '*.txt' -exec basename {} .txt \; 2>/dev/null

Search directories /res/values-en-rUS and /res/xml for XML files
find /res/values-en-rUS /res/xml -iname '*.xml'

Search directories called ' backup ' from /usr directory downwards and print them.
find /usr -type d -name backup -print

Search directory foo for files containing "/tmp/foo/bar" in their full names
find foo -path /tmp/foo/bar -print

Search directory foo for files containing "foo/bar" in their full names
find foo -path foo/bar -print

Search directory lpi104-6 for files with inode number 1988884
find lpi104-6 -inum 1988884

Search directory tree $DIR for *.txt files
find "$DIR" -name \*.txt

Search directory tree $DIR for *.txt files
find "${DIR}" -name "*.txt"

Search directory tree $DIR for *.txt files
find $DIR -name "*.txt"

Search directory tree $DIR for *.txt files
find $DIR -name "*.txt" -print

Search directory tree `MyApp.app' for directories whose name is 'Headers' and delete them in an optimized way
find -d MyApp.app -name Headers -type d -exec rm -rf {} +

Search directory tree `MyApp.app' for directories whose name is 'Headers' and delete them in an optimized way
find -d MyApp.app -name Headers -type d -print0 | xargs -0 rm -rf

Search directory tree `foo' for files named `Headers'
find foo -name Headers

Search directory trees /tmp and /var/tmp for "testfile.txt"
find /tmp /var/tmp -iname "testfile.txt"

Search directory trees /usr/local/man and /opt/local/man for files whose names begin with 'my'
find /usr/local/man /opt/local/man -name 'my*'

Search directory trees /usr/share/doc, /usr/doc, and /usr/locale/doc for files named 'instr.txt'
find /usr/share/doc /usr/doc /usr/locale/doc -name instr.txt

Search case insensitively for 'foo' in all the files with '.java' extension under current directory tree and show only the file names
find . -type f -name "*.java" -exec grep -il 'foo' {} \;

Search every directory except the subdirectory excluded_path for a regular file 'myfile'
find / -path excluded_path -prune -o -type f -name myfile -print

Search everywhere for a file called `httpd.conf' that is newer than /etc/apache-perl/httpd.conf
find / -name httpd.conf -newer /etc/apache-perl/httpd.conf

Search everywhere for directories named `root'
find / -type d -name root

Search everywhere for files changed within the last minute
find / -newerct '1 minute ago' -print

Search everywhere for hidden file `.profile'
find / -name .profile

Search files "file-containing-can't" in the current directory tree for the string "can't"
find . -name "file-containing-can't" -exec grep "can't" '{}' \; -print

search files in current folder using name patterns
find . -name "$pattern"

search files  in the file system excluding those in the paths "10_Recommended" and "/export/repo"
find / -name whatever -not -path "/10_Recommended*" -not -path "/export/repo/*"

search files in the folder /home which have been modified after /tmp/after and before /tmp/before
find /home/ -type f -newer /tmp/after -not -newer /tmp/before

Search file /etc/logs/Server.log for lines containing "Error"
find /etc/logs/Server.log -exec grep Error {} \; -print

Search file aaa from current direcoty downwards and print it .
find . -name aaa -print

Search folder /home/ABCD/ recursively for regular files
find /home/ABCD/ -type f -print

Search for " 000" in the hex dump of "file-with-nulls"
od file-with-nulls | grep ' 000'

Search for " 840" in history
history | grep " 840"

Search for "#define" in all files in the current directory, excluding backup files *~, *.orig, *.bak
find . -maxdepth 1 ! -regex '.*~$' ! -regex '.*\.orig$' \     ! -regex '.*\.bak$' -exec grep --color "#define" {} +

Search for "1234567890" in every gzip file modified between 8:00 and 9:00 on 2014-04-30
find . -newermt '2014-04-30 08:00:00' -not -newermt '2014-04-30 09:00:00' |xargs gunzip -c | grep 1234567890

Search for "CONFIG_64BIT" in gzip compressed file "/proc/config.gz"
zcat /proc/config.gz | grep CONFIG_64BIT

Search for "LOG" in jsmith's home directory tree
find ~jsmith -exec grep LOG '{}' /dev/null \; -print

Search for "Stock" in all *.java files from the current directory tree
find . -name "*.java" | xargs grep "Stock"

Search for "YOURSTRING" in all files under current directory
grep YOURSTRING `find .`

Search for "facebook\|xing\|linkedin\|googleplus" in "access-log.txt" and print a count of the unique entries
grep -ioh "facebook\|xing\|linkedin\|googleplus" access-log.txt | sort | uniq -c | sort -n

search for "flac" files in current folder using regular expressions
find ./ -regex "./cmn-.\.flac"

Search for "foo" in every file in the current directory and number the output
grep foo * | nl

Search for "ifconfig" in the output of "history" and print 5 lines that precede and follow
history | grep -C 5 ifconfig

Search for "ifconfig" in the output of "history" and print 5 lines that precede and follow
history | grep ifconfig -A5 -B5

Search for "mpirun" in all processes owned by the current user
pgrep -u `whoami` mpirun

Search for "pattern" in "file" and join each line by a space
cat file | grep pattern | paste -sd' '

search for "some_function" in all the python files in the current directory
find . -name \*.py | xargs grep some_function

search for "specified string" in all the php files in the current folder
find . -name “*.[php|PHP]” -print | xargs grep -HnT “specified string”

Search for "vid=123" in all compressed files found under "/my_home" matching "*log.20140226*"
zcat `find /my_home -name '*log.20140226*'`|grep 'vid=123'

Search for "whatever" in all files under /dir directory ensuring white space safety in filenames
find /dir -type f -print0 | xargs -0i cat {} | grep whatever

Search for "www.athabasca" in all files under current directory
find . -exec grep "www.athabasca" '{}' \; -print

Search for $GROUP at the beginning of each line in /etc/group and print the last colon (':') separated entry with comma replaced with newlines
grep ^$GROUP /etc/group | grep -o '[^:]*$' | tr ',' '\n'

Search for $SEARCH in all regular files under $DIR directory tree and display the number of bytes of the matched output
find $DIR -type f -exec grep $SEARCH /dev/null {} \; | wc --bytes

Search for '“foobar”' in all files starting with '‘' and ending with '’' and contain '.' in their names in the entire filesystem and display only the matched files
find / -name ‘*.*’ -exec grep -il “foobar” {} \;

Search for '/usr/bin/perl' in all regular files under current dirctory tree and also show a long listing of them
find . -type f -exec grep "/usr/bin/perl" {} \; -ls

Search for 'Attached: Yes' in all regular files under '/proc/scsi' directory tree matching the path '/proc/scsi/usb-storage' and show only the matched filenames
find /proc/scsi/ -path '/proc/scsi/usb-storage*' -type f | xargs grep -l 'Attached: Yes'

Search for 'DOGS' in all files with '.txt' extension under ~/documents and also print the file names
find ~/documents -type f -name '*.txt' -exec grep -s DOGS {} \; -print

Search for 'It took' in all $srch1* (case insensitive) files under current directory and run the sed script 'N;s/(.*)\n(.*)/\2 \1/' on the output and redirect the final output to temp1 file
find . -iname "$srch1*" -exec grep "It took" {} \; -print |sed -r 'N;s/(.*)\n(.*)/\2 \1/' > temp1

Search for 'Processed Files' in all $srch* (case insensitive) files under current directory
find . -iname "$srch*" -exec grep "Processed Files" {} \; -print

Search for 'Processed Files' in all $srch* (case insensitive) files under current directory run the sed script 'N;s/(.*)\n(.*)/\2 \1/' on the output and redirect the final output to temp2 file
find . -iname "$srch*" -exec grep "Processed Files" {} \; -print| sed -r 'N;s/(.*)\n(.*)/\2 \1/'  > temp2

Search for 'Processed Files' in all dl-aster-full-20131102* (case insensitive) files under current directory and print only the 2nd field from the output with : (colon) as the delimiter
( find . -iname "dl-aster-full-20131102*" -exec grep "Processed Files" {} \;) | cut -d":" -f2

Search for 'String' case insensitively in all files under current directory tree and show the matched lines with their filenames
find . -name * -print0  | xargs -0 grep -iH "String"

Search for 'Text To Find' in all regular files under current directory tree and show the matched files
find ./ -type f -exec grep -l "Text To Find" {} \;

Search for 'Text To Find' in all regular files under current directory tree and show the matched files and matched lines with line numbers
find ./ -type f -exec grep -Hn "Text To Find" {} \;

Search for 'example' in all regular files from the current directory
find -maxdepth 1 -type f | xargs grep -F 'example'

Search for 'example' in all regular files from the current directory tree
find -type f -print0 | xargs -r0 grep -F 'example'

Search for 'example' in all regular files under current directory tree
find . -type f -print | xargs grep "example"

Search for 'example' in all regular files under current directory tree and also print the filenames
find . -type f -exec grep "example" '{}' \; -print

Search for 'foo' in all regular files under 'sources' directory tree and show the matched lines with filenames
find sources -type f -exec grep -H foo {} +

Search for 'foo' in all the java files under 'dir1', 'dir2' and 'dir3' directory tree and print only the names of the matched files
find dir1 dir2 dir3 -type f -name "*.java" -exec grep -il 'foo' {} \;

Search for 'foo=' in all *.png files under current directory without descending into *.gif and *.svn directories
find . -name "*.png" -prune -o -name "*.gif" -prune -o -name "*.svn" -prune -o -print0 | xargs -0 -I FILES grep -IR "foo=" FILES

Search for 'invalidTemplateName' in all regular files in directories/files taken from the glob pattern './online_admin/*/UTF-8/*' and show the matched lines with the filenames
find ./online_admin/*/UTF-8/* -type f -exec grep -H "invalidTemplateName" {} \;

Search for 'ireg' in all PHP files under 'project' directory tree and show only the files that match
find project -name '*.php' -type f -print0 | xargs -0 grep -l ireg

Search for 'js' in all files under current directory that match 'some string' in their names
find . | grep 'some string' | grep js

Search for 'keyword' in all javascript files under current directory tree excluding all paths that includes the directory 'node_modules'
find ./ -not -path "*/node_modules/*" -name "*.js" | xargs grep keyword

Search for 'magic' in all regular files under current directory tree
find . -type f | xargs grep "magic"

Search for 'mystring' in all *.txt (case insensitive) files under current directory
find . -iname *.txt -exec egrep mystring \{\} \;

Search for 'mystring' in all *.txt files under current directory
find . -name "*.txt" -exec egrep mystring {} \;

Search for 'mystring' in all *.txt files under current directory
find . -name "*.txt" -print0 | xargs -0 egrep mystring

Search for 'mystring' in all *.txt files under current directory
find . -name '*.txt' | xargs egrep mystring

Search for 'mystring' in all *.txt files under current directory
find . -name *.txt | xargs egrep mystring

Search for 'pattern' in all files with '.cc' extension under current directory tree and show the matched lines with line numbers and filenames
find . -name “*.cc” |xargs grep -n “pattern”

Search for 'pattern' in file 'file' and print the matched lines by separating them with spaces instead of newlines
grep pattern file | tr '\n' ' '

Search for 'pattern_to_search' in all regular files with '.txt' extension under '/directory/containing/files' and show the matched lines along with filenames
find /directory/containing/files -type f -name "*.txt" -exec grep -H 'pattern_to_search' {} +

Search for 'some string' in all *.axvw files under current directory and show the matched lines with line numbers
find . -name '*.axvw' -exec grep -n 'some string' {} +

Search for 'some string' in all *.axvw files under current directory and show the matched lines with line numbers
find . -name '*.axvw' -print0 | xargs -0 grep -n 'some string'

Search for 'some string' in all *js files under current directory and show the matched lines with line numbers
find . -name '*js' -exec grep -n 'some string' {} \;

Search for 'some string' in all *js files under current directory and show the matched lines with line numbers
find . -name '*js' | grep -n  'some string'

Search for 'specific string' in all files matching the name pattern '“*.[txt|TXT]”' under current directory tree
find . -name “*.[txt|TXT]” -print | xargs grep “specific string”

Search for 'string' case insensitively in all files under current directory tree and show the matched lines with their filenames
find . -name * | xargs grep -iH "string"

Search for 'string-to-find' in all HTML files under current directory tree and show the matched lines with their filenames
find . -name \*.html -exec grep -H string-to-find {} \;

Search for 'stuff' in all *,txt files under current directory
find . -name "*.txt" -print0 | xargs -0 egrep 'stuff'

Search for 'text' in all regular files under current directory tree
find . -type f -exec grep "text" {} /dev/null \;

Search for 'whatIWantToFind' in all files under current directory
find . -exec grep whatIWantToFind {} \;

search for *.log files starting from /
find / -name "*.log"

search for *.log files starting from / (root) and only in the current file system
find / -xdev -name "*.log"

Search for *pattern* in and below current directory
find -name "*pattern*"

Search for .bam files anywhere in the current directory recursively
find . -name "*.bam"

Search for .pdf files
find / -name '*.pdf'

Search for .zip files that are larger than 100M found anywhere in the file system and delete those files.
find / -type f -name *.zip -size +100M -exec rm -i {} \;

Search for Subscription.java under current directory, and go to directory containing it.
cd "$(find . -name Subscription.java -printf '%h\n')"

search for a cpp directory in current folder and display all its files
find . -type d -name "cpp" -exec find {} -type f \;

search for a directory in a folder taking name as argument and assign the first instance of it to a variable
DIR='find $HOME -type d -name $1 | head 1'

search for a files "cart1" in the folder junk which is in home folder and move the folder to ~/junk/A.
find ~/junk  -name 'cart1' -exec mv {} ~/junk/A \;

search for a file "file" in current folder and display all instances of this file
find -name file -print

search for a file "file" in current folder and if the file is found quit !
find -name file -quit

search for a file in a directory and pass it as an input to the script getLine
find $dir -type f -name $1 -exec getLine {} \;

search for a file in current folder and append the file name at the starting of all the lines in the file
find /path/to/dir -type f | sed -r 'p;s:.*/(.*)/.*:\1:' | xargs -n 2 sh -c 'sed -i "s/^/$1 /" $0'

search for a file using name patterns from the list of all the regular files in the folder project and save the output to the file Include.
find project -type f -print | egrep '(\.[ch]|[Mm]akefile)$' > Include

search for a function in all python files in the current folder
find . -name '*.py' | xargs grep some_function

Search for a line starting with 'use strict' in all files with '.pl' extension under current directory tree and show the unmatched files only
find . -name '*.pl' | xargs grep -L '^use strict'

Search for a pattern "can't" in all the files with the name "file-containing-can't" in the current directory tree
find . -name "file-containing-can't" -exec grep "can't" '{}' \; -print

search for a pattern in all the files in the current folder
find . | xargs grep <string-to-find>

search for a pattern in all the python files in the current folder. and save the output to a txt file
find . -name "*.py" -type f -exec sh -c 'grep "something" <"$0" >"$0.txt"' {} \;

search for a pattern in all the python files in the current folder. and save the output to output.txt file
find . -name '*.py' -exec grep 'something' {} \; > output.txt

search for a regular/normal file myfile in the folder "/home/weedly"
find /home/weedly -name myfile -type f -print

search for a specific word in all files beginning with a specific word in the current directory
find -name 'file_*' -follow -type f -exec zcat {} \; | agrep -dEOE 'grep'

search for a specific word in all files beginning with a specific word in the current directory
find . -name "file_*" -follow -type f -print0 | xargs -0 zcat | agrep -dEOE 'grep'

search for a shell script in the current folder and display the current folder path but search from the sub directories
find . -name onlyme.sh -execdir pwd \;

Search for a string in all gzip'd files under the current directory
find . -type f -name "*.gz" -exec zgrep 'string' {} \;

search for a string in gzip'd files
find . -type f -name "*.gz" -exec zgrep 'GET /foo' {} \;

search for a word in all c files in the current folder
find . -name '*.c' | xargs grep 'stdlib.h'

search for a word in all the .C files( those having the extension "c") in current directory
find . -type f \( -iname “*.c” \) |grep -i -r “keyword”

search for a word in all the .C files in the current directory
find . -name "*.c" -exec grep -ir "keyword" {} ";"

search for a word in all the java files in the current directory
find . -name "*.java" | xargs grep "Stock"  find . -name "*.java" | xargs grep "Stock"  find . -name "*.java" | xargs grep "Stock"  find . -name "*.java" | xargs grep "Stock"  find . -name "*.java" | xargs grep "Stock"   find . -name "*.java" | xargs grep "Stock

search for a word in all the files in the current directory
find . -exec grep chrome {} +

search for a word in all the files in the current directory
find . -exec grep chrome {} \;

search for a word in all the files in the current directory
find . -type f -exec grep 'needle' {} \;

search for a word in all the files in the current directory
find . | xargs grep 'chrome'

search for a word in all the files in the current directory (case insensitive search)
find . -type f -exec grep 'needle' {} \;

search for a word in all the files in the current directory and display the file paths relative to the current directory
find . -exec grep -l foo {} +

search for a word in all the files with the extension "ch" in the current folder
find -name '*.[ch]' | xargs grep -E 'expr'

search for a word in all the fies in the current folder
find . -type f -exec grep some_string {} \;

search for a word in all the php files in the current folder and display the count of all matching lines.
find . -name \*.php -type f -exec grep -Hn '$test' {} \+ | wc -l

search for a word in all the php files in the current folder and display the count of all matching lines.
find . -name \*.php -type f -exec grep -Hn '$test' {} \; | wc -l

search for a word in all the php files in the current folder and display the count of all matching lines.
find . -name \*.php -type f -print0 | xargs -0 -grep -Hn '$test' | wc -l

search for a word in all the php files in the current folder and display the count of all matching lines.
find . -name \*.php -type f -print0 | xargs -0 -n1 grep -Hn '$test' | wc -l

search for a word in all the php files in the current folder and display the matching lines
find . -name \*.php -type f -exec grep -Hn '$test' {} \;

search for a word in all the php files in the current folder and display the matching lines.
find . -name \*.php -type f -print0 | xargs -0 -n1 grep -Hn '$test'

search for a word in all the php files in the current folder and display the matching lines. PLus at the end takes multilple files as input
find . -name \*.php -type f -exec grep -Hn '$test' {} \+

search for a word in all the normal/regular files in the current folder
find . -type f | xargs grep "text"

search for a word in all the regular files in the current folder.
find -type f -print0 | xargs -r0 grep -F 'example'

search for a word in all the regular/normal files in the current folder and display the filename along with the matched text
find . -type f -exec grep -l linux {} \;

search for a word in all the regular files in the current folder without traversing the sub directories .
find -maxdepth 1 -type f | xargs grep -F 'example'

search for a word in all the regular/normal files in the entire filesystem. ( + is used to give more than one file as input to the grep command.
find / -type f -exec grep -i 'the brown dog' {} +;

search for a word in all the shell scripts in the current folder and display the matched files.
find . -type f -name "*.sh" -exec grep -l landoflinux {} \;

search for a word in all the shell scripts in the current folder and display the matched files.(case insensitive search in grep commad)
find . -type f -name "*.sh" -exec grep -il landoflinux {} \;

search for all "tif" images in current folder
find . -name '*.tif ' -print

search for all "tif" images in the entire file system
find / -name '*.tif ' –print

Search for all *.conf files in entire file system
find / -type f -name "*.conf"

Search for all *.ogg (case insensitive) files in the $HOME directory that have an access time of greater than 30 days
find $HOME -iname '*.ogg' -atime +30

Search for all .html files in directory "www" and output only the basename (without containing path) of each.
find www -name \*.html -type f -exec basename {} \;

Search for all .mp3 files in the /mnt/usb directory tree
find /mnt/usb -name  "*.mp3" -print

search for all C, C++, Header, JavaScript files in the folder /opt/chromium/src and exclude the search in the path "/.svn" and save the output list to CSRC.LST
find /opt/chromium/src -wholename '*/.svn' -prune -o -type f -regex ".*\.\(c\|cc\|h\|js\)" -print > CSRC.LST

Search for all directories named foo, FOO, or any other combination of uppercase and lowercase characters beneath the current directory.
find . -iname foo -type d

search for all empty directories in the folder /home
find /home -type d -empty

search for all text files in the directory "/path/to/inputfiles" and pass them as input to the shell script in exec command and save the output to the file out.txt
find /path/to/inputfiles -name "*.txt" -exec /path/to/myprogram.sh {} \; > Out.txt

search for all text files in the folder /home
find /home -name *.txt

Search for all files and directories named foo, FOO, or any other combination of uppercase and lowercase characters beneath the current directory.
find . -iname foo

Search for all files newer than file /tmp/t1 but not newer than file /tmp/t2
find / -newer /tmp/t1 -and -not -newer /tmp/t2

Search for all files in the /home directory tree that have the same inode number
find /home -xdev -inum 2655341

Search for all files in the current directory recursively whose names contain "linkin park", ignoring the case
find . -iname "*linkin park*"

Search for all files named foo, FOO, or any other combination of uppercase and lowercase characters beneath the current directory.
find . -iname foo -type f

Search for all files not newer than file /tmp/t
find / -not -newer /tmp/t

Search for all files owned by user www-data that are not larger than 100kb
find -user www-data -not -size +100k

Search for all files that end in ".conf"
find / -type f -name "*.conf"

Search for all files with either "sitesearch" or "demo" in their path names
find . -ipath '*sitesearch*' -ipath '*demo*'

Search for all files with either "sitesearch" or "demo" in their path names
find . -iregex '.*sitesearch.*' -iregex '.*demo.*'

Search for all files with either "sitesearch" or "demo" in their path names
find . | grep -i demo | grep -i sitesearch

Search for all files with same inode NUM
find . -inum NUM

Search for all files with the same inode number 41525360
find . -follow -inum 41525360

search for all files ending with ".mkv" in current folder
find /volume1/uploads -name "*.mkv"

search for all non empty regular/normal files in the current folder and empty them ie., delete the content not the file
find . -type f -maxdepth 1 -not -empty -print0 | xargs -0i cp /dev/null {}

search for all html files in current folder and replace a pattern in all the files
find . -type f -name "*html" -exec perl -pi -e 's|pibeta.psi.ch/~stefan|midas.psi.ch/~stefan|g' {} ;

search for all html files in current folder folder and create a zip file of all these files
find . -name "*.html" -print | zip all-html-files.zip -@

search for all html files in current folder folder and create a zip file of all these files
find . -type f -name "*.html" | zip -j all-html-files -@

Search for all jpg images on the system and archive them
find / -name *.jpg -type f -print | xargs tar -cvzf images.tar.gz

Search for all non-hidden files
find . -name '*'

search for all png files in a folder and copy them to another folder
find /home/mine -iname "*.png" -exec sh -c 'cp $0 /home/mine/pngcoppies/copy/$0' {} \;

search for all pdf files in the folder "/home/pdf" which have been accessed in the last 60*24 hours
find /home/you -iname "*.pdf" -atime -60 -type -f

search for all regular/normal files in current folder and display all the files which contain 16 lines
find . -type f -print0 | xargs -0 grep -cH '.' | grep ':16$'

search for all regular files in the current directory which have the extension "c" or "asm"
find . -type f \( -iname "*.c" -or -iname "*.asm" \)

search for all regular/normal files in the current folder and display the number of lines in the file
find . -type f -print | xargs -L1 wc -l

search for all regular/normal files in the current folder and display the number of lines in the file
find . -type f -print0 | xargs -0L1 wc -l

search for all xml files in current folder and display them
find . -name "*.xml" -exec echo {} \;

search for all xml files in current folder and display the copy command to copy them to another folder
find . -name "*.xml" -exec sh -c 'echo "cp $0 someWhereElse/$0"' {} \;

search for all xml files in some directory
I'm assuming you only want to zip files that match names in $Namese. In your script, try replacing the find command with:  export Namese  find /var/tmp/ -type f -name '*.xml'

search for all Scala files under the current directory that contain the string null
find . -type f -name "*.scala" -exec grep -B5 -A10 'null' {} \;

search for all perl files in the folder /nas/projects/mgmt/scripts/perl which have been modified yesterday
find /nas/projects/mgmt/scripts/perl -mtime 1 -daystart -iname "*.pl"

search for all tar.gz compress files  in the current folder
find -name *.tar.gz

search for all the ".pyc" files inthe current folder and remove them
find . -name "*.pyc" | xargs -i rm '{}

search for all the .o files in the current directory which have permisssions 664 and print them.
find . -name *.o -perm 664 -print

search for all the log files in the folder "/var/log" and create a tar ball and compress it to bz2.
find /var/log -name '*.log' | tar cv --files-from=- | bzip2 > log.tar.bz2

search for all the log files in the folder /apps which have not been modified in the last 60 days and which are present in the same file system as that of /apps and delete them
find /apps -xdev -name "*.log" -type f -mtime +60 | xargs rm

search for all the c files in the current folder
find . -name \*.c -print

search for all the rpm files in the file system which reside in the same partition as that of the root
find / -xdev -name "*.rpm"

search for all the directories ending with ".mp3" in the file system and move them to the folder /mnt/mp3
find / -iname "*.mp3" -type d -exec /bin/mv {} /mnt/mp3 \;

search for all the directories in a folder and limit the search to current folder and give them as input to the python script
find /stuff -maxdepth 1 -type d -exec script.py {} +

search for all the directories in a folder and limit the search to current folder and give them as input to the python script
find /stuff -type d -printf '%P\0' | xargs -0 script.py

search for all the directories in a folder and limit the search to current folder and give them as input to the python script
find /stuff/* -type d -maxdepth 1 -print0 | xargs -0 script.py

search for all the directories in a folder and limit the search to current folder and give them as input to the python script
script.py $(find /stuff/* -type d)

search for all the directories in a folder and give them as input to the python script
find /stuff -type d -exec script.py {} +

Search for all the directories in directories taken from the glob pattern '/path/to/folders/*' and add the extension ".mbox" to all and create directories named 'Messages' inside them
find /path/to/folders/* -type d -exec mv {} {}.mbox \; -exec mkdir {}.mbox/Messages \;

search for all the directories in the current directory and do not search in sub directories
find . -mindepth 1 -maxdepth 1 -type d

search for all the directories in the current folder and save the output to a variable
dirs=($(find . -type d))

search for all the directories in the current folder and run the print command in the searched folder
find . -type d -execdir sh -c 'printf "%s/%s\n" "$PWD" "$0"' {} \;

search for all the directories in the current folder, do not search in sub folders and run the 'pwd' command in all these directories
find . -maxdepth 1 -type d \( ! -name . \) -exec bash -c "cd '{}' && pwd" \;

Search for all the directories named 'm?' under current directory tree, add the extension ".mbox" to all, create a 'Messages' directories inside them and move all files with .emlx extension to 'Messages' directory
find . -name 'm?' -type d -exec mv '{}' '{}.mbox' ';' -exec mkdir '{}.mbox/Messages' ';' -exec sh -c 'mv {}.mbox/*.emlx {}.mbox/Messages' ';'

search for all the text files and display the long listing of these files from that directory
find . -name "*.txt" -execdir ls -la {} ";"

search for all the text files in the folder /home/calvin/ and save the output to  /tmp/search.log
find /home/calvin/ -name “*.txt” > /tmp/search.log

Serach for all the files containing grep in man pages
find /usr/share/man/ -regex .*grep*

Search for all the files in man pages and return the manual page for grep
find /usr/share/man/ -regex .*/grep*

Serach for all the files starting with grep in man pages
find /usr/share/man/ -regex grep.*

search for all the files ending with ".bak" in current folder which have not been accessed in the last 30 days and delete the file it it exists
find . -name '*.bak' -type f -atime +30 -exec csh -c 'test -s $1:r && rm $1' '{}' ;

search for all the files ending with "fits" in the folder "/store/01"
find /store/01 -name "*.fits"

search for all the files excluding directories ending with old or sccs or core or orig in the project folder and append the output to the file exclude
find . -type f -print | \ egrep  '/,|%$|~$|\.old$|SCCS|/core$|\.o$|\.orig$' >>Exclude

search for all the files excluding directories ending with old or sccs or core or orig in the project folder and save the output to the file exclude
find project ! -type d -print | egrep '/,|%$|~$|\.old$|SCCS|/core$|\.o$|\.orig$' > Exclude

search for all the files having spaces in the current folder and save the output to the variable founddata
founddata=`find . -name "filename including space" -print0`

search for all the files in a directory and give the first five characters of the file
find . -type f -exec bash -c 'echo ${1:0:5}' funcname {} \;

search for all the files in current folder which start with "file2015-0" and move them to frst 400 fiiles  to another folder
find . -name "file2015-0*" | head -400 | xargs -I filename mv  filename

search for all the files in the current directory which have the group staff and have write permission enabled to the user and display them.
find . -group staff -perm -2000 -print

search for all the files in the current directory which have the name a.out or core or which end with .o and delete them.
find . \( -name a.out -o -name '*.o' -o -name 'core' \) -exec rm {} \;

search for all the files in the current directory which have been modified in the last 24 hours.
find . -mtime -1

search for all the files in the current directory which belong to the user "xuser1" and change the owner ship of them to "user2"
find . -user xuser1 -exec chown -R user2 {} \;

search for all the files in the current folder and sort them in the order of their depth and display the file names
find -type d -printf '%d\t%P\n' | sort -r -nk1 | cut -f2-

search for all the files in the current folder which are bigger than 10KB and display them biggest file
find . -size +10k -exec ls -ls {} \+ | sort -n | tail -1

search for all the files in the current folder which have not been modified in the last 7 days and save the output to a file
find -mtime +7 -print > found.lst

search for all the files in the current folder which have spaces and force delete them
find . -name "filename including space" -print0 | xargs -0 rm -rdf

search for all the files in the current folder which have spaces, save the output of a file and save the long listing of these files to a log file
find . -name "filename including space" -print0 | tee my_teed_file | xargs -0 ls -aldF > log.txt

search for all the files in the current folder which have the word "-GHBAG-" and display the move command for replacing the word "GHBAG" in the file names to "stream-agg"
find . -name '*-GHBAG-*' -exec bash -c 'echo mv $0 ${0/GHBAG/stream-agg}' {} \;

search for all the files in the current folder which start with gen and end with bt2 and assign the output list to the variable var.
var="$(find . -name 'gen*.bt2')"

search for all the files in the entire file system which have either suid or sgid bit enabled and find of diff of these files with the file "files.secure".
find / \( -perm 2000 -o -perm 4000 \) -print | diff - files.secure

search for all the files in the folder /data/images which are modified after /tmp/foo
find /data/images -newer /tmp/foo

search for all the files in the folder /data/images which have been modified after /tmp/start and before /tmp/end
find /data/images -type f -newer /tmp/start -not -newer /tmp/end

search for all the files in the folder /data/images which have been modified after /tmp/start and before /tmp/end and save the output list to output.txt
find /data/images -type f -newer /tmp/start -not -newer /tmp/end > output.txt

search for all the files in the folder /home which have sticky bit set and have the permissions 553
find /home -perm 1553

search for all the files in the folder /home/user1 which end with ".bin"
find /home/user1 -name "*.bin"

search for all the files in the folder /usr/bin which have not been accessed in the last 100*24 hours
find /usr/bin -type f -atime +100

search for all the files which have not been modified in the last 6 months (180 days) in current folder and display the disk usage of them
find . -mtime +180 -exec du -sh {} \;

search for all the files with the name "dummy" in the current folder  and discard all the errors.
find / -type f -name dummy 2>/dev/null

search for all the foo.txt files in the current folder and move them to another location
find . -name foo.txt -print0 | xargs -0  -I{} mv {} /some/new/location/{}

search for all the Joomla's version.php files in various directories and display the latest versions of it.
find /var/www/vhosts/*/httpdocs -type f \( -iwholename '*/libraries/joomla/version.php' -o -iwholename '*/libraries/cms/version.php' -o -iwholename '*/libraries/cms/version/version.php' \) -print0 -exec perl -e 'while (<>) { $release = $1 if m/ \$RELEASE\s+= .([\d.]+).;/; $dev = $1 if m/ \$DEV_LEVEL\s+= .(\d+).;/; } print qq( = $release.$dev\n);' {} \;

search for all the jpg files in the folder "/mnt/hda1/zdjecia/test1/" and copy these files to the folder  /mnt/hda1/test/<same name as the found file>
find /mnt/hda1/zdjecia/test1/ -iname “*.jpg” -type f -exec cp {} -rv /mnt/hda1/test{} ‘;’

search for all the jpg files in the folder "/mnt/hda1/zdjecia/test1/" and create a directory in /mnt/hda1/test with the same name as the mp3 file
find /mnt/hda1/zdjecia/test1/ -type f -iname ‘*.jpg’ -printf ‘%’h’\'”0″ | xargs -0 -I ‘{}’ mkdir -p /mnt/hda1/test/{} \;

search for all the links in a folder and display all the broken links
find -L /target -type l | while read -r file; do echo $file is orphaned; done

search for all the mp3 files in the current folder and change the character encoding of them to <source-encoding>
$ find . -name "*mp3" -print0 | xargs -0 mid3iconv -e <source-encoding> -d

search for all the mp3 files in the current folder and change the character encoding of them to  EUR-KR (Korean characters)
$ find . -name "*mp3" -print0 | xargs -0 mid3iconv -e EUR-KR -d

search for all the mp3 files in the file system and move them to the folder /mnt/mp3
find / -iname "*.mp3" -exec mv {} /mnt/mp3 \;

search for all the non-hidden files in the current directory and do not search in the subfolders and dispaly their name and size.
find . -maxdepth 1 -name '[!.]*' -printf 'Name: %16f Size: %6s\n'

search for all the php files in  current directory and check for their syntax ( check for syntax errors) .
find . -name \*.php -type f -exec php -l {} \;

search for all the php files in the folder "/home/mywebsite" which have been changed in the last 30*24 hours
find /home/mywebsite -type f -name "*.php" -ctime -30

search for all the regular/normal files ending with sdw or sdc or sdd in the current folder and save the output to list_1 file
find . -type f | egrep '(sdw|sdc|sdd)$' > list_1

search for all the regular/normal files  in the /etc folder which have been modified in the last 24 hours
find /etc/ -type f -mtime -1

search for all the regular/normal files in the current folder and display only video/image files
find folder -type f -print0 | xargs -0 file --media-type | egrep 'image|video' | cut -f1 -d : | tr '\n' '\0'

search for all the regular files in the current folder and display the contents
find . -type f -exec cat {} \;

search for all the regular files in the folder /home which have the permission 077
find /home -type f -perm 0777 -print

search for all the regular/normal mp3 files in the file system and move them to the folder /mnt/mp3
find / -iname "*.mp3" -type f -exec /bin/mv {} /mnt/mp3 \;

search for all the regular/normal mp3 files in the file system and move them to the folder /mnt/mp3
find / -iname "*.mp3" -type f -print0 | xargs -0 -I '{}' /bin/mv "{}" /mnt/mp3/

search for all the regular/normal mp3 files in the file system and move them to the folder /mnt/mp3
find / -iname "*.mp3" -type f | xargs -I '{}' mv {} /mnt/mp3

search for all the regular/normal mp3 files in the file system and sync them to the folder /mnt/mp3
find / -iname "*.mp3" -type f -print0 | xargs -0 -I '{}' /usr/bin/rsync -avR "{}" /mnt/mp3/

search for all the perl files in the folder /nas/projects/mgmt/scripts/perl which have been modified 8-10 days ago.
find /nas/projects/mgmt/scripts/perl -mtime 8 -mtime -10 -daystart -iname "*.pl"

search for all the symbolic links in a folder and delete them
find /target/dir -type l ! -exec test -e {} \; -exec rm {} \;

Search for all zero-byte files and move them to the /tmp/zerobyte folder
find test -type f  -size 0 -exec mv {} /tmp/zerobyte \;

search for al cpp files in current folder and display distinct parent directory of these files in sorted order
find . -name "*.cpp" -exec dirname {} + | sort -u

search for al cpp files in current folder and display distinct parent directory of these files in sorted order
find . -name "*.cpp" | while read f; do dirname "$f" ; done | sort -u

Search for case-insensitive "string" in "log.tar.gz"
zcat log.tar.gz | grep -a -i "string"

(Linux specific) Search for command "tail" in the maps of the process with PID 2671
cat /proc/2671/maps | grep `which tail`

search for dbmsspool.sql file in the current folder
find . -print|grep ?i dbmspool.sql

search for directories in the folder "test" which end have 5 digits as their name
find ./test -type d -name '[0-9][0-9][0-9][0-9][0-9]'

search for directories in the folder "test" which end with 5 digits using regular expressions
find ./test -regextype posix-egrep -type d -regex '.*/[0-9]{5}$'

search for bash and rsync files in the entire file system excluding search in /usr folder and discard all the errors
find / -path /usr -prune -o \( -name rsync -o -name bash \) -print 2>/dev/null

search for bash and rsync files in the entire file system excluding search in the path /usr/share folder and discard all the errors
find / -path /usr/share -prune -o \( -name rsync -o -name bash \) -print 2>/dev/nul

Search for empty files
find . -size 0k

Search for ERROR in all btree*.c files under current directory
grep ERROR $(find . -type f -name 'btree*.c')

Search for aaa in all files under current directory and count the number of matches
find . -type f -exec grep -o aaa {} \; | wc -l

Search for aaa in all files under current directory and count the number of matches
find .|xargs perl -p -e 's/ /\n'|xargs grep aaa|wc -l

search for text files in the current folder which have write access to others
find . -type f \( -iname "*.txt" -and -perm -o=w \)

search for text files in the current folder which do not have write access to others
find . -type f \( -iname "*.txt" ! -perm -o=w \)

search for text files in the current folder which do not have write access to others
find . -type f \( -iname "*.txt" -not -perm -o=w \)

search for text files in the directory "/home/user1" and copy them to the directory /home/backup
find /home/user1 -name '*.txt' | xargs cp -av --target-directory=/home/backup/ --parents

search for text files in the folders /home/hobbes/ /home/calvin/
find /home/hobbes/ /home/calvin/ -name “*.txt”

search for text files in the folders /home/hobbes/ /home/calvin/ and discard all the errors
find /home/hobbes/ /home/calvin/ -name “*.txt” 2>/dev/null

search for text files in the folder /home/you which have been modified in the last 60*24 hours(case insensitive search) and display their contents
find /home/you -iname "*.txt" -mtime -60 -exec cat {} \;

Search for files/directories named 'fileName.txt' under '/path/to/folder' directory tree without traversing into directories that contain the string 'ignored_directory' in their paths
find /path/to/folder -path "*/ignored_directory" -prune -o -name fileName.txt -print

Search for files/directories named 'fileName.txt' under current directory tree without traversing into './ignored_directory'
find . -path ./ignored_directory -prune -o -name fileName.txt -print

Search for files/directories that are readable for everybody, have at least one write bit set but are not executable for anybody
find . -perm -444 -perm /222 ! -perm /111

Search for files/directories with a case insensitive .txt extension in entire file system
find / -iname '*.txt'

Search for files/directories which are writable by both their owner and their group
find . -perm -220

Search for files/directories which are writable by both their owner and their group
find . -perm -g+w,u+w

Search for files/directories which are writable by either their owner or their group
find . -perm /220

Search for files/directories which are writable by either their owner or their group
find . -perm /u+w,g+w

Search for files/directories which are writable by either their owner or their group
find . -perm /u=w,g=w

Search for files/directories which are writable by somebody (their owner, or their group, or anybody else)
find . -perm /222

Search for files/directories which have read and write permission for their owner, and group and only read permission for others
find . -perm -664

Search for files/directories which have read and write permission for their owner, and group and only read permission for others
find . -perm 664

Search for files/directories with the case insensitive pattern anaconda* in /var/log
find /var/log/ -iname anaconda*

Search for files/directories with the case insensitive pattern anaconda.* in /var/log directory and create an archive (file.tar) of the last file found
find /var/log/ -iname anaconda.* -exec tar -cvf file.tar {} \;

Search for files/directories with the case insensitive pattern anaconda.* in var/log directory
find var/log/ -iname anaconda.*

Search for files/directories with the case insensitive pattern anaconda.* in var/log directory and create an archive (file.tar) of all the files found
find var/log/ -iname "anaconda.*" -exec tar -rvf file.tar {} \;

Search for files/directories with the case insensitive pattern anaconda.* in var/log directory and create an archive (somefile.tar) of all the files found
tar -cvf file.tar `find var/log/ -iname "anaconda.*"`

Search for files/directories with the case insensitive pattern anaconda.* in var/log directory and create an archive (somefile.tar) of all the files found ensuring white space safety
find var/log -print0 -iname 'anaconda.*' | tar -cvf somefile.tar -T -

Search for files/directories with the case insensitive pattern anaconda.* in var/log directory and create an archive (file1.tar) of the last block of files sent to xargs
find var/log/ -iname anaconda.* | xargs tar -cvf file1.tar

Search for files/directories with the case insensitive pattern anaconda.* in var/log directory and create an archive (file.tar) of the last file found
find var/log/ -iname anaconda.* -exec tar -cvf file.tar {} \;

Search for files greater than 20MB in the entire file system, display the path and file size and discard error reporting of the find command
find / -type f -size +20M -exec ls -lh {} \; 2> /dev/null | awk '{ print $NF ": " $5 }'

Search for files greater than 20MB in the entire file system, sort them according to size in ascending order and display the path and file size
find / -type f -size +20M -exec ls -lh {} \; 2> /dev/null | awk '{ print $NF ": " $5 }' | sort -nk 2,2

Search for files greater than 20MB in the entire file system, sort them according to size in descending order and display the path and file size
find / -type f -size +20000k -exec ls -lh {} \; 2> /dev/null | awk '{ print $NF ": " $5 }' | sort -nrk 2,2

Search for files greater than 20MB under your home directory (/home/user)
find ~ -size +20M

Search for files in your home directory which have been modified in the last twenty-four hours
find $HOME  -mtime 0

Search for files in your home directory which have been modified in the last twenty-four hours.
find $HOME  -mtime 0

Search for files in the current user's home directory and below for files that have not been accessed for more than 100 days and ask the user for permission to delete each file, one by one.
find ~/ -atime +100 -exec rm -i {} \;

Search for files only that end with .php and look for the string $test inside those files
find . -name \*.php -type f -exec grep -Hn '$test' {} \+

Search for files only that end with .php and look for the string $test inside those files
find . -name \*.php -type f -exec grep -Hn '$test' {} \;

Search for files only that end with .php and look for the string $test inside those files
find . -name \*.php -type f -print0 | xargs -0 -n1 grep -Hn '$test'

Search for files only that end with .php and look for the string $test inside those files
find . -name \*.php -type f -print0 | xargs -0 grep -Hn '$test'

Search for files specifying the maximum depth of the search
find -maxdepth num -name query

Search for files specifying the minimum depth of the search
find -mindepth num -name query

Search for files that are at least 100MB
find / -size +100M

Search for files that were accessed less than 5 days ago.
find -atime -5

Search for files whose size is between 100 kilobytes and 500 kilobytes
find . -size +100k -a -size -500k

Search for files with "demo" in their names and "sitesearch" in their path names
find . -iname '*demo*' | grep -i sitesearch

Search for files with "sitesearch" in their names and "demo" in their path names
find . -iname '*sitesearch*' | grep demo

Search for files which are writable by somebody
find . -perm /222

Search for files which have read and write permission for their owner and group, and which other users can read, without regard to the presence of any extra permission bits
find . -perm -664

search for files cart1 or cart2 or cart3 or ...cart6 in the folder junk which is in home folder and display all its details. Discard all the errors and do not display them.
find ~/junk  -name 'cart[1-6]' -exec ls -l {} \; 2> /dev/null

search for files cart4 or cart5 or cart6 in the folder junk which is in home folder and delete it.
find ~/junk  -name 'cart[4-6]' -exec rm {}  \;

search for files in a directory and check the validity of a command by giving the  file as input
find … -print0 | xargs -0 -n1 invalid_command

search for files in current folder using name patterns
find . -name "S1A*1S*SAFE"

search for files in current folder using regular expressions
find ./ -regex '.*\..*'

search for files in the current folder ending with ".au"
find -type f -name '*.au'

search for files in the current folder ending with ".au" and save the output to the file names.txt
find -type f -name '*.au' > names.txt

search for files in the current folder using name patterns
find . -name '[mM][yY][fF][iI][lL][eE]*'

search for files in the current folder which start with "myfile" ( case insensitive search )
find . -iname 'MyFile*'

search for files named "WSFY321.c" in a case-insensitive manner
find . -iname "WSFY321.c"

search for files starting with memo and which belong to the user ann in the folder /work
find /work -name 'memo*' -user ann -print

search for files which are writable by both their owner and their group
find . -perm -220

search for files which are writable by both their owner and their group
find . -perm -g+w,u+w

search for files which are writable by either their owner or their group
find . -perm /220

search for files which are writable by either their owner or their group
find . -perm /u+w,g+w

search for files which are writable by either their owner or their group
find . -perm /u=w,g=w

search for files with the name "temp" in the /usr folder
find /usr -name temp -print

Search for filenames matching "android" in the current directory and number the output
ls | grep android | nl

Search for file "file" between level 2 and 3 of the directory tree
find -mindepth 2 -maxdepth 3 -name file

Search for file names with "bad" characters in the current directory and delete the files.
find . -name '*[+{;"\\=?~()<>&*|$ ]*' -maxdepth 0 -exec rm -f '{}' \;

Search for first match of the case insensitive regex 'oyss' in all *.txt files under current directory and print the file paths along with the matches
find . -name '*.txt'|xargs grep -m1 -ri 'oyss'

Search for first match of the case insensitive regex 're' in all *.coffee files under current directory and print the file paths along with the matches
find . -print0 -name '*.coffee'|xargs -0 grep -m1 -ri 're'

search for jpg images in folders in the path "cam2/2013" and convert these files to the video Cam2-2013-30fps-19crf.mp4
find Cam2/2013* -name "*.jpg" -print0 | xargs -0 cat | ffmpeg -f image2pipe -framerate 30 -vcodec mjpeg -i - -vcodec libx264 -profile:v baseline -level 3.0 -movflags +faststart -crf 19 -pix_fmt yuv420p -r 30 "Cam2-2013-30fps-19crf.mp4"

Search for line 111 in file "active_record.rb" with 2 lines of context
nl -ba  -nln  active_record.rb  | grep -C 2 '^111 '

Search for line number 111 in file "active_record.rb"
nl -ba  -nln  active_record.rb  | grep '^111 '

Search for lines that have zero or more whitespace characters before "http://" and number the uniquely sorted output
grep '^[[:space:]]*http://' | sort -u | nl

search for MP3 files in the current folder and subfolders exclude dir1 AND dir2
find ! -path "dir1" ! -path "dir2" -iname "*.mp3"

search for mp3 files in the folder /mp3collection which are smaller than 5MB
find /mp3collection -name '*.mp3' -size -5000k

search for multiple files in the current folder
find . -name photoA.jpg photoB.jpg photoC.jpg

Search for non-empty files
find . ! -size 0k

Search for occurrences of string "main(" in the .c files from the current directory tree
find . -name "*.c" -print | xargs grep "main("

Search for occurrences of string "main(" in the .c files from the current directory tree
find . -type f -name "*.c" -print -exec grep -s "main(" {} \;

search for pattern matched files in the current folder and subfolders exclude "excluded path"
find ./ -type f -name "pattern" ! -path "excluded path" ! -path "excluded path"

search for php files  in current directory and search for a word in all these files
find -name '*.php' -exec grep -iq "fincken" {} \; -exec grep -iq "TODO" {} \; -print

Search for regular expression 'expr' in all .c and .h files from the current directory tree
find -name '*.[ch]' | xargs grep -E 'expr'

Search for regular files of the grooup 'users' in the file system
find /  -type f -group users

Search for regular files of the user bluher in the file system
find / -type f -user bluher -exec ls -ls {}  \;

search for regular files in the current folder which path is not  "./.*" and not "./*/.*"
find ./ -type f -name "*" ! -path "./.*" ! -path "./*/.*"

search for regular/normal file with the name "myfile" in the entire file system
find / -name myfile -type f -print

search for regular/normal file with the name "myfile" in the entire file system and discard all the errors
find / -name myfile -type f -print 2> /dev/null

search for perl files in the folder /users/tom
find /users/tom -name "*.pl"

search for swap files (.swp files) in temp folder and remove them
find /tmp -name '*.swp' -exec rm {} \;

Search for symlinks pointing to anywhere within /mnt/oldname/
find / -type l -lname '/mnt/oldname*'

search for the ".git" folder in the current folder and run the git pull request
find . -name .git -type d -execdir git pull -v ';'

search for the directory "config" in the current folder
find . -name config -type d

search for the directory "config" in the current folder and change directory to it
cd `find . -name "config"`

search for the directory "mysql" in the /etc folder
find /etc -name mysql -type d

search for the directory "mysql" in the entire file system
find / -name mysql -type d

search for the directory "ora10" in the entire file system
find / -type d -name "ora10"

search for the directory "uploads" in current folder and change the permission of the folder and all the files to 755
find . -type d -name 'uploads' -print0 | xargs -0 chmod -R 755

search for the directory "uploads" in current folder and change the permission of the folder and all the files to 755
find . -type d -name 'uploads' | while read d; do chmod -R 755 "$d"; done

search for the directory testdir in the folder /home
find /home -type d -name testdir

search for the directory starting with "ora10" in the entire file system
find / -type d -name "ora10*"

search for the directory with the name aa in the current folder
find . -type d -name aa

Search for the case insensitive pattern 'search for me' in all files with '.p', '.w' and '.i' extension under current directory tree without descending into '.svn' and 'pdv' directories
find . \( \( -name .svn -o -name pdv \) -type d -prune \) -o \( -name '*.[pwi]' -type f -exec grep -i -l "search for me" {} + \)

Search for the case insensitive regex 'STRING_TO_SEARCH_FOR' in all files under current directory
find . -type f -exec grep -n -i STRING_TO_SEARCH_FOR /dev/null {} \;

Search for the case insensitive regex expanded by $2 in all files named $1 (to be expanded) under current directory
find . -name "$1" -type f -exec grep -i "$2" '{}' \;

Search for the case insensitive regex expanded by $2 in all files named $1 (to be expanded) under current directory
find . -name "$1" -type f -print0 | xargs -0 grep -i "$2"

Search for the case insensitive regex expanded by $2 in all files named $1 (to be expanded) under current directory
find . -name $1 -type f -exec grep -i $2 '{}' \;

Search for the query "filename" in the current directory and any subdirectories
find -iname "filename"

search for the text file "file.txt" and display its parent directory
cd /nfs/office/ &&  find . -name 'file.txt' | sed -r 's|(\./([^/]*/)?).*|\1|'

Search for the extened regex 'expr' in all files with '.c' and '.h' extension under current directory tree
find . -name '*.[ch]' | xargs grep -E 'expr'

Search for the extended regex expanded by"$MONTH\/$YEAR.*GET.*ad=$ADVERTISER HTTP\/1" in the decompressed contents of the /var/log/apache2/access*.gz files that are newer than ./tmpoldfile and older than ./tmpnewfile
find /var/log/apache2/access*.gz -type f -newer ./tmpoldfile ! -newer ./tmpnewfile \ | xargs zcat | grep -E "$MONTH\/$YEAR.*GET.*ad=$ADVERTISER HTTP\/1" -c

Search for the files/directories that were modified more than an hour ago
find . -mtime +1

Search for the files that are owned by user rooter or by user www-data
find -user root -o -user www-data

search for the file ".user.log" and display its parent directory
cd /nfs//office/ && find . -name '.user.log' | xargs -I{} dirname {} | xargs -I{} dirname {}

search for the file ".user.log" in a folder
find /nfs/office -name .user.log -print

search for the file "abc" in the current folder or display all the directories
find . -name abc -or -type d

search for the file "dok.txt" in the kat folder and if it sis present then print the echo statement
find kat -name dok.txt -exec bash -c 'echo -e "\nAutor: Jan Kowalski" >> {}' \;

search for the file "file" in current folder and save the output to the same file
find -name file -fprint file

search for the file "file" in the current folder excluding those in the sub directory ".git"
find . -path ./.git  -prune -o -name file  -print

search for the file "file_name" in the folder /path
find /path -name file_name

search for the file "filename" in the entire file system
find / -name filename

search for the files "foo.txt" in the current folder
find . -name foo.txt

search for the files "foo.txt" in the current folder and rename it to foo.xml
find -name foo.txt -execdir rename 's/\.txt$/.xml/' '{}' ';'

search for the file "foo.txt" in the entire file system
find / -name foo.txt

search for the file "foobar.txt" in the folder "/home/mywebsite"
find /home/mywebsite -type f -name "foobar.txt"

search for the file "job.history" in the folder /data/Spoolln and search for multiple patterns in the file and display the count of matched lines along with the pattern
find /data/SpoolIn -name job.history | xargs grep -o -m 1 -h 'FAIL\|ABOR' | sort | uniq -c

search for the file "myfile" in the current folder and display all errors apart from permission denied error
find . -name myfile |& grep -v 'Permission denied'

search for the file "myletter.doc" in the home folder
find ~ -name myletter.doc -print

search for the file "process.txt" in the current folder (case insensitive search)
find . -iname 'process.txt' -print

search for the file "program.c" in the entire file system and save the errors to the file errors.txt
find / -name 'program.c' 2>errors.txt

search for the file centos in /usr folder ( case insenstive search )
find /usr -iname centos

search for the file chapter1 in the folder /work
find /work -name chapter1

search for the file, filename.txt in the current folder
find . -name filename.txt

search for the file, filename.txt in the current folder ( case insensitive search )
find . -iname filename.txt

search for the file, filename.txt in the folder /home
find /home -name filename.txt

search for the file foo.txt in the entire file system
find / -name foo.txt

search for the file foo in  the current folder and display a long listing of it in sorted order of modification date
find . -name foo | xargs ls -tl

search for the files in the current folder which begin with the word "kt" followed by a digit
find . -name 'kt[0-9] '

search for the file in the entire file system which has the words "filename" in its name
find / -name ”*filename*”

search for the file test in the current folder
find . -name test

search for the file test2 in the current folder
find -name test2

search for the files which contain the word start in their name excluding search in ./proc, ./sys, ./run folders
find . -path ./proc -prune -or -path ./sys -prune -or -path ./run -prune  -or -iname '*start*' -print

search for the files with the name "temp" and which have not been accessed in the last 7*24 hours in the /usr folder
find /usr -name temp -atime +7 -print

search for the folder .dummy in the entire directory structure of "test folder" and remove it.
find -depth "Test Folder" -type d -name .dummy -exec rm -rf \{\} \;

search for the ip "192.168.1.5" in all the files in /etc folder
find /etc/ -iname "*" | xargs grep '192.168.1.5'

Search for the literal string 'v$process' in all files under current directory
find . -print|xargs grep v\$process

search for the host "slc02oxm.us.oracle.com" in all the xml files in the current folder and display the files which has the matched content
find -name “*.xml” -exec grep -l “slc02oxm.us.oracle.com” {} \;

Search for the pattern '^use strict' in all *.pl files under current directory
find . -name '*.pl' | xargs    grep -L '^use strict'

Search for the pattern 'search string' in all the files in the ''/tmp folder and display the matched lines along with the file names
find /tmp -type f -exec grep 'search string' '{}' /dev/null \+

Search for the regex "\$wp_version =" in all the regular files that end with '/wp-includes/version.php' (case insensitive) in their paths in directories/files taken from the glob pattern '/home/*//public_html/' and show the matched lines along with the file names
find /home/*/public_html/ -type f -iwholename "*/wp-includes/version.php" -exec grep -H "\$wp_version =" {} \;

Search for the regex $greppattern in all files with '.c' or '.h' extension under $searchpath with name pattern $filepat and show the matched line numbers, file names and matched lines
find "$searchpath" -name "$filepat.[ch]" -exec grep --color -aHn "$greppattern" {} \;

Search for the regex '->get(\|#hyphenate' in all files with '.pl' or '.pm' extension under '/users/tom' directory tree and only show the filenames
find /users/tom -name '*.p[lm]' -exec grep -l -- '->get(\|#hyphenate' {} +

Search for the regex '[0-9][0-9]*[.][0-9][0-9]*[.][0-9][0-9]*[.][0-9][0-9]*' in all files under /etc
find /etc -exec grep '[0-9][0-9]*[.][0-9][0-9]*[.][0-9][0-9]*[.][0-9][0-9]*' {} \;

Search for the regex '^ERROR' in all *.log files under current directory
find . -name "*.log" -exec egrep -l '^ERROR' {} \;

Search for the regex '^aaa$' in all *.txt files under current directory and count the number of matches
( find . -name '*.txt' -exec cat {} ';' ) | sed 's/ /\n/g' | grep '^aaa$' | wc -l

Search for the regex 'pattern_to_search' in all files under '/directory/containing/files' and show the matched lines as well as the file names
find /directory/containing/files -type f -exec grep -H 'pattern_to_search' {} +

Search for the regex ... in the manual of the find command
man find | grep ...

Search for the regex \s1$ in all files under current directory
find . -type f -exec perl -wnl -e '/\s1$/ and print' {} +

Search for the regex ^catalina in the first line of each file under current directory
find -type f | xargs head -v -n 1 | grep -B 1 -A 1 -e '^catalina'

Search for the regex expanded by the variable $SEARCH in all regular files under $DIR directory tree
find "$DIR" -type f -exec grep -q "$SEARCH" {} + ;

Search for the regex expaned by the variable $SEARCH in all regular files under $DIR directory tree
find "$DIR" -type f -exec grep "$SEARCH" {} \;

search for the regular/normal file "Dateiname" in the entire file system
find / -type f -iname "Dateiname"

search for the regular/normal file "foo.bar" and force delete it
find /home -name foo.bar -type f -exec rm -f "{}" ';'

search for the regular/normal file "myfile" in the current folder excluding search in the paths of "work" and "home" sub directories
find .  \( -name work -o -name home \)  -prune -o -name myfile -type f -print

search for the regular/normal file java in the entire file system excluding search in the directories share and those starting with 10_Recommended and discard all the errors
find / \( -name 10_Recommended* -o -name share \) -prune -o -type f -name java -print 2>/dev/null

search for the regular/normal file firefox or thunderbird or seamonkey in the entire file system excluding search in the directories share and those starting with 10_Recommended and discard all the errors
find / \( -name 10_Recommended* -o -name share \) -prune -o -type f \( -name firefox -0 -name thunderbird -0 -name seamonkey \) -print 2>/dev/null

search for the regulars file starting with HSTD which have been modified yesterday from day start and copy them to /path/tonew/dir
find . -type f -iname ‘HSTD*’ -daystart -mtime 1 -exec cp {} /path/to new/dir/ \;

Search for the string "ERROR" in all XML files in the current working directory tree
find . -name "*.xml" -exec grep "ERROR" /dev/null '{}' \+

Search for the string 'device' in all regular files in the entire filesystem
find / -type f -print | xargs grep "device"

Search for the string 'foo' in *.html files under /usr/src/linux directory
grep foo `find /usr/src/linux -name "*.html"`

Search for the string 'git' in all the files under current directory tree excluding paths and names that contain the string 'git'
find . -not -path "*git*" -not -name '*git*' |grep git

Search for the string 'git' in all the files under current directory tree without traversing into '.git' folder and excluding files that have 'git' in their names
find . -path ./.git -prune -o -not -name '*git*' -print |grep git

Search for the string 'magic' in all regular files under current directory tree and display long listing of them
find . -type f -exec grep "magic" {} \; -ls

Search for the string 'nameserver' in all files under /etc
find /etc -type f -print0 2>/dev/null | xargs -0 grep --color=AUTO -Hn 'nameserver' 2>/dev/null

search for the word "foo" in all the regular/normal files with the name "file-pattern" in the directory "/path/to/dir"
find /path/to/dir/ -type f -name "file-pattern" -print0 | xargs -I {} -0 grep -l "foo" "{}"

search for the word "methodNameHere" in all the python files in the folder "/mycool/project/" and display color on the matched lines in the output
find /mycool/project/ -type f -name "*.py" -print0 | xargs -I {} -0 grep -H --color "methodNameHere" "{}"

search for the word "mysql" in all the files in the current containing the word "notes" in their name
find . -iname "*notes*" | xargs grep -i mysql

search for the word "mysql" in all the files in the current containing the word "notes" in their name. print0 is used to handle files  with newlines in their names or those which have only spaces in their names
find . -iname "*notes*" -print0 | xargs -I{} -0 grep -i mysql "{}"

search for the word "nameserver" in all the configuration files of the /etc folder
find /etc/ -type f -name "*.conf" -print0 | xargs -I {} -0 grep "nameserver" "{}"

search for the word "nameserver" in all the regular/normal files in the /etc directory and display the name of the file along with the matched line
find /etc/ -iname "*" -type f -print0 | xargs -0 grep -H "nameserver"

search for the word "put" in all the files in the current folder which have the word "bills" in their name and display the matched line along with the filename.
find . -name '*bills*' -exec grep -H "put" {} \;

search for the word "redeem reward" in all the regular/normal files in the current folder
find . -type f -exec grep -i “redeem reward” {} \; -print

search for the word "redeem reward" in all the regular/normal files in the current folder and discard all the errors
find . -type f -exec grep -i “redeem reward” {} \; -print 2>/dev/null

search for the word "slrn" in all the files in the current folder
find ./ -exec grep -q 'slrn' '{}' \; -print

search for the word "slrn" in all the files in the folder $HOME/html/andrews-corner
find $HOME/html/andrews-corner -exec grep -q 'slrn' '{}' \; -print

search for the word bananas in the all the regular/normal files in the entire file system
find / -type f -exec grep bananas {} \; -print

search for the word error in all the xml files in the current folder
find . -name "*.xml" -exec grep "ERROR" /dev/null '{}' \+

search for the word text in all the python files in the current folder
find . -iname '*py' -exec grep "text" {} \;

search for the word echo all the bash files(files ending with .bash) in the current folder
find . -name "*.bash" |xargs grep "echo"

Search for utility "foo" in PATH, display its file type description.
file $(which foo)

search for version in system.info files.
find /home/*/public_html/ -type f -iwholename "*/modules/system/system.info" -exec grep -H "version = \"" {} \;

search for word linux in all the regular/normal files in the folder mail.
find ~/mail -type f | xargs grep "Linux"

Search for xception in all *auth*application* files under current directory and count the number of matches
zegrep "xception" `find . -name '*auth*application*'` | wc -l

Hash hostnames in user's known hosts file.
ssh-keygen -Hf ~/.ssh/known_hosts

search in all the directories of the folder /PROD for JSON files and send them as input to the python file /tmp/test.py
find /PROD -type d -exec sh -c 'cd "{}" && for f in *.json; do /tmp/test.py "$f"; done' \;

search in all the regular/normal files of the current folder for the word "word" and display the matched file name
find . -type f -exec grep -l "word" {} +

Search in current directory downwards all files whose owner is aa1 and grop is grp .
find .  \( -user aa1 - group grp \) -print

Search  in current directory downwards all files whose size is 10 blocks .
find .  -size 10 print

Search  in current directory downwards all files whose size is greater than 10 bytes .
find . -size +10c -print

Search  in current directory downwards all files which  have not been accessed since last 7 days
find . -atime +7 -print

search  in current directory downwards all files which were accessed exactly 7 days back
find . -atime 7 -print

search in current directory downwards all files whose size is less then 10 bytes
find .  -size -10c -print

search  in current directory downwards all files whose status has changed more then 7  days ago
find .  -ctime +7 -print

Serach  in root directory all files which  have more than 2 links.
find / -links +2 -print

search  in root ( / ) directory downwards all files which  have exactly 2 links.
find /  -links 2 -print

search  in root  ( / ) directory downwards all files which have less than 2 links.
find / -links -2 -print

search in the home folder for all the files with the name "monfichier"
find /home/ -name monfichier

Search in the current directory and all sub-directories except ./D and any further sub-directories also named D for the file named hi.dat
$ find . \( -name D -prune \) -o -name hi.dat

Search in the current directory and all sub-directories except ./D for the file hi.dat using the extending file-globbing features of the shell.
shopt -s extglob find !(D) -name hi.dat

Search in the current directory and all sub-directories except ./D for the file named hi.dat
find -path ./D -prune -o -name hi.dat -print

Search in the current directory and all sub-directories except ./D for the file named hi.dat.
find . \( -name D -prune \) -o -name hi.dat

search in the current folder for all the directories with the name "test"
find . -type d -name test

search in the current folder for all the text files and display their names
find . -type f -name "*.txt" -exec printf "File: %s\n" {} \;

search in the current folder for all the regular/normal file with the name "test"
find . -type f -name test

search in the current folder for the file "myletter.doc"
find . -name myletter.doc -print

search in the current folder for the files that begin with "myletter"
find . -name 'myletter*' -print

search in the current folder for the file with the name "test"
find . -name test

search in the current folder for the file with the name "test" ( case insensitive search )
find . -iname test

search in the entire file system for the files firefox, thunderbird, seamonkey and display all the files expect those having the words "10_Recommended" or "repo" (discard all the errors during search)
sudo find / ( -name firefox -o -name thunderbird -o -name seamonkey \) -type f 2>/dev/null|grep -v '(10_Recommended|repo)'

Search level 3 of the current directory tree for the directories whose pathnames contain "New Parts"
find -mindepth 3 -maxdepth 3 -type d | grep "New Parts"

Search non-recursively directory tree `MyApp.app' for directories whose name is 'Headers' and delete them in an optimized way
find MyApp.app -name Headers -type d -prune -exec rm -rf {} +

Search only for directories
find -type d

Search only for regular files
find -type f

Catch output from a script printing to /dev/tty
screen -D -m yourEvilProgram

Search PATH for utilities called "rename", display the type of file (script, executable, ...) for each match found.
which -a rename | xargs file -L

Search PATH for utilities called "rename", display the type of file (script, executable, ...) for each match found.
which -a rename | xargs readlink -f | xargs file

Search regular files under ~/mail for string "Linux"
find ~/mail -type f | xargs grep "Linux"

Search recursively through /mydir, outputting only the base (leaf) name of each file, directory, symlink etc. without any containing directories, that is the part following the last slash.
find /mydir | xargs -I{} basename {}

Search subdirectory `Linux' in the current directory for file `teste.tex'
find -path './Linux/*' -name teste.tex

Search the "data" directory tree for files matching pattern 'filepattern-*2009*' and save the result as 'filesOfInterest.txt'
find data/ -name filepattern-*2009* -print > filesOfInterest.txt

Search the "katalogi" directory tree for files named "wzorzec"
find katalogi -name wzorzec

Search the "test1" directory recursively for regular files
find test1 -type f -print

Search the "test1" directory recursively for regular files named "textfile.txt"
find test1 -type f -name 'textfile.txt' -print

Search the "your/dir" directory for empty subdirectories
find your/dir -mindepth 1 -prune -empty

Search the `images' directory tree for regular files
find images/ -type f

Search the `research' directory and one level below for directories that are not owned by group `ian'
find -L research -maxdepth 2 -type d ! -group ian

Search the 'tmp' directory for .mp3 files
find tmp -maxdepth 1 -name '*.mp3'

Search the *.cc files in the current directory tree for string "xxx"
find . -name "*.cc" -print -exec grep "xxx" {} \;

Search the *.cc files in the current directory tree for string "xxx"
find . -name "*.cc" | xargs grep "xxx"

Search the *.code files from the current directory tree for string 'pattern'
find . -name '*.code' -exec grep -H 'pattern' {} +

Search the *.code files from the current directory tree for string 'pattern'
find . -name '*.code' -print0 | xargs -0 grep -H 'pattern'

Search the *.pdf files from directory tree PDFs/ for text "perry sound", ignoring the case
find PDFs/ -name '*.pdf' -exec sh -c 'pdftotext "{}" - | grep -C 2 -i --with-filename --label="{}" --color "perry sound"' \;

Search the *.pdf files from directory tree PDFs/ for text "perry sound", ignoring the case
find PDFs/ -name '*.pdf' -exec sh -c 'pdftotext "{}" - | grep -i --with-filename --label="{}" --color "perry sound"' \;

Search the *.pdf files from directory tree PDFs/ for text "perry sound", ignoring the case, and print the list of matched files
find PDFs/ -name '*.pdf' -exec sh -c 'pdftotext "{}" - | grep -l -i --with-filename --label="{}" --color "perry sound"' \;

Search the *.txt files from the current directory tree for "string"
find . -name "*.txt" -print0 | xargs -0 egrep 'string'

Search the ./bin directory recursively for files called "cp"
find ./bin -name “cp”

Search the .VER files from the current directory tree for Perl regular expression "Model-Manufacturer:.\n."
find . -name "*.VER" -exec grep -P 'Model-Manufacturer:.\n.' '{}' ';' -print

Search the .css files in the /starting/directory tree for ".ExampleClass"
find /starting/directory -type f -name '*.css' | xargs -ti grep '\.ExampleClass' {}

Search the .java files from the /Applications/ directory tree for TODO lines
find /Applications/ -name "*.java" -exec grep -i TODO {} +

Search the .java files from the /Applications/ directory tree for TODO lines
find /Applications/ -name "*.java" -exec grep -i TODO {} \;

Search the .java files from the /Applications/ directory tree for TODO lines
find /Applications/ -name "*.java" -print0 | xargs -0 grep -i "TODO"

Search the .log files in the current directory tree for string "The SAS System"
find `pwd` -name "*.log" -exec grep "The SAS System" {} \;

Search the .py files residing in the current directory tree for "something" and save the output to output.txt
find . -name '*.py' -exec grep 'something' {} \; > output.txt

Search the /Applications directory tree for *.app directories
find /Applications -type d -name "*.app"

Search the /Path directory tree for files matching pattern "file_name*"
find /Path -name "file_name*"

Search the /Path directory tree for files matching pattern "file_name*" and containing "bar" in their pathnames
find /Path -name "file_name*" | grep "bar"

Search the /Path directory tree for files whose pathnames match "/Path/bar*" or "/Path/foo*" and whose names match pattern "file_name*"
find /Path \( -path "/Path/bar*" -o -path "/Path/foo* \) -name "file_name*"

Search the /Path directory tree for files whose pathnames match pattern "/Path/bar*" and whose names match pattern "file_name*"
find /Path -path "/Path/bar*" -name "file_name*"

Search the /Path/bar* directories recursively for files matching pattern "file_name*"
find /Path/bar* -name "file_name*"

Search the /dir directory tree for files whose names match regular expression '.*2015.*\(album.*\|picture.*\)'
find /dir -regex '.*2015.*\(album.*\|picture.*\)'

Search the /dir directory tree for files whose names match regular expression '2015.*(album|picture)'
find /dir|egrep '2015.*(album|picture)'

Search the /etc directory tree for files accessed within the last 24 hours
find /etc -atime -1

Search the /etc directory tree for symbolic links
find /etc -type l -print

Search the /etc/apache-perl directory tree for files newer than /etc/apache-perl/httpd.conf
find /etc/apache-perl -newer /etc/apache-perl/httpd.conf

Search the /home/bozo/projects directory tree for files modified within the last 24 hours
find /home/bozo/projects -mtime 1

Search the /home/sdt5z/tmp directory tree for files named "accepted_hits.bam"
find /home/sdt5z/tmp -name "accepted_hits.bam"

Search the /home/test directory tree for directories and files called '.ssh'
find /home/test -name '.ssh'

Search the /home/user1 directory tree for files whose names end in ".bin"
find /home/user1 -name "*.bin"

Search the /home/weedly directory tree for regular files named myfile
find /home/weedly -name myfile -type f -print

Search the /home/www directory tree for regular files
find /home/www -type f

Search the /media/shared directory recursively for MP3 and OGG files
find /media/shared \( -iname "*.mp3" -o -iname "*.ogg" \)

Search the /mnt/raid/upload directory tree for files that have not been modified within the last 5 days
find /mnt/raid/upload -mtime +5 -print

Search the /mnt/raid/upload directory tree for files that have been modified within the last 7 days
find /mnt/raid/upload -mtime -7 -print

Search the /myfiles directory tree for files last accessed more than 30 days ago
find /myfiles -atime +30

Search the /myfiles directory tree for files last modified 2 days ago
find /myfiles -mtime 2

Search the /myfiles directory tree for files that are 5 512 byte blocks in size
find /myfiles -size 5

Search the /myfiles directory tree for files whose names contain "blue"
find /myfiles -name '*blue*'

Search the /myfiles directory tree for regular files with at least these permissions: 647
find /myfiles -type f -perm -647

Search the /path directory recursively for TXT files
find /path -type f -iname "*.txt"

Search the /path directory tree for files having permissions 777
find /path -perm ugo+rwx

Search the /path directory tree for files matching pattern '*.foo'
find /path -name '*.foo'

Search the /path directory tree for files missing g+w and o+w bits
find /path ! -perm /022

Search the /path directory tree for files that do not have a valid user or group
find /path -nouser -or -nogroup

Search the /path directory tree for regular files
find /path -type f

Search the /path tree for all executables
find /path -perm /ugo+x

Search the /path/to/dir directory tree for .c files
find /path/to/dir -name \*.c

Search the /path/to/directory tree for regular files modified 61 days ago and then remove them
find /path/to/directory -type f -mtime 61 -exec rm -f {} \;

Search the /root directory recursively for files named "FindCommandExamples.txt"
find /root -name FindCommandExamples.txt

Search the /root directory recursively for the regular file named "myfile"
find /root/ -name myfile -type f

Search the /root directory recursively for the regular file named "myfile" ignoring "work" directories
find /root/ -name 'work' -prune -o -name myfile -type f -print

Search the /root directory recursively for the regular file named "myfile" ignoring /root/work/
find /root/ -path '/root/work' -prune -o -name myfile -type f -print

Search the /storage/sdcard0/tencent/MicroMsg/ directory tree for JPG files
find  /storage/sdcard0/tencent/MicroMsg/ -type f  -iname '*.jpg' -print0

Search the /tmp directory tree for files owned by user `ian'
find /tmp -user ian

Search the /tmp tree for files between 10kb and 20kb
find /tmp -size +10k -size -20k

Search the /tmp/ directory recursively for files matching regular expression ".*file[0-9]+$"
find /tmp -regex ".*file[0-9]+$"

Search the /tmp/ directory recursively for regular files
find /tmp -type f

Search the /usr/bin directory tree for regular files accessed more than 100 days ago
find /usr/bin -type f -atime +100

Search the /usr/bin directory tree for regular files modified or created less than 10 days ago
find /usr/bin -type f -mtime -10

Search the /usr/local/doc directory tree for .texi files
find /usr/local/doc -name '*.texi'

Search the /var/www/ tree for files owned by root or unknown group and change their group to 'apache'
find /var/www -group root -o -nogroup -print0 | xargs -0 chown :apache

Search the /var/www/ tree for files not owned by user `apache'
find /var/www ! -user apache -print0 | xargs -0

Search the CSS files found in the current directory tree for string "foo"
find . -name \*.css -print0 | xargs -0 grep -nH foo

Search the current directory and all of its sub-directory for any PDF files.
find . -name "*.pdf" -print

Search the current directory and all of its sub-directory for any PDF files being careful to prevent the shell from expanding "*"  before it's passed to find.
find . -name \*.pdf -print

Search the current directory and all of its sub-directories for the file 'file1'.
find . -name file1 -print

Search the current directory and directories below for .sql files
find . -name \*.sql

Search the current directory and its sub-directories for any file that has "bsd" somewhere in its name.
find . -name "*bsd*" -print

Search the current directory and two levels below for file `teste.tex'
find ~/ -maxdepth 3 -name teste.tex

Search the current directory, except the subdirectory tree ".svn", for files whose name is "foo.cpp"
find . -name 'foo.cpp' '!' -path '.svn'

Search the current directory for *rc.conf files and grant "other" users read permission
find `pwd` -name "*rc.conf"  -execdir /bin/chmod o+r {} \;

Search the current directory for all files with no 'read' privilege for 'others'
find . -maxdepth 1 ! -perm  -o=r

Search the current directory for all regular files executable by 'user', 'group', and 'others'
find . -maxdepth 1 -type f -perm -ugo=x

Search the current directory for files whose names start with my
find . -name 'my*'

Search the current directory for files whose names start with "messages." ignoring SVN files
find \( -name 'messages.*' ! -path "*/.svn/*" \) -exec grep -Iw uint {} +

Search the current directory for files whose names start with "messages." ignoring SVN, GIT, and .anythingElseIwannaIgnore files
find -name 'messages.*' -exec grep -Iw uint {} + | grep -Ev '.svn|.git|.anythingElseIwannaIgnore'

Search the current directory for files whose names start with "messages." ignoring SVN, GIT, and .anythingElseIwannaIgnore files
find . -type f -print0 | xargs -0 egrep messages. | grep -Ev '.svn|.git|.anythingElseIwannaIgnore'

Search the current directory for HTML files whose names begin with "a"
find . -maxdepth 1 -name a\*.html

Search the current directory for PHP files
find . -type f -name "*.php"

Search the current directory for regular files whose names start with my
find . -name 'my*' -type f

Search the current directory recursively for .m4a files
find . -type f -iname *.m4a -print

Search the current directory recursively for directories with the execute permission set for everybody
find -type d ! -perm -111

Search the current directory recursively for text files containing at least one character
find -type f -exec grep -Iq . {} \; -and -print

Search the current directory recursively for text files containing at least one character
find . -type f -exec grep -Iq . {} \; -and -print

Search the current directory recursively for files containing "needle text"
find . -type f -exec grep -Iq . {} \; -and -print0 | xargs -0 grep "needle text"

Search the current directory recursively for files containing "needle text"
find . -type f -print0 | xargs -0 grep -I "needle text"

Search the current directory recursively for files containing "needle text"
find . -type f -print0 | xargs -0 grep -IZl . | xargs -0 grep "needle text"

Search the current directory recursively for files containing "needle text"
find . -type f | xargs grep -I "needle text"

Search the current directory recursively for files containing "string"
find . -type f -exec grep -l 'string' {} \;

Search the current directory recursively for files last modified within the past 24 hours
find . -mtime 0

Search the current directory recursively for files last modified within the past 24 hours ignoring .swp files and "en" and "es" directories
find . \( -name en -o -name es \) -prune , -mtime 0 ! -name "*.swp"

Search the current directory recursively for files last modified within the past 24 hours ignoring .swp files and paths ./es* and ./en*
find "$(pwd -P)" -mtime 0 -not \( -name '*.swp' -o -regex './es.*' -o -regex './en.*' \)

Search the current directory recursively for files last modified within the past 24 hours ignoring .swp files and paths ./es* and ./en*
find -mtime 0 -not \( -name '*.swp' -o -path './es*' -o -path './en*' \)

Search the current directory recursively for files last modified within the past 24 hours ignoring .swp files and paths ./es* and ./en*
find . -mtime 0 -not \( -name '*.swp' -o -regex '\./es.*' -o -regex '\./en.*' \)

Search the current directory recursively for files last modified within the past 24 hours ignoring .swp files and paths ./es* and ./en*
find . -mtime 0 | grep -v '^\./en' | grep -v '^\./es' | grep -v .swp

Search the current directory recursively for files last modified within the past 24 hours ignoring paths ./es* and ./en*
find . -mtime 0 | grep -v '^\./en' | grep -v '^\./es'

Search the current directory recursively for files whose size is between 10 and 50 MB
find . -size +10M -size -50M -print

Search the current directory recursively for files with the exact permissions u=rwx,g=rx,o=rx
find . -perm a=rwx,g-w,o-w

Search the current directory recursively for files with the exact permissions u=rwx,g=rx,o=rx
find . -perm u=rwx,g=rx,o=rx

Search the current directory recursively for files writable for `others'
find . -perm -o+w

Search the current directory recursively for MOV files
find . -iname *.mov

Search the current directory recursively for MOV files, following symlinks
find . -iname "*.mov" -follow

Search the current directory recursively for regular files last accessed 2 minutes ago
find . type -f -amin 2

Search the current directory recursively for regular files last accessed more than 2 days ago
find . type -f -atime +2

Search the current directory recursively for regular files last accessed less than 2 days ago
find . type -f -atime -2

Search the current directory recursively for regular files last changed 2 days ago
find . type -f -ctime 2

Search the current directory recursively for regular files last changed more than 2 days ago
find . type -f -ctime +2

Search the current directory recursively for regular files last changed less than 2 days ago
find . type -f -ctime -2

Search the current directory recursively for regular files last modified more than 2 days ago
find . type -f -mtime +2

Search the current directory recursively for regular files last modified less than 2 days ago
find . type -f -mtime -2

Search the current directory recursively for regular files modified 2 days ago
find . type -f -mtime 2

Search the current directory recursively for regular files, skipping hidden files in the current directory
find * -type f -print

Search the current directory recursively for regular files that have been changed less than 3 days ago and print 5 of them.
find . -type f -ctime -3 | tail -n 5

Search the current directory recursively for regular files with extensions sdw, sdc, sdd and save the search result as "list_1"
find . -type f | egrep '(sdw|sdc|sdd)$' > list_1

Search the current directory recursively for regular files with the extension given as variable $extension
find . -type f -name "*.$extension"

Search the current directory recursively for regular files with the read permission set for everybody
find -type f ! -perm -444

Search the current directory recursively for the largest files
find . -type f -printf '%20s %p\n' | sort -n | cut -b22- | tr '\n' '\000' | xargs -0 ls -laSr

Search the current directory tree for *.c and *.asm files, ignoring the case
find . -type f \( -iname "*.c" -or -iname "*.asm" \)

Search the current directory tree for *.c and *.sh files
find . -type f \( -name "*.c" -o -name "*.sh" \)

Search the current directory tree for *.conf and *.txt files
find . -type f \( -name "*.conf" -or -name "*.txt" \) -print

Search the current directory tree for *.wav files that have "export" in their pathnames
find -type f -name "*.wav" | grep export

Search the current directory tree for *cache, *xml, and *html files
find . -type f \( -name "*cache" -o -name "*xml" -o -name "*html" \)

Search the current directory tree for .aux files
find . -name ".aux"

Search the current directory tree for .log files containing the string "The SAS System", and save their names to sas_log_list.txt
find . -name "*.log" -exec grep -l "The SAS System" {} \; > sas_log_list.txt

Search the current directory tree for .rb files ignoring the "./vendor" subdirectory
find . -name '*.rb' ! -wholename "./vendor/*" -print

Search the current directory tree for a regular file named "file_name"
find . -type f -name file_name

Search the current directory tree for all .java files newer than the file build.xml
find . -name '*.java' -newer build.xml -print

Search the current directory tree for all .java files that were last modified at least 7 days ago
find . -name '*.java' -mtime +7 -print

Search the current directory tree for all files except SVN ones
find .  ! -regex ".*[/]\.svn[/]?.*"

Search the current directory tree for all files except SVN ones
find . -not -iwholename '*.svn*'

Search the current directory tree for all files except SVN ones
find . | grep -v \.svn

Search the current directory tree for all files matching either pattern "*.rb" or pattern "*.py"
find . -name "*.rb" -or -name "*.py"

Search the current directory tree for all files matching pattern "*.rb"
find . -name "*.rb"

Search the current directory tree for all files matching regular expression ".*\.rb$"
find . -regex ".*\\.rb$"

Search the current directory tree for all image files
find . -type f -regex ".*\.\(jpg\|jpeg\|gif\|png\|JPG\|JPEG\|GIF\|PNG\)"

Search the current directory tree for all regular files matching pattern "*.rb"
find . -name "*.rb" -type f

Search the current directory tree for all regular non-hidden files except *.o
find ./ -type f -name "*" -not -name "*.o"

Search the current directory tree for an html file having the text 'Web sites' in it
find . -type f -iname \*.html -exec grep -s "Web sites" {} \;

Search the current directory tree for directories
find "$PWD" -type d

Search the current directory tree for directories
find $PWD -type d

Search the current directory tree for directories lacking execute permissions for user, group, or others
find . -type d ! -perm -111

Search the current directory tree for directories that can be opened by noone
find -type d ! -perm -111

Search the current directory tree for executable files
find . -type f -executable -print

Search the current directory tree for executable files and searchable directories
find -executable

Search the current directory tree for executable regular files
find . -executable -type f

Search the current directory tree for executable regular files
find . -type f -executable -exec file {} \; | grep -wE "executable|shared object|ELF|script|a\.out"

Search the current directory tree for files and directories called "test"
find . -name test -print

Search the current directory tree for files and directories whose names begin with "pro"
find . -name pro\*

Search the current directory tree for files and directories whose names do not end in "exe" and "dll"
find . | grep -v '(dll|exe)$'

Search the current directory tree for files and directories with permissions 775
find .  -perm 775 -print

Search the current directory tree for files containing "album" and "vacations" in their names and not containing "2015"
find . -name "*album*" -a -name "*vacations*" -a -not -name "*2015*"

Search the current directory tree for files containing "needle" in their names
find . -iname "*needle*"

Search the current directory tree for files containing "string" in their path names
find | egrep string

Search the current directory tree for files AAA and BBB
find . \( -name AAA -o -name BBB \) -print

Search the current directory tree for files executable by at least someone
find . -type f -perm +111 -print

Search the current directory tree for files executable by at least someone
find . -type f \( -perm -u=x -o -perm -g=x -o -perm -o=x \) -exec test -x {} \; -print

Search the current directory tree for files larger than 10MB but smaller than 50MB
find . -size +10M -size -50M -print

Search the current directory tree for files last accessed more than 10 days ago
find . -atime +10

Search the current directory tree for files matching sed regular expression '.*myfile[0-9]\{1,2\}'
find . -regextype sed -regex '.*myfile[0-9]\{1,2\}'

Search the current directory tree for files matching regular expression '.*myfile[0-9][0-9]?'
find . -regex '.*myfile[0-9][0-9]?'

Search the current directory tree for files matching regular expression '^myfile[0-9][0-9]?$'
find . -\( -name "myfile[0-9][0-9]" -o -name "myfile[0-9]" \)

Search the current directory tree for files modified less than 5 days ago
find . -mtime -5

Search the current directory tree for files named "accepted_hits.bam"
find . -name "accepted_hits.bam"

Search the current directory tree for files named "accepted_hits.bam"
find `pwd` -name "accepted_hits.bam"

Search the current directory tree for files named "somename", case insensitive
find -iname 'somename'

Search the current directory tree for files that are less than 50kb
find . -size -50k

Search the current directory tree for files whose names are not "a.txt"
find . ! -name "a.txt" -print

Search the current directory tree for files whose names begin with "my" and end with "p" followed by any character, ignoring path names containing "test"
find . -regex ".*/my.*p.$" -a -not -regex ".*test.*"

Search the current directory tree for files whose names begin with 'my'
find . -name 'my*'

Search the current directory tree for files whose names contain "TextForRename"
find ./ -name "*TextForRename*"

Search the current directory tree for files whose names end in "rb" or "js"
find . -name "*js" -o -name "*rb"

Search the current directory tree for files whose names end in "rb" or "js"
find . -regextype posix-egrep -regex ".*(rb|js)$"

Search the current directory tree for files whose names end in "rb" or "js" and which contain string "matchNameHere"
find . -regextype posix-ergep -regex ".*(rb|js)$" -exec grep -l matchNameHere {} \;

Search the current directory tree for files whose name is ".note", case insensitive
find -type d -exec find {} -maxdepth 1 \! -type d -iname '.note' \;

Search the current directory tree for files whose name is ".note", case insensitive
find . -iname '.note'

Search the current directory tree for files whose name is ".note", case insensitive
find . -iname '.note' | sort

Search the current directory tree for files whose name is ".note", case insensitive
find . -iname '.note' | sort -r

Search the current directory tree for files whose names do not end in ".exe" and ".dll"
find . -not -name "*.exe" -not -name "*.dll" -not -type d

Search the current directory tree for files whose names do not end in ".exe" and ".dll"
find . -not -name "*.exe" -not -name "*.dll" -type f

Search the current directory tree for files whose names do not end in "1" and "2"
find . -type f ! -name "*1" ! -name "*2" -print

Search the current directory tree for files without "test" in their path names
find . -not -regex ".*test.*"

Search the current directory tree for filenames matching the pattern '[mM][yY][fF][iI][lL][eE]*'
find . -name '[mM][yY][fF][iI][lL][eE]*'

Search the current directory tree for file "a.txt"
find . -name "a.txt" -print

Search the current directory tree for hidden files
find .*

Search the current directory tree for hidden files skipping .htaccess
find . -type f \( -iname ".*" ! -iname ".htaccess" \)

Search the current directory tree for PHP files changed less than 14 days ago
find . -name *.php -ctime -14

Search the current directory tree for regular .mkv files
find . -type f -name "*.mkv"

Search the current directory tree for regular files changed less than 1 day ago
find . -type f -ctime -1

Search the current directory tree for regular files changed on the 10th of September
find ./ -type f -ls |grep '10 Sep'

Search the current directory tree for regular files last changed more than 14 days ago
find -type f -ctime +14

Search the current directory tree for regular files modified within the past 24 hours whose names do not end with ".DS_Store"
find . -mtime -1 ! -name '.DS_Store' -type f -exec basename {} \;

Search the current directory tree for regular files modified within the past 24 hours whose names do not end with ".DS_Store"
find . -mtime -1 ! -name '.DS_Store' -type f -printf '%f\n'

Search the current directory tree for regular files named `doc.txt' and print "found" for each of them
find ./ -type f -name doc.txt -printf "found\n"

Search the current directory tree for regular files omitting directory `omit-directory'
find . -name omit-directory -prune -o -type f

Search the current directory tree for regular files omitting directory `omit-directory'
find . -name omit-directory -prune -o -type f  -print

Search the current directory tree for regular files omitting directory `omit-directory'
find . \( -name omit-directory -prune -o -type f \) -print

Search the current directory tree for regular files omitting directory `omit-directory'
find . \( -name omit-directory -prune \) -o \( -type f -print \)

Search the current directory tree for regular files that contain "string"
find . -type f -print0 | xargs -0 grep string

Search the current directory tree for regular files that contain "string"
find . -type f -printf '"%p"\n' | xargs grep string

Search the current directory tree for regular files that contain "string"
find . -type f | xargs grep string

Search the current directory tree for regular files that can be read by noone
find -type f ! -perm -444

Search the current directory tree for regular files that were accessed $FTIME days ago
find . -type f -atime $FTIME

Search the current directory tree for regular files that were changed $FTIME days ago
find . -type f -ctime $FTIME

Search the current directory tree for regular files that were modified $FTIME days ago
find . -type f -mtime $FTIME

Search the current directory tree for regular files whose names end in ".shtml" or ".css"
find -type f -regex ".*/.*\.\(shtml\|css\)"

Search the current directory tree for regular files whose names end in ".shtml" or ".css"
find . -type f \( -name "*.shtml" -o -name "*.css" \) -print

Search the current directory tree for regular files whose names end in ".shtml" or ".css"
find . -type f \( -name "*.shtml" -or -name "*.css" \)

Search the current directory tree for regular files whose names end in ".shtml" or ".css"
find . -type f | egrep '\.(shtml|css)$'

Search the current directory tree for regular files whose names end in "log"
find `pwd` -name "*log" -type f

Search the current directory tree for regular files whose names end with "keep.${SUFFIX}", where $SUFFIX is a shell variable
find . -type f -name "*keep.${SUFFIX}"

Search the current directory tree for regular files whose names match pattern $x
find . -type f -name $x

Search the current directory tree for symbolic links named "link1"
find . -type l -name link1

Search the current directory tree for symbolic links to files matching pattern '*/test*'
find -P . -lname '*/test*'

Search the current directory tree for symbolic links to files matching pattern '*test*'
find . -lname '*test*'

Search the current directory tree for symlinks pointing at other symlinks
find . -type l -xtype l

Search the current directory tree for symlinks whose contents match pattern "*sysdep.c"
find . -lname '*sysdep.c'

Search the current directory tree for TXT files skipping hidden ones
find . -type f \( -iname "*.txt" ! -iname ".*" \)

Search the current directory tree for the files with extension "trc" and remove them if they are more than three days old
find . -name "*.trc" -ctime +3 -exec rm -f {} \;

Search the current directory tree for the files with extension "trc" and remove them if they are more than three days old
find . -name "*.trc" -ctime +3 -exec rm {} \;

Search the current directory tree recursively for the regular file named "myfile" ignoring "work" and "home" directories
find .  \( -name work -o -name home \)  -prune -o -name myfile -type f -print

Search the current directory up to depth level 2 for files and directories
find . -maxdepth 2

Search the current user's home directory and below for all .png files and copy those files in the directory imagesdir.
find ~/ -name *.png -exec cp {} imagesdir \;

Search the current user's home directory and its sub-directories for any files accessed after alldata.tar was last accessed and add them to that same tar archive.
find ~/ -newer alldata.tar 	-exec tar uvf alldata.tar {} \;

Search the current user's home directory and its sub-directories for any file that ends in .tar-gz and was modified after filename was last modified.
find ~/ -name *.tar.gz -newer filename

Search the current user's home directory and its sub-directories for any file that was modified less than 2 days ago or was modified after filename was last modified.
find ~/ -mtime -2 -o -newer filename

Search the current working directory tree for files whose names start with "fileA_" or "fileB_"
find . -name 'fileA_*' -o -name 'fileB_*'

Search the dir_data directory and all of its sub-directories for regular files and remove the execute permission for all while adding the write permission for the user.
find ~/dir_data -type f  -exec chmod a-x,u+w {} \;

Search the directory $path recursively for regular files with the given $extension
find $path -type f -name "*.$extension"

Search the directory given as variable $backuppath recursively for files that were last modified less than 10 days ago and save the list of them to file.list
find "${backuppath}" -mtime -10 > file.list

Search the directory given as variable $d for empty subdirectories
find "$d" -mindepth 1 -prune -empty

Search the directories matching pattern "/path/to/some/dir/*[0-9]" for level 1 subdirectories
find /path/to/some/dir/*[0-9] -type d -maxdepth 1

Search the directories that match pattern '/path/to/directory/folder{?,[1-4]?,50}' for .txt files
find /path/to/directory/folder{?,[1-4]?,50} -name '*.txt'

Search the directory tree /tmp for regular files using zero delimiter for output
find /tmp -type f -print0

search the entire file system for the file "jan92.rpt"
find / -name jan92.rpt -print

Search the entire file hierarchy for all regular files owned by olduser and change their ownership to newuser.
find / -user olduser  -type f  -exec chown newuser {} \

Search the entire file hierarchy for files ending in '.old' and delete them.
find / -name "*.old" -delete

Search the entire file hierarchy for files ending in '.old' and delete them.
find / -name "*.old" -exec /bin/rm {} \

Search the entire file hierarchy for files larger than 100 megabytes and delete them.
find / -size +100M -exec /bin/rm {} \;

Search the entire file hierarchy for files named zsh that exist on ext3 file systems and print out detailed information about the file.
find / -fstype ext3 -name zsh -ls

Search the entire file hierarchy for files named zsh that exist on ext3 file systems and print out detailed information about the file while sending anything printed to stderr to /dev/null.
find / -fstype ext3 -name zsh -ls 2> /dev/null

Search the entire file hierarchy for any file that begins with zsh and exists on the ext3 file systems.
find / -fstype ext3 -name zsh*

Search the entire file system for .jpg files.
find / -name “*.jpg”

Search the entire file system for any file that is writable by other.
find / – perm -0002

Search the entire system for SUID or SGID files
find / -path /proc -prune -o -type f -perm +6000 -ls

Search the case insensitive regex ''a.search.pattern'' in all Python files and all XML files under current directory and pipe the result in a readonly Vim session
find -iregex '.*\.py$\|.*\.xml$' | xargs egrep -niH 'a.search.pattern'  | vi -R -

Search the bla directory recursively for *.so files
find bla -name "*.so"

Search the files from directory tree "dirname" for string "foo"
find dirname  -print0 | xargs -0 grep foo

Search the files from directory tree "dirname" for string "foo"
find dirname -exec grep foo {} +

Search the files from the current directory tree for text "documentclass"
find . -type f -print0 | xargs -0 grep -H 'documentclass'

Search the files in the current directory tree for lines containing string "vds admin"
find . -exec grep -i "vds admin" {} \;

Search the files in the current directory tree that are named "string to be searched" for "text"
find . -name "string to be searched" -exec grep "text" "{}" \;

Search the files under and below /directory/containing/files for "pattern_to_search"
find /directory/containing/files -type f -exec grep -H 'pattern_to_search' {} +

Search the files under and below /directory/containing/files for "text to search"
find /directory/containing/files -type f -print0 | xargs -0 grep "text to search"

Search the files residing in the current directory tree whose names contain "bills" for "put"
find . -name "*bills*" -print0 | xargs -0 grep put

Search the files residing in the current directory tree whose names contain "bills" for "put"
find . -name '*bills*' -exec grep -H "put" {} \;

Search the files residing in the current directory tree whose names contain "bills" for "put"
find . -name '*bills*' -exec grep put {} \;

search the file "myfile.txt" in home folder
find "$HOME/" -name myfile.txt -print

search the file myfile.txt in the current folder
find . -name myfile.txt -print

Search the file hierarchy for files larger than 100000 KB without searching any mounted removable media
find / -path /media -prune -o -size +200000 -print

Search the file system for regular files whose names are shorter than 25 characters
find / -type f -regextype posix-extended -regex '.*/.{1,24}$'

Search the file system for regular files whose names are shorter than 25 characters
find / -type f | egrep '.*/.{1,24}$'

Search the file system for regular files whose names are shorter than 25 characters
find / -type f| egrep -o "/[^/]{0,24}$" | cut -c 2-

Search the file system for regular files whose names are shorter than 25 characters
find / -type f|egrep "/[^/]{0,24}$"

Search the first 300 commands in history containing "scp" and ending in "important"
history 300 | grep scp | grep important$

Search the given $directory for files with permissions stored in $permissions
find "$directory" -perm "$permissions"

Search the root directory and its subdirectories for files risiding on NTFS or VFAT filesystems
find / -maxdepth 2 \( -fstype vfat -or -fstype ntfs \) 2> /dev/null

Search the Movies folder in the user's home directory for files larger than 1024 megabytes in size.
find ~/Movies/ -size +1024M

Search the home directory for files accessed more than 10 days ago
find ~/ -atime +10

Search the home directory for files whose names begin with "test"
find ~ -name "test*" -print

Search the home directory for filenames starting with "xx" except for "xxx" files
find ~ -name 'xx*' -and -not -name 'xxx'

Search the home directory for OGG and MP3 files
find $HOME -iname '*.ogg' -o -iname '*.mp3'

Search the home directory tree for .tar.gz files newer than file "filename"
find ~/ -name *.tar.gz -newer filename

Search the home directory tree for all .txt files
find ~/ -name '*.txt'

Search the home directory tree for files last modified less than 2 days ago or newer than file "filename"
find ~/ -mtime -2 -o newer filename

Search the home directory tree for files matching pattern '*.txt'
find ~ -name *.txt

Search the home directory tree for files modified less than 7 days ago
find $HOME -mtime -7

Search the home directory tree for files modified less than a day ago
find $HOME -mtime -1

Search the home directory tree for files owned by sam
find /home -user sam

Search the home directory tree for regular files modified yesterday
find ~ -daystart -type f -mtime 1

Search the home directory tree for video files
find ~ -type f -name '*.mkv' -o -name '*.mp4' -o -name '*.wmv' -o -name '*.flv' -o -name '*.webm' -o -name '*.mov'

Search the home directory tree for video files
find ~ -type f -regex '.*\.\(mkv\|mp4\|wmv\|flv\|webm\|mov\)'

Search the path given as the $absolute_dir_path variable for regular files
find "$absolute_dir_path" -type f -print0

search the pattern ^PyErr in all the ".c" files in the folder Lib/
find Lib/ -name '*.c' -print0 | xargs -0 grep ^PyErr

Search the regular files from directory tree 'directory_name' for "word" and print the names of the matched files
find directory_name -type f -print0 | xargs -0 grep -li word

Search the regular files of the current directory tree for string "foo"
find . -type f -exec grep "foo" '{}' \;

Search the regular files of the current directory tree for string "foo"
find ./ -type f | xargs grep "foo"

Search the regular files of the current directory tree for string "stringYouWannaFind", ignoring the case
find ./ -type f -print -exec grep -n -i "stringYouWannaFind" {} \;

Search the regular files of the current directory tree for string "texthere"
find -type f -exec grep -Hn "texthere" {} +

Search the XML files from directories /res/values-en-rUS and /res/xml for string "hovering_msg"
find /res/values-en-rUS /res/xml -iname '*.xml' -print0 | xargs -0 -d '\n' -- grep -i "hovering_msg" --

Search the XML files from directories /res/values-en-rUS and /res/xml for string "hovering_msg"
find /res/values-en-rUS /res/xml -iname '*.xml' | while read file; do grep -i "hovering_msg" "$file"; done

Search the specified group for the given "filename
find / -group users -iname "filename"

Search the specified user for the given "filename"
find / -user pat -iname "filename"

Search the src/ directory recursively for .c and .h files
find src/ -name '*.[ch]'

Search the system for *.rpm files ignoring removable media
find / -xdev -name \*.rpm

Search the system for directories named "needle"
find / -type d -name "needle"

Search the system for directories named "needle" suppressing error messages
find / -type d -name "needle" 2>/dev/null

Search the system for files and directories owned by group `managers'
find / -group managers -print

Search the system for files and directories owned by user `admin'
find / -user admin -print

Search the system for files named "findcommandexamples.txt", ignoring the case
find  / -iname findcommandexamples.txt

Search the system for files whose names begin with letters 'a', 'b', or 'c'
find  / -name '[a-c]*'

Search the system for regular files whose names are "filename" ignoring the case
find / -type f -iname "filename"

Search the system for the file “testfile.txt”
find / -name "testfile.txt"

Search the system for the file “testfile.txt” ignoring the case
find / -iname "testfile.txt"

Search the system for the file 'myfile' ignoring permission denied errors
find . -name myfile |& grep -v 'Permission denied'

Search the system for the regular file 'myfile' ignoring permission denied errors
find / -name myfile -type f -print 2> /dev/null

Search the xargstest/ directory recursively for files matching pattern 'file??'
find xargstest/ -name 'file??'

Search the ~ and `Music' directory trees for .mp3 files
find ~ Music -name '*.mp3'

Search the ~/Books directory recursively for files named "Waldo"
find ~/Books -name Waldo

Search the ~/Books directory recursively for regular files named "Waldo"
find ~/Books -type f -name Waldo

search through only the /usr and /home directories for any file named Chapter1.txt
find /usr /home -name Chapter1.txt -type f

Search through the /usr directory for all files that begin with the letters Chapter, followed by anything else.
find /usr -name "Chapter*" -type f

Search through the /usr/local directory for files that end with the extension .html, and print the file locations.
find /usr/local -name "*.html" -type f

Search three folders named foo, bar, and baz for all "*.rb" files
find foo bar baz -name "*.rb"

Back up all *.txt files/directories in new files/directories with a .bak extension in their names under /etc directory
find /etc -name "*.txt" | xargs -I {} mv {} {}.bak

Back up all *.txt files/directories in new files/directories with a .bak extension in their names under /etc directory
find /etc -print0 -name "*.txt" | xargs -I {} -0 mv {} {}.bak

Search user1's home directory tree for *.bin files
find /home/user1 -name \*.bin

grep from bottom of file
tac your.log | grep stuff

grep for the last occurrence of text between two tags
tac a | grep -m1 -oP '(?<=tag>).*(?=</tag>)'

grep only regular files smaller than 10KB with the regex '\bsomeknowncontent\b'
find / -type f -size -10k 2>/dev/null -print0 | xargs -0 egrep '\bsomeknowncontent\b'

Eliminates partially duplicate lines by column, keeping the last occurrence
tac temp.txt | sort -k2,2 -r -u

Email an alert message containing the IP address of the SSH connection with attachment "tmpfile" to "user@example.com"
mail -s "Alert: SSH Access from `who | cut -d'(' -f2 | cut -d')' -f1`" -a tmpfile user@example.com

Enables 'dotglob' shell option.
shopt -s dotglob

Enables 'globstar' (recursive globbing) shell option.
shopt -s globstar

enable extglob expansion and create symbolic links in "bar2" directory to all files located in "bar1" directory that are not directory and do not have".cc" filename extension
shopt -s extglob; cd bar2; ln -s ../bar1/foo!(*.cc) .

Enables shell option 'cmdhist'.
shopt -s cmdhist

Enables shell option 'compat31'.
shopt -s compat31

Enables shell option 'expand_aliases'.
shopt -s expand_aliases

Enables shell options 'expand_aliases', 'extglob', 'xpg_echo'.
shopt -s expand_aliases extglob xpg_echo

Enables shell option 'failglob'.
shopt -s failglob

Enables shell option 'lastpipe'.
shopt -s lastpipe

Enables shell option 'lithist'.
shopt -s lithist

Enables shell option 'nocaseglob'.
shopt -s nocaseglob

Enables shell option 'nullglob'.
shopt -s execfail

Enables shell options 'nullglob' and 'dotglob'.
shopt -s nullglob dotglob

Enables shell option 'progcomp'.
shopt -s progcomp

Enables shell option 'promptvars'.
shopt -s promptvars

Sends current job to the background.
bg

Sends current job to the background.
bg %

Ensure all 5 of UEDP0{1..5}_20120821.csv files exist, creating empty files for any missing ones (updates the file's timestamps)
touch -a UEDP0{1..5}_20120821.csv

ERROR - need to add -a or -r for recursive copy
rsync --exclude='B/' --exclude='C/' . anotherhost:/path/to/target/directory

ERROR - will overwrite the executable if it's not a symlink.
sudo ln -sf /usr/local/ssl/bin/openssl `which openssl`

Evaluate the output of recursively changing the owner and group of "/data/*" to "mongodb"
`sudo chown -R mongodb:mongodb /data/*`

Revert $string value and print first 20 space-separated fields
echo $string | rev | cut -d ' ' -f -20

Query about which keys invoke the named function
bind -q complete

Query NSS entries for current hostname.
getent `uname -n`

Examines the path expanded by variable $FILENAME to see if it is a symlink and if so, sets SOURCE_DIR to the location of the link itself.
ls -l $FILENAME | grep -q ^l && SOURCE_DIR=$(ls -l $FILENAME | awk '{print $NF}');

Exclude directory from find . command
find ! -path "dir1" -iname "*.mp3"

Exclude directory from find . command
find -iname example.com | grep -v beta

Exclude directory from find . command
find -name "*.js" -not -path "./directory/*"

Exclude directory from find . command
find . -name '*.js' -and -not -path directory

Exclude directory from find . command
find . -name '*.js' | grep -v excludeddir

Exclude directory from find . command
find . -path ./misc -prune -o -name '*.txt' -print

Exclude directory from find . command
find . -type d -name proc -prune -o -name '*.js'

Exclude directory from find . command
find ./ -path ./beta/* -prune -o -iname example.com -print

Exclude directory from find . command
find build -not \( -path build/external -prune \) -name \*.js

exclude vendor and app/cache dir, and search name which suffixed with php
find . -name *.php -or -path "./vendor" -prune -or -path "./app/cache" -prune

Execute "${MD5}" on all files found under "${1}", numerically sort the results, and save to variable "DATA"
DATA=$( find "${1}" -type f -exec ${MD5} {} ';' | sort -n )

Execute "1" and write output to standard output and file "${LOG_FILE}"
exec 1 | tee ${LOG_FILE}

Execute "1" and write standard output and error to standard output and file "${LOG_FILE}"
exec 1 2>&1 | tee ${LOG_FILE}

Execute "2" and write output to standard output and file "${LOG_FILE}"
exec 2 | tee ${LOG_FILE}

Execute "bash -c 'python -m unittest discover |& pyrg'" in a shell with color support every second
watch -n 1 --color --exec bash -c 'python -m unittest discover |& pyrg'

Execute "bash -c your_script" every 2 seconds
watch bash -c your_script

Execute "cd ${REMOTE_PATH}; mkdir -p $i" on host "$SERVER" as user "$USER" and connect standard input to "/dev/null"
ssh $USER@$SERVER "cd ${REMOTE_PATH}; mkdir -p $i" < /dev/null

Execute "cd /some/directory/myprogram" in the background on target machine "user@target" and write standard output and standard error to foo.out and foo.err
ssh user@target "cd /some/directory; nohup myprogram > foo.out 2> foo.err < /dev/null"

Execute "chown -R ask:ask /www/askapache.com" in the background on server "askapache" with a niceness of 19
ssh askapache 'nice -n 19 sh -c "( ( nohup chown -R ask:ask /www/askapache.com &>/dev/null ) & )"'

Execute "dropbox-cli status" every second
watch -n1 dropbox-cli status

Execute "du -s path" every 300 seconds
watch -n 300 du -s path

Execute "elinks -dump file.html" every 2 seconds
watch elinks -dump file.html

Execute "killall -USR1 dd" every minute
watch -n 60 killall -USR1 dd

Execute "ls -l" every 0.5 seconds
watch -n 0.5 ls -l

Execute "ls -l" every 2 seconds
watch 'ls -l'

Execute "ls -l" every 2 seconds
watch ls -l

Execute "ls -l" every 2 seconds and highlight the differences in runs
watch -d ls -l

Execute "ls -l" on host "something" as user "root"
ssh root@something 'ls -l'

Execute "ls" every 2 seconds
watch ls

Execute "ls" every second
watch -n 1 ls

Execute "lynx -dump http://dslrouter/stats.html" every 10 seconds
watch --interval=10 lynx -dump http://dslrouter/stats.html

Execute "myfile" on all .ogv files from the current directory tree
find ./ -name *.ogv -exec bash -c 'myfile {}' \;

Execute "myfile" on all .ogv files from the current directory tree
find ./ -name *.ogv -exec myfile {} \;

Execute "myfile" on all regular files from the current directory tree
find . -type f -exec bash -c 'myfile "{}"'  \;

Execute "myscript.rb" with the first argument as the current host name and the second "file.txt"
echo "`hostname -i` file.txt" | xargs myscript.rb

Execute "myscript.rb" with the first argument as the current host name and the second "file.txt"
myscript.rb `hostname -i` file.txt

Execute "mysqladmin -u root -pXXXXX processlist | grep tablename" every second and append output to "/root/plist.log"
watch -n 1  "mysqladmin -u root -pXXXXX processlist | grep tablename"  | tee -a /root/plist.log

Execute "ps -C java -o pcpu,state,cputime,etimes" every second
watch -n 1 ps -C java -o pcpu,state,cputime,etimes

Execute "ps -mo pid,tid,%cpu,psr -p \`pgrep BINARY-NAME\`" every half second displayed with no title and highlighting the differences
watch -tdn0.5 ps -mo pid,tid,%cpu,psr -p \`pgrep BINARY-NAME\`

Execute "ps -mo pid,tid,%cpu,psr -p \`pgrep firefox\`" every half second displayed with no title and highlighting the differences
watch -tdn0.5 ps -mo pid,tid,%cpu,psr -p \`pgrep firefox\`

Execute "ps aux | grep php" every second
watch -n 1 'ps aux | grep php'

Execute "sleep 30; touch nohup-exit" in the background on target machine "REMOTE"
ssh REMOTE "sh -c \"(nohup sleep 30; touch nohup-exit) > /dev/null &\""

Execute "some_script" on all files in the current directory tree
find -exec some_script {} \;

Execute "ssh raptor.lan hostname\; uptime" on server "genja.org"
ssh -t genja.org 'ssh raptor.lan hostname\; uptime'

Execute "tail file | grep pattern" every 2 seconds
watch "tail file | grep pattern"

Execute "utility" for each file in the current directory tree passing the pathname as a command line argument
find . -exec utility \;

Execute "wget -qO-  http://fake.link/file.txt" every 5 seconds
watch -n 5 wget -qO-  http://fake.link/file.txt

Execute "your_script.sh" passing all "sqlite.db" files from the current directory tree as arguments to it
find . -name 'sqlite.db' | xargs your_script.sh

Execute '/usr/bin/fbi -noverbose -a -t 4 -u `find -type f | egrep -i "(jpg|bmp|png|gif)$"`' every 300 seconds and display without title
watch -n 300 -t '/usr/bin/fbi -noverbose -a -t 4 -u `find -type f | egrep -i "(jpg|bmp|png|gif)$"`'

Execute 'bash -c "python -m unittest discover |& pyrg"' every second and display with color support
watch -n 1 --color 'bash -c "python -m unittest discover |& pyrg"'

Execute 'echo -e "\033[31mHello World\033[0m"' every without color support 2 seconds
watch 'echo -e "\033[31mHello World\033[0m"'

Execute 'echo -e "\tHello World"' every 2 seconds
watch 'echo -e "\tHello World"'

Execute `echo' for each file found
find . | xargs -n 1 echo

Execute `find -type f | egrep -i "(jpg|bmp|png|gif)$"` every 300 seconds and display without title
watch -n 300 -t `find -type f | egrep -i "(jpg|bmp|png|gif)$"`

Execute 'python -m unittest discover 2>&1 | pyrg' every second and display with color support
watch -n 1 --color 'python -m unittest discover 2>&1 | pyrg'

Execute 'tail -f -n 50 mylogfile.txt | ccze' every 5 seconds and display with color support
watch -n 5 -c 'tail -f -n 50 mylogfile.txt | ccze'

Execute 'top -n1 | grep mysql' every 2 seconds and highlight the differences between runs
watch -d 'top -n1 | grep mysql'

Execute 'tput setaf 1; echo foo' with color support every 2 seconds
watch --color 'tput setaf 1; echo foo'

Execute /usr/bin/find with $* arguments
/usr/bin/find $*

Execute /usr/bin/find with $* arguments where current directory is the first argument
/usr/bin/find ./ $*

Execute all arguments to a shell script and write the output to console and "$FILE"
$@ | tee $FILE

Execute all commands in "/path/to/commands-inc.sh" on server "remote" as user "user"
ssh user@remote 'bash -s' < /path/to/commands-inc.sh

Execute command "tssh MYBOXES N" where N ranges from 0 to 20
seq 0 20 | xargs -n1 tssh MYBOXES

execute command "who" when key "\eW" is pressed
bind -x '"\eW":"who"'

Executes command 'cd ~/server' in an opened tmux session 'cf'.
tmux send-keys -t cf 'cd ~/server' C-m

Execute COMMAND for all files and directories under the current directory tree
find . -print0 | xargs -0 COMMAND

Execute COMMAND on all files and directories in the current directory tree
find . -exec COMMAND {} +

Execute find with "$@" arguments
exec /usr/bin/find "$@"

Execute md5sum command on files found by the find command
find -iname "MyCProgram.c" -exec md5sum {} \;

Execute python script "test.py" with "LD_PRELOAD=./linebufferedstdout.so" and write the output to console and append to "test.out"
LD_PRELOAD=./linebufferedstdout.so python test.py | tee -a test.out

Execute script "your_command_here" for each file from directory tree /target/path passing the filename as an argument to the script
find /target/path -type f -exec your_command_here \{\} \;

Execute script "your_command_here" passing all regular files from directory tree /target/path as arguments to it
find /target/path -type f -print0 | xargs -0 your_command_here

Execute script 'truncate.sh' on all files in the /path/to/files directory tree
find /path/to/files -exec truncate.sh {} \;

Execute script /tmp/echoargs on all files from the /tmp/foo directory tree
find /tmp/foo -exec /tmp/echoargs {} \;

Execute script do1.sh on each regular file from the /etc directory tree
find /etc -type f |  xargs --max-lines=1  -r --max-procs=20  ./do1.sh

excute script makeallsizes with all '*.jpg' file under originals directory.
find originals -name '*.jpg' | xargs -1 makeallsizes

excute script makeallsizes with all '*.jpg' file under originals directory in 2 processes parallelly
find originals -name '*.jpg' | xargs -1 -P 2 makeallsizes

Execute Shell script with find comamnd
find -maxdepth 0 -name "*.sh"  -exec ./lastline.sh {} \;

Execute the `convert' command for every .jpg file in the current directory
find . -maxdepth 1 -name *.jpg -print -exec convert

Execute the 'echo' command on each file from the current directory tree individually
find . -exec echo {} \;

Execute the `file' command on all regular files from the current directory tree and save the output as /tmp/filetypes.log
find . -type f -exec file {} \; > /tmp/filetypes.log

Execute the first instance of "parallel" found in the PATH, passing it all parameters received by the script/function
`which parallel` "$@"

Execute zcat on every file matching "*20120805.gz" in the current directory and subdirectories
find . -name *20120805.gz -exec zcat {} \;

Execute the ruby script "genrc.rb" which will output a filename, and interpret this file in the current shell.
source $(ruby genrc.rb)

Execute the file utility for each file found under /etc and below
find /etc -print0 | xargs -0 file

Execute the file utility for each file found under /etc or below that contains "test" in its pathname
find /etc -print0 | grep -azZ test | xargs -0 file

Execute the SSH command and kill it after 5 seconds
timeout 5 ssh user@ip

Exits from login shell.
logout

Exits from screen session.
exit

Exits from script with exit code 1.
exit 1

Edit current user's cron job list with editor specified by EDITOR environment variable, or default /usr/bin/editor if EDITOR is not set.
crontab -e

Edit the cron job list for user 'wwwrun' using default editor specified by the EDITOR environment variable, or /usr/bin/editor if no default editor is specified.
sudo crontab -u wwwrun -e

Exits the entire bash script with defined status code N.
exit N

explicitly list all files in the current directory
find . -print

Report all files in /mydir1 and /mydir2 larger than 2000 blocks and accessed in over 30 days
find /mydir1 /mydir2 -size +2000 -atime +30 -print

Report all files starting in the directories /mydir1 and /mydir2 larger than 2,000 blocks that have not been accessed in over 30 days
find /mydir1 /mydir2 -size +2000 -atime +30 -print

Report available space on the file system containing /tmp in kilobytes.
df -k /tmp | tail -1 | tr -s ' ' | cut -d' ' -f4

Report file system '/dev/disk0s2' disk usage
df | grep /dev/disk0s2

Report file system containing /example disk usage in kilobytes.
df -k /example

Report file system containing /tmp disk usage in kilobytes.
df -k /tmp

Report file system containing path to /dir/inner_dir/ disk usage human-readable.
df -h /dir/inner_dir/

Report file system containing path to /dir/inner_dir/ disk usage in kilobytes.
df -k /dir/inner_dir/

Report file system containing path to the current working directory disk usage in kilobytes.
df -k .

Report file system containing path to the current working directory inodes usage.
df -i $PWD

Report file system containing path-to-file disk usage human-readable.
df -h path-to-file

Report file system containing the current directory disk usage
df .

Report file system containing the current directory disk usage in kilobytes.
df -k .

Report file system disk space usage in human readable format
df -h

Report file systems disk space usage pretty formatted.
df -Ph | column -t

Report file systems disk space usage pretty formatted.
df -Ph | perl -ne 'chomp; printf "\n%-40s %8s %8s %8s %8s %-20s", split / +/, $_, 6 ; '

Report file systems disk usage, elide all entries insignificant to available space, and produce a grand total.
df --total

Report file systems disk usage for file systems of type <type>.
df -kt<type>

Report file systems disk usage human-readable using POSIX output format.
df -Ph

Report file systems disk usage in 1GB blocks.
df -BG

Report file systems disk usage in kilobytes.
df -k

Report file systems disk usage using POSIX output format.
df -P

Report file systems inode usage.
df -i

Report file systems inodes usage.
df -i

Report file system inodes usage in human readable format
df -ih

Report file system mounted at $path_in_question disk usage if canonical path $path_in_question is a mount point.
df $path_in_question | grep " $path_in_question$"

Export full path of command "git" to variable "git"
export git=$(which git)

Import the uncompressed contents of the last modified file  matching "*.sql.gz" into "mysql"
ls -Art *.sql.gz |tail -n 1 |xargs gunzip -c | mysql --user=user --password=password database

Report total disk usage info on root file system, printing all sizes as power of 1000
df -H --total /

Report total file systems disk usage.
df --total | tail -n 1

Report total file systems disk usage estimated in terabytes
df --total -BT | tail -n 1

Report total file systems disk usage in 1T blocks.
df --total -BT | tail -n 1

Report total size of the root filesystem disk usage in powers of 1000.
df -H --total /

Export variable "JAVA_HOME" as symlink resolved absolute path of "/usr/bin/javac" with "/bin/javac" removed
export JAVA_HOME=$(readlink -f /usr/bin/javac | sed "s:/bin/javac::")

Export variable "JAVA_HOME" as symlink resolved absolute path of the 2nd parent directory name of "java"
export JAVA_HOME=$(readlink -f $(dirname $(readlink -f $(which java) ))/../)

Export variable "JAVA_HOME" as symlink resolved absolute path of two parent directories above "/usr/bin/javac"
export JAVA_HOME=$(readlink -ze /usr/bin/javac | xargs -0 dirname -z | xargs -0 dirname)

Export variable "PS1" as the current username "@" the hostname
export PS1='$(whoami)@$(hostname):'

extract "backup.tar.gz" with verbose output
tar -xzvf backup.tar.gz

extract "filename.tar.xz" with verbose output
$ tar xvfJ filename.tar.xz

extract "phantomjs-1.9.0-linux-x86_64.tar.bz2"
sudo tar xvf phantomjs-1.9.0-linux-x86_64.tar.bz2

extract 'archive.tar.gz' to /destination
gzip -dc archive.tar.gz | tar -xf - -C /destination

extract 'archive.tar.gz' to /destination
tar xzf archive.tar.gz -C /destination

extract /path/to/my_archive.tar.xz to /path/to/extract and preserve permissions.
tar xpvf /path/to/my_archive.tar.xz -C /path/to/extract

extract an archive stripping the first component
tar --strip-components 1 -xvf my_directory.tar.gz

extract archive stored in $1
tar -zxvf $1

extract the content of the file doc.gz and split it into pieces per 1000 lines compressed with gzip
zcat doc.gz | split -l 1000 --filter='gzip > $FILE.gz'

extract the content of the file large.csv.gz and split it into pieces per 1000 lines named as xxxNNN
gzcat large.csv.gz | split -l 1000 - xxx

Extracts 258 lines beginning from line 16482 of in.sql and saves them to out.sql
head -16482 in.sql | tail -258 > out.sql

Extracts a bz2 file.
bunzip2 file.bz2

Extract rpm "foo.rpm"
rpm2cpio foo.rpm | xzcat | cpio -idmv

Extract rpm "libstdc++-4.9.2-1.fc21.x86_64.rpm"
rpm2cpio libstdc++-4.9.2-1.fc21.x86_64.rpm |cpio -idmv

Extract rpm "packagename"
rpm2cpio packagename | cpio -ivd

Extract files from archive 'archive.tar'
cat archive.tar | tar x

Extract, sort and print only group names from /etc/group.
cut -d: -f1 /etc/group | sort

Extract any line in "f1" or "f2" which does not appear in the other
comm -3 <(sort -un f1) <(sort -un f2)

Extract any line in "file1" or "file2" which does not appear in the other
comm -3 <(sort file1) <(sort file2)

Extract any line in "file1.txt" which does not appear as the first ";" delimited entry in "file2.txt"
comm -23 <(sort file1.txt) <(grep -o '^[^;]*' file2.txt | sort)

Extract any line in "set1" which does not appear in "set2"
comm -23 <(sort set1) <(sort set2)

Extract any line in sorted file "A" that does not appear in "B", "C", or "D"
cat B C D | sort | comm -2 -3 A -

Extract path and query part from URL
echo "$url" | cut -d'/' -f4-

Extract protocol part from URL.
echo "$url" | cut -d':' -f1

Extracts single file 'filename' from bzip2-compressed tarball archive.tbz.
bzip2 -dc archive.tbz | tar xvf - filename

Extract tar.gz archive and go into the directory that would normally be created by extracting it.
tar xvf "$myarchive" && cd "${myarchive%.tar.gz}"

Extract the contents of "Input.txt.gz", list the unique first comma separated field prefixed by the number of occurrences
zcat Input.txt.gz | cut -d , -f 1 | sort | uniq -c

Extract the second-to-last slash-separated path component, ie. "90_2a5" in this case.
echo 'test/90_2a5/Windows' | xargs dirname | xargs basename

Fetches the newest version of Homebrew and all formulae from GitHub and perform any necessary migrations.
brew update

file all the Sticky Bit set files whose permission are 551
find / -perm 1551

Filters out strings beginning with '#' from all files in current folder, and prints file name before each line.
cd /var/cron/tabs && grep -vH ^# *

Filters out strings, using the extended regexp pattern '^#|^$|no crontab for|cannot use this program' from "$USERTAB"
echo "$USERTAB"| grep -vE '^#|^$|no crontab for|cannot use this program'

Filters only directories from long file listing of the current directory
ls -l --color=always "$@" | egrep --color=never '^d|^[[:digit:]]+ d'

Filters only directories from long file listing of the current directory
ls -l --color=always "$@" | grep --color=never '^d'

Filters only directories from long file listing of the current directory.
ls -l | grep "^d"

filter output of bind -p by regex
bind -p | grep -a forward

Filters unique lines by matching against the first column of a .csv file
tac a.csv | sort -u -t, -r -k1,1 |tac

Find "$i" files under current directory and search for "$SrchStr" in those files
find . -name "$i" -type f -print | xargs egrep -n "$SrchStr" >/dev/null

Find "*.dat" files recursively in the current directory, print the lines starting on line 5 to the console and save to "concat.txt"
find . -type f \( -name "*.dat" \) -exec tail -n+5 -q "$file" {} + |tee concat.txt

Find "*201512*" regular files in /home/myhome/data/ARCHIVE/ and move them to /home/myhome/ARCHIVE/TempFolder/
find /home/myhome/data/ARCHIVE/. -name . -o -type d -prune -o -name '*201512*' -print | xargs -i mv {} /home/myhome/ARCHIVE/TempFolder/.

Find "*prefs copy" files in the /mnt/zip directory tree and remove them
find /mnt/zip -name "*prefs copy" -print0 | xargs rm

Find ".c" and ".h" files in the current directory tree and print lines containing "#include"
tree -if | grep \\.[ch]\\b | xargs -n 1 grep -H "#include"

find ".flac" files in current folder using regular expressions
find ./ -regex "./cmn-.\.flac"

bind "\C-i" to "complete" function
bind '"\C-i":complete'

Find "file.xml" under the current directory and change directory to its parent
cd `find . -name file.xml -exec dirname {} \;`

Find "file.xml" under the current directory and change directory to its parent
cd `find . -name file.xml -printf %h`

Send "yes" 4 times followed by 1 "no" to "./script"
{ yes yes | sed 4q; yes no | sed 1q; } | ./script

Finds $a pattern in a $b string, and returns exit code 0 if found, suppressing any visible output.
echo $b|grep -q $a

Find & replace broken symbolic links
find -L . -type l -delete -exec ln -s new_target {} \;

Find '*prefs copy' files under /mnt/zip and delete them ensuring white space safety
find /mnt/zip -name "*prefs copy" -print0 | xargs>    -0 rm

Find '*prefs copy' files under /mnt/zip and delete them with confirmation prompt
find /mnt/zip -name "*prefs copy" -print0 | xargs>    -p rm

Find '*prefs copy' files under /mnt/zip and delete them with confirmation prompt ensuring white space safety
find /mnt/zip -name "*prefs copy" -print0 | xargs    -0 -p /bin/rm

Find '.git' directories in directory tree /home/madhu/release/workspace
find /home/madhu/release/workspace -type d -name '.git'

Find '.git' directories in directory tree /path/to/files and print the pathnames of their parents
find /path/to/files -type d -name '.git' -exec dirname {} +

Find `string' in all *.java files ignoring the case of that string
find . -type f -name "*.java" -exec grep -il string {} \;

Find *.NEF files under current directory and take only the filename without extension and run other commands on this    file name.
find . -name "*.NEF" -exec basename \{\} .NEF \; | xargs> -i sh -c 'dcraw -w -c $0.NEF | convert - -resize 25% $0.jpg'

Find *.avi and *.flv files in /path/to/your/directory and below and copy them to /path/to/specific/folder
find /path/to/your/directory -regex '.*\.\(avi\|flv\)' -exec cp {} /path/to/specific/folder \;

Find *.c and *.h files under the current directory tree skipping hidden directories and files
find . \( -path '*/.*' -prune -o ! -name '.*' \) -a -name '*.[ch]'

Find *.c files under $HOME and search for the string 'sprintf' in those files
find $HOME -name '*.c' -print | xargs    grep -l sprintf

Find *.css files in the current directory tree, skipping all directories that match pattern '*/lang/en.css'
find . -path '*/lang/en.css' -prune -o -name '*.css' -print

find *.gif files under the currently directory and sub-directories and list them using the ls command
find . -name *.gif -exec ls {} \;

Find *.html files in the current directory tree that were last modified more than 7 days ago
find . -mtime +7 -name "*.html" -print

Find *.html files in the current directory tree that were modified 7 days ago
find . -mtime 7 -name "*.html" -print

Find *.html files in the current directory tree that were modified less than 7 days ago
find . -mtime -7 -name "*.html" -print

Find *.java files under current directory and compress them to myfile.tar
find . -type f -name "*.java" | xargs    tar rvf myfile.tar

Find *.java files under current directory and compress them to myfile.tar
find . -type f -name "*.java" | xargs>    tar cvf myfile.tar

Find *.java files under current directory and compress them to myfile.tar
find . -type f -name "*.java" | xargs>    tar rvf myfile.tar

Find *.java files under current directory and compress them to myfile.tar  (unsafe)
find . -type f -name "*.java" | xargs    tar cvf myfile.tar

Find *.o files with permissions 664 in the current directory tree
find . -name *.o -perm 664 -print

Find *.pdf files in the PDFs directory tree that contain text "perry sound" and copy them to folder Found/
find PDFs/ -name '*.pdf' -exec sh -c 'pdftotext "{}" - | grep -l -Z -i --with-filename --label="{}" --color "perry sound" | xargs -0 -I{} cp -v {} Found/' \;

Find *.pl files/directories under /users/tom
find /users/tom -name "*.pl"

Find *.scm files recursively in the current directory
find . -name '*.scm'

find *.txt files in the current directory and sub-directories
find -name "*.txt" 2>>/dev/null

Find *.txt files in the current directory tree, ignoring paths ./Movies/*, ./Downloads/*, and ./Music/*
find . -type f -name "*.txt" ! -path "./Movies/*" ! -path "./Downloads/*" ! -path "./Music/*"

Find *2011* files and grep for the string 'From: Ralph' in those files
find . -name '*2011*' -print | xargs -n2 grep 'From: Ralph'

Find *log files/directories within a maximum of 3 levels of directories
find / -maxdepth 3  -name "*log"

find -name '*.js' -not -path './node_modules/*' -not -path './vendor/*'
find -name '*.js' -not \( -path './node_modules/*' -o -path './vendor/*' \)

find .bmp or .txt files
find /home/user/Desktop -name '*.bmp' -o -name '*.txt'

Find .cpp files that differs in subdirectories PATH1 and PATH2.
diff -rqx "*.a" -x "*.o" -x "*.d" ./PATH1 ./PATH2 | grep "\.cpp " | grep "^Files"

find .gif files in /var/www and below that were last changed between 90 and 180 days ago
find /var/www -name *.gif -ctime +90 -ctime -180

Find .java files in the current directory tree that contain 'TODO', and print their pathnames
find . -name "*.java" -exec grep -Hin TODO {} + | cut -d ":" -f 1

Find .jpg files owned by user daniel in the current directory and its sub-directories.
find . -user daniel -type f -name *.jpg

Find .jpg files owned by user daniel in the current directory and its sub-directories but ignore any file beginning with "autumn".
find . -user daniel -type f -name *.jpg ! -name autumn*

Find .log files in the /var/log directory tree and copy them to a bzip2 archive
find /var/log -name '*.log' | tar cv --files-from=- | bzip2 > log.tar.bz2

Find .rm files in the /home/me/download/ directory tree and convert them to the MP3 format
find /home/me/download/ -type f -name "*.rm" -exec ffmpeg -i \{} -sameq \{}.mp3 \; -exec rm \{} \;

Find .rm files in the current directory tree and convert them to the MP3 format
find . -type f -name "*.rm" -exec ffmpeg -i {} -sameq {}.mp3 \; -exec rm {} \;

Find .rmv files in the ./root directory recursively and copy them to directory /copy/to/here
find root -name '*.rmv' -type f -exec cp --parents "{}" /copy/to/here \;

Find .rmv files in the ./root directory recursively and copy them to directory /copy/to/here
find root -name '*.rmv' -type f -exec cp {} /copy/to/here \;

Find .rmv files in the current directory recursively
find . -name *.rmv

Find .txt files on the system whose size is greater than 12000 bytes
find / -name "*.txt" -size +12000c

Find 10 largest files in the current directory and its subdirectories
du -hsx * | sort -rh | head -10

Find 10 most recently changed files in the current directory tree
find . -type f -printf "%C@ %p\n" | sort -rn | head -n 10

Send 4 ping packets of size 2 to "www.google.com" on a Solaris machine
ping -s www.google.com 2 4

Send 5 ping requests to address 12.34.56.78 and print only the last 2 lines of the summary output.
ping -c 5 -q 12.34.56.78 | tail -n 2

Find <fileName> files/directories under current directory
find -name "<fileName>"

find a 'fool.scala' named regular file under /opt /usr /var those directories.
find /opt /usr /var -name foo.scala -type f

Find a 400 permission file under /data directory
find /data -type f -perm 400 -print -quit

find a difference between website content of "http://tldp.org/LDP/abs/html/" and "http://www.redhat.com/mirrors/LDP/LDP/abs/html/"
diff <(curl -s http://tldp.org/LDP/abs/html/) <(curl -s http://www.redhat.com/mirrors/LDP/LDP/abs/html/)

Find a directory named 'project.images' in the entire filesystem
find  / -type d -name "project.images"

Find a directory named 'project.images' in the entire filesystem and show it in long listing format
find  / -type d -name "project.images" -ls

find a file in current folder and show all errors apart from permission denied
find /. -name 'toBeSearched.file' 2>&1 | grep -v 'Permission denied'

Send a lot of packets to "remote.machine" on port "CLOSED_PORT" at 0.1 second intervals
watch --interval 0.1 "nc remote.machine CLOSED_PORT"

Find a hostname that resolves to IP '173.194.33.71'
dig +short -x 173.194.33.71

Find a more recent version of httpd.conf file than /etc/apache-perl/httpd.conf in entire file system
find / -name httpd.conf -newer /etc/apache-perl/httpd.conf

Send a single ping request with a TTL of 1 to "192.168.1.1"
ping -c 1 -t 1 192.168.1.1

Find a single file called FindCommandExamples.txt under current directory and remove it
find . -type f -name "FindCommandExamples.txt" -exec rm -f {} \;

Find a single file called tecmint.txt and remove it
find . -type f -name "tecmint.txt" -exec rm -f {} \;

Find a file "foo.bar" without showing "Permission Denied" messages
find / -name foo.bar -print 2>/dev/null

Find a size of only the target directory in MB format
du -s --block-size=M /path/to/your/directory/

Find a file/directory named modules under current directory and exit with the number of files/directories named 'modules'  found in this path
find . -name modules -exec sh -c 'exit $(find {} -name modules|grep -n ""|tail -n1|cut -d: -f1)' \;

find a specfic video file in the current directory
find ./ -name "foo.mp4" -exec echo {} \;

Find a used disk space of a target directory and files inside of it
du -h your_directory

find a.out, *.o and core files under the current directory and sub-directories and delete them.
find . \( -name a.out -o -name '*.o' -o -name 'core' \) -exec rm {} \;

Find a.out and object files in the current directory tree
find . ( -name a.out -o -name *.o ) -print

Find absolute path of command with PID "$pid"
readlink -f `ls --dereference /proc/$pid/exe`

find all ".flac" files in current folder starting with "cmn-"
find . -name 'cmn-*.flac'

Find all ".gz" files in directory tree "files/" and use a count and the filename as arguments to "..."
find files/ -name "*.gz" | nl -n rz | sed -e 's/\t/\n/' | xargs --max-args 2 ...

Find all "G*.html" files modified more than 7 days ago in the current directory tree
find . -mtime +7 -name "G*.html"

Find all "G*.html" files modified more than 7 days ago in the current directory tree and pass them as arguments to script /path/to/script_7zipi
find . -mtime +7 -name "G*.html" -execdir  /path/to/script_7zipi {} +

Find all "YourProgramName" regular files in the current directory tree and print the full paths to the directories containing them
find . -type f -name YourProgramName -execdir pwd \;

find all "tar.gz" files in a folder and sort them according to the name and display the first 2 files
(find $DIR/tmp/daily/ -name *.tar.gz | sort -n | head -2

Find all $1 files/directories under current directory and enter into the parent directory of the first one found
cd $(find . -name $1 | xargs dirname)

Find all $2 files in $1 path and search for the regex expanded by $3 in those files
find $1 -name "$2" -exec grep -Hn "$3" {} \;

Find all $2 files in $1 path and search for the regex expanded by $3 in those files excluding the files with /proc in their paths
find $1 -name "$2" | grep -v '/proc' | xargs grep -Hn "$3" {} \;

Find all $2 files in $1 path excluding /proc and search for the regex expanded by $3 in those files
find $1 -path /proc -prune -o -name "$2" -print -exec grep -Hn "$3" {} \;

Find all $tofind* files/directories under $parentdir
find $parentdir -name $tofind*

find all '*.c' files under $HOME directory which context contains sprintf
find $HOME -name '*.c' -print | xargs grep -l sprintf

Find all '*~' files under current directory
find ./ -name '*~'

Find all '*~' files under current directory and delete them
find ./ -name '*~' | xargs> rm

Find all  'custlist*' files under current directory
find . -name custlist\*

Find all `doc.txt' files in the current directory tree printing "found" for each of them
find ./ -name doc.txt -printf "found\n"

find all 'js' suffix files  exclue the path *exclude/this/dir*' under current dirctory
find . -name '*.js' -not -path '*exclude/this/dir*'

Find all 'test' directories in the current directory tree and remove them
find -type d -a -name test|xargs rm -r

Find all 'test' directories in the current directory tree and remove them
find . -name test -type d -print0|xargs -0 rm -r --

Find all 'test' directories in the current directory tree and remove them
find . -type d -name 'test' -exec rm -rf {} \;

Find all *$VERSION* files/directories under current directory where $VERSION is a variable
find . -name "*$VERSION*"

Find all *-* files under current directory
find . -type f -name '*-*'

Find all *.$input_file_type files/directories under $source_dir
find "$source_dir" -name *.$input_file_type

Find all *.$input_file_type files/directories under $source_dir with the null character as the delimiter
find "$source_dir" -name "*.$input_file_type" -print0

Find all *.* directories under /home/feeds/data directory
find /home/feeds/data -type d \( -name 'def/incoming' -o -name '456/incoming' -o -name arkona \) -prune -o -name '*.*' -print

Find all *.* files under current directory
find . -type f -a -name '*.*'

Find all *.* files not within .git directory and run $SED_CMD -i "s/$1/$2/g" on each of them
find . -type f -name "*.*" -not -path "*/.git/*" -print0 | xargs -0 $SED_CMD -i "s/$1/$2/g"

Find all *.[ch] files under current directory
find . -name '*.[ch]'

Find all *.axvw files/directories under current directory
find . -name '*.axvw'

Find all *.bmp files in the current directory tree and convert them to the JPEG format
find -name *.bmp -type f -exec convert '{}' '{}'.jpg \;

Find all *.c files in /usr/src bigger than 100k
find /usr/src -name '*.c' -size +100k -print

Find all *.c files under and below the current directory that contain "hogehoge"
find . -name \*.c | xargs grep hogehoge

Find all *.c files located under /home and below
find /home -name "*.c"

Find all *.c files on the system and feed the output to wc
find / -name *.c | wc

Find all *.cls files/directories under current directory and print '{if(length($0) > L) { LINE=$0; L = length($0)}} END {print LINE"L"L}' for each of them where $0 is expanded to the file/directory path
find . -iname "*.cls" -exec echo '{if(length($0) > L) { LINE=$0; L = length($0)}} END {print LINE"L"L}' {} \;

Find all *.coffee files under /some/path and run 'perl /path/to/your/program' with all of the file paths as its arguments
find /some/path -name '*.coffee' -print0 | xargs -0 perl /path/to/your/program

Find all *.cpp files in the current directory tree that contain "sub" in their names
find . -name "*sub*.cpp"

Find all *.css files under /starting/directory and print filenames and the lines matching the regex '\.ExampleClass' from those files
find /starting/directory -type f -name '*.css' | xargs -ti grep '\.ExampleClass' {}

find all  *.csv files which  modify within last 2 days in /home directory then zip ( archive )-
find /home/archive -type f -name "*.csv"  -mtime -2 -exec gzip -9f {} \;

Find all *.csv files under /foo/bar and move them to some_dir
find /foot/bar/ -name '*.csv' -print0 | xargs -0 mv -t some_dir

Find all *.csv files under /foot/bar/ and move them to some_dir
find /foot/bar/ -name '*.csv' -print0 | xargs -0 mv -t some_dir

Find all *.dbf files/directories in entire file system
find / -name "*.dbf"

Find all *.dbf files/directories in entire file system and print their sorted and unique parent directory paths
find / -name \*.dbf -print0 | xargs -0 -n1 dirname | sort | uniq

Find all *.dbf files/directories in entire file system discarding errors and print their sorted and unique parent directory paths
find / -name \*.dbf -print0 2>/dev/null | xargs -0 -n1 dirname | sort | uniq

Find all *.dbf files/directories in entire file system discarding errors and print their sorted and unique parent directory pathsg
find / -name "*.dbf"  -exec dirname {} \; 2> /dev/null | sort -u

Find all *.epub, *.mobi, *.chm, *.rtf, *.lit and *.djvu files/directories under current directory
find ./ -name '*.epub' -o -name '*.mobi' -o -name '*.chm' -o -name '*.rtf' -o -name '*.lit' -o -name '*.djvu'

Find all *.err files under current directory that are larger than 5120 bytes in size
find . -type f -size +10 -name "*.err"

Find all *.ext regular files under /path and execute my_cool_script for each of them with the file path as argument
find /path -type f -name '*.ext' -exec my_cool_script \{\} \;

Find all *.foo files under current directory and search for 'bar' in those files
find . -name '*.foo' -exec grep bar {} \;

Find all *.foo files under current directory and print their contents
cat $(find . -name '*.foo')

Find all *.foo files under current directory and print their contents
cat `find . -name '*.foo' -print`

Find all *.foo files under current directory and print their contents
find . -name '*.foo' -exec cat {} +

Find all *.foo files under current directory and print their contents
find . -name '*.foo' -exec cat {} \;

Find all *.gz files/directories under asia and emea directory
find asia emea -name \*.gz

Find all *.gz files/directories under asia and emea directory
find asia emea -name \*.gz -print0 | xargs -0

Find all *.htm files under current directory
find -type f -name "*.htm"

Find all *.htm files under current directory and change their names by appending 3 levels of parent directory names at the beginning and modifying the actual name to dd-nnn format
eval "`find -type f -name "*.htm" |awk -F/ '{print "cp " $0 " " $2 "-" $3 "-" $4 "-" substr($5,5) ";" }'`"

Find all *.html files under current directory
find . -type f -name '*.html'

Find all *.ini files
find . -name *.ini

find all *.java files/directories under current directory
find . -name  "*.java"

find all *.java files/directories under current directory
find . -name  \*.java

Find all *.java files in the current directory tree
find . -name  \*.java

Find all *.java files under current directory
find . -name "*.java"

Find all *.java files under current directory and archive them to myfile.tar
find . -type f -name "*.java" | xargs tar rvf myfile.tar

Find all *.jpg files/directories under current directory
find . -name '*.jpg'

Find all *.jpg files in */201111/* paths and numerically sort them according to the second field in the file name with a delimiter '_'
find */201111/* -name "*.jpg" | sort -t '_' -nk2

Find all *.jpg files in Cam2/2013* paths and send the contents to a ffmpeg command to create a video file
find Cam2/2013* -name "*.jpg" -print0 | xargs -0 cat | ffmpeg -f image2pipe -framerate 30 -vcodec mjpeg -i - -vcodec libx264 -profile:v baseline -level 3.0 -movflags +faststart -crf 19 -pix_fmt yuv420p -r 30 "Cam2-2013-30fps-19crf.mp4"

Find all *.jpg (case insensitive) files under current directory
find . -iname '*.jpg'

Find all *.jpg files under current directory
find . -name *.jpg

Find all *.jpg files under current directory and print only duplicate names
find . -name \*.jpg -exec basename {} \; | uniq -d

Find all *.jpg files under current directory and print only unique names
find . -name *.jpg | uniq -u

Find all *.jpg files under current directory and print only unique names
find . -name \*.jpg -exec basename {} \; | uniq -u

Find all *.jpg (case-insensitive) files under maximum 2 levels down the temp/images/* paths and run `mogrify -resize 100x100">" -quality 80 -compress JPEG -monitor -strip` with the file paths as arguments
find temp/images/* -maxdepth 2 -iname "*.jpg" -print0 | xargs -0 mogrify -resize 100x100">" -quality 80 -compress JPEG -monitor -strip

Find all *.jpg (case-insensitive) files under maximum 2 levels down the temp/large/* paths and run `mogrify -resize 428x270">" -quality 80 -compress JPEG -monitor -strip` with the file paths as arguments
find temp/large/* -maxdepth 2 -iname "*.jpg" -print0 | xargs -0 mogrify -resize 800x800">" -quality 85 -compress JPEG -monitor -strip -gravity SouthEast -draw 'text 10,10 "www.kmstools.com"'

Find all *.jpg (case-insensitive) files under maximum 2 levels down the temp/medium/* paths and run `mogrify -resize 428x270">" -quality 80 -compress JPEG -monitor -strip` with the file paths as arguments
find temp/medium/* -maxdepth 2 -iname "*.jpg" -print0 | xargs -0 mogrify -resize 428x270">" -quality 80 -compress JPEG -monitor -strip

Find all *.jpg (case-insensitive) files under  maximum 2 levels down the temp/medium/* paths and run `mogrify -resize 428x270"^" -quality 80 -compress JPEG -monitor -strip` with the file paths as arguments
find temp/medium/* -maxdepth 2 -iname "*.jpg" -print0 | xargs -0 mogrify -resize 428x270"^" -quality 80 -compress JPEG -monitor -strip

Find all *.jpg files on the system
find / -name *.jpg 2>/dev/null

Find all *.log files under current directory that contain the string "Exception"
find . -name '*.log' -mtime -2 -exec grep -Hc Exception {} \; | grep -v :0$

Find all *.log files under path/
find path/ -name "*.log"

Find all *.log files under path/ that do not contain "string that should not occur"
find path/ -name '*.log' -print0 | xargs -r0 -I {} bash -c 'grep -q "string that should not occur" "{}" || echo "{}"'

Find all *.log files under path/ that do not contain "string that should not occur"
find path/ -name '*.log' -print0 | xargs -r0 grep -L "string that should not occur"

Find all *.m4a files/directories under /home/family/Music directory
find /home/family/Music -name '*.m4a' -print0

Find all *.m4a files/directories under /home/family/Music directory
find /home/family/Music -name *.m4a -print0

Find all *.m4a files under /home/family/Music directory
find  /home/family/Music -type f -name '*.m4a' -print0

Find all *.m4a files under /home/family/Music directory and convert them to ogg
find /home/family/Music -name '*.m4a' -exec ffmpeg -i "{}" -acodec libvorbis -aq 6 -vn -ac 2 "{}.ogg" \;

Find all *.m4a files under /home/family/Music directory and convert them to ogg
find /home/family/Music -name '*.m4a' -exec sh -c 'ffmpeg -i "$0" -acodec libvorbis -aq 6 -vn -ac 2 "${0%.m4a}.ogg"' '{}' \;

Find all *.m4a files under /home/family/Music directory and convert them to ogg
find /home/family/Music -name '*.m4a' -print0 | xargs -0 -i ffmpeg -i {} -acodec libvorbis -aq 6 -vn -ac 2 {}.ogg

Find all *.md files in entire file system and convert them to HTML (*.html) files
find / -name "*.md" -type f -exec sh -c 'markdown "${0}" > "${0%.md}.html"' {} \;

Find all *.md files in entire file system and convert them to HTML (*.md.html) files
find / -name "*.md" -type f -exec markdown -o {}.html {} \;

Find all *.md files in entire file system and convert them to HTML (*.md.html) files
find / -name "*.md" -type f -exec sh -c 'markdown "$0" > "$0.html"' {} \;

Find all *.mov files under current directory
find . -name "*.mov"

Find all *.mov (case insensitive) files under current directory and execute /path/to/myffmpeg.sh with each file path as its argument
find . -iname "*.mov" -exec /path/to/myffmpeg.sh {} \;

Find all *.mov (case insensitive) files under current directory and list their paths with their names
find . -iname "*.mov" -printf "%p %f\n"

Find all *.mov (case insensitive) files under current directory and run an ffmpeg command with the literal '%p' and '%f' as the path and name respectively for each file
find . -iname "*.mov" -exec ffmpeg -i "%p" -f flv "%f" \;

Find all *.mov (case insensitive) files under current directory and run an ffmpeg command with the path and the name for each file
find . -iname "*.mov" -print0 | xargs -0 -i sh -c 'ffmpeg -i {} -f flv `basename {}`'

Find all *.mov (case insensitive) files under current directory and run an ffmpeg command with the path and the name for each file
find . -iname "*.mov" -printf "%p %f\n" | xargs -l bash -c 'echo ffmpeg -i $0 -f flv $1' | xargs

Find all *.mov (case insensitive) files under current directory and run an ffmpeg command with the path and the name for each file
find . -iname "*.mov" -printf "%p %f\n" | xargs -r -n2 ffmpeg -f flv -i

Find all *.mov (case insensitive) files under current directory and run an echo command with the path and the name for each file
find . -iname "*.mov" -printf "%p %f\n" | while read -a HR ; do echo ffmpeg -i ${HR[0]} -f flv ${HR[1]} ;done

Find all *.mp3, *.aif*, *.m4p, *.wav, *.flac files under $musicdir directory
find "$musicdir" -type f -print | egrep -i '\.(mp3|aif*|m4p|wav|flac)$'

Find all *.mp3 (case insensitive) files/directories under /tmp and remove them
find /tmp -iname '*.mp3' -print0 | xargs -0 rm

Find all *.mp3 files in entire file system greater than 10MB and delete them
find / -type f -name *.mp3 -size +10M -exec rm {} \;

Find all *.mp3 files under current directory
find . -name *.mp3

Find all *.mp3 files under current directory and run mplayer with these files
find . -name "*.mp3" -print0 | xargs -0 mplayer

Find all *.mp3 files under current directory and run mplayer with these files
find . -name \*.mp3 -print0 | xargs -0 mplayer

Find all *.mp4 files under /foo/bar and move them to /some/path
find /foo/bar -name '*.mp4' -print0 | xargs -I{} -0 mv -t /some/path {}

Find all *.mp4 files under /foo/bar and move them to /some/path
find /foot/bar/ -name '*.mp4' -exec mv -t /some/path {} +

Find all *.mp4 files under /working
find /working -type f -name '*.mp4'

Find all *.ogg (case insensitive) files/directories in entire file system
sudo find / -iname '*.ogg'

Find all *.ogg (case insensitive) files/directories under your home directory
find $HOME -iname '*.ogg'

Find all *.ogg (case insensitive) files/directories under your home directory that are greater than 100MB in size
find $HOME -iname '*.ogg' -size +100M

Find all *.ogg (case insensitive) files/directories under your home directory that are greater than 20MB in size
find $HOME -iname '*.ogg' -size +20M

Find all *.ogg (case insensitive) files/directories under your home directory that are not greater than 20MB in size
find $HOME -iname '*.ogg' ! -size +20M

Find all *.ogg (case insensitive) files under your home directory that are less than 100MB in size
find $HOME -iname '*.ogg' -type f -size -100M

Find all *.ogg files under the home directory ignoring the case
find $HOME -iname '*.ogg'

Find all *.ogg files on the system ignoring the case
find / -iname '*.ogg'

Find all *.old files and move them to directory oldfiles
find . -name "*.old" -exec mv {} oldfiles \;

Find all *.p[lm] files/directories under current directory
find -name '*.p[lm]'

Find all *.p[lm] files under /users/tom directory that matches both the regex '->get(' and '#hyphenate' in their contents
find /users/tom -name '*.p[lm]' -exec grep -l -- '->get(' {} + | xargs grep -l '#hyphenate'

Find all *.p[lm] files under /users/tom directory that matches the regex '->get(\|#hyphenate' in their contents
find /users/tom -name '*.p[lm]' -exec grep -l -- '->get(\|#hyphenate' {} +

Find all *.page (case insensitive) files/directories under current directory and run ~/t.sh for each of them with the file path as argument, then sort the output
find . -iname *.page -exec ~/t.sh {} \; | sort

Find all *.pdf files under ./polkadots
find ./polkadots -type f -name "*.pdf"

Find all *.pdf.marker files under ${INPUT_LOCATION} and move them to ${OUTPUT_LOCATION} also move any *.pdf files with the same name under current directory to ${OUTPUT_LOCATION}
find ${INPUT_LOCATION}/ -name "*.pdf.marker" | xargs -I file mv file $(basename file .marker) ${OUTPUT_LOCATION}/.

Find all *.php (case insensitive) and *.js files (case insensitive) under /home/jul/here excluding  /home/jul/here/exclude/* paths
find /home/jul/here -type f \( -iname "*.php" -o -iname "*.js" \) ! -path "/home/jul/here/exclude/*"

Find all *.php (case insensitive) files and *.js files/directories (case insensitive) under /home/jul/here excluding *.js files/directories under /home/jul/here/exclude/* paths
find /home/jul/here -type f -iname "*.php" -o -iname "*.js" ! -path "/home/jul/here/exclude/*"

Find all *.php (case insensitive) files and *.js files/directories (case insensitive) under /home/jul/here excluding /home/jul/here/exclude/* paths
find /home/jul/here -type f -iname "*.php" ! -path "/home/jul/here/exclude/*" -o -iname "*.js" ! -path "/home/jul/here/exclude/*"

Find all *.php files under current directory and change their permission to 644
find . -type f -name '*.php' -exec chmod 644 {} \;

Find all *.plist files/directories under current directory
find -name \*.plist

Find all *.plist files/directories under current directory
find . -name \*.plist

Find all *.plist files/directories under current directory
find ./ -name "*.plist"

Find all *.ps files under $STARTDIR
find $STARTDIR -name '*.ps' -print

Find all *.ps files under $STARTDIR and run ps2pdf for each files with the file path as a argument
find $STARTDIR -name '*.ps' -print | sed -e 's/.ps$//' | xargs -l -i  ps2pdf \{}.ps

Find all *.py files/directories under current directory
find . -name *.py

Find all *.py files/directories under current directory
find . -name \*.py -print

Find all *.py (case insensitive) files/directories under dir directory ignoring .git path
find dir -not -path '.git' -iname '*.py'

Find all *.py files under current directory
find . -type f -name "*.py"

Find all *.py files under current directory and search for regular expressions taken from the search_terms.txt file
find . -name '*.py' -exec grep -n -f search_terms.txt '{}' \;

Find all *.py files under current directory and run 'perl script.pl' with the file paths as arguments
find . -name '*.py' | xargs perl script.pl

Find all *.rb and *.py files/directories under current directory
find . -name "*.rb" -or -name "*.py"

Find all *.rb (regular) files under current directory
find . -name "*.rb" -type f

Find all *.rb (regular) files under current directory and change their mode to 600
find . -name "*.rb" -type f -exec chmod 600 {} \;

Find all *.rb (regular) files under current directory and count their line numbers
find . -name "*.rb" -type f -exec wc -l \{\} \;

Find all *.rb (regular) files under current directory and count their line numbers
find . -name "*.rb" -type f | xargs wc -l

Find all *.rb (regular) files under current directory and count their line numbers ensuring white space safety on file name/path.
find . -name "*.rb" -type f -print0 | xargs -0 wc -l

Find all *.rb (regular) files under current directory and print them on stdout putting the file name/path in-between two string literals 'Hello,' and '!'
find . -name "*.rb" -type f | xargs -I {} echo Hello, {} !

Find all *.rb (regular) files under current directory ensuring white space safety and print at most two file names/paths per line
find . -name "*.rb" -type f -print0 | xargs -0 -n 2 echo

Find all *.rpm files/directories under current directory
find . -name '*.rpm'

Find all *.sh files owned by user vivek
find / -user vivek -name "*.sh"

Find all *.so files/directories under current directory and run myCommand with the file/directory paths as its argument, then search for ExpectedResult in the output
find . -name *.so -print0 | xargs -0 myCommand | grep ExpectedResult

Find all *.so files/directories under current directory and run myCommand with the file/directory paths as its argument then search for ExpectedResult in the output of myCommand
find . -name *.so -print0 | xargs -0 -I % sh -c 'echo % ; myCommand "%" | grep ExpectedResult'

Find all *.so files under $S directory and run doexe command with minimal invocation for those files
find "${S}" -name '*.so*' -exec doexe '{}' +

Find all *.so files under current directory and search for mysymbol in their symbol tables
find . -type f -name "*.so" -exec sh -c "echo {} && readelf -s {} | grep mysymbol" \;

Find all *.sql files in maximum 1 level down the current directory, process it with sed and then send the output to a mysql command
find -maxdepth 1 -name '*.sql' -exec cat '{}' \; | sed -e 's/ , );/1,1);/g' | mysql -D ootp

Find all *.sql files in maximum 1 level down the current directory, process it with sed and then send the output to a mysql command
find -maxdepth 1 -name '*.sql' -exec sed -e 's/ , );/1,1);/g' '{}' + | mysql -D ootp

Find all *.sql files in maximum 1 level down the current directory, process it with sed and then send the output to a mysql command
find -maxdepth 1 -name '*.sql' -exec sed -e 's/ , );/1,1);/g' '{}' | mysql -D ootp

Find all *.sql files in maximum 1 level down the current directory, process it with sed and then send the output to a mysql command
find -maxdepth 1 -name '*.sql' -print0 \; | xargs -0 sed -e 's/ , );/1,1);/g'  | mysql -D ootp

Find all *.sql files in maximum 1 level down the current directory, process it with sed and then send the output to a mysql command
find . -maxdepth 1 -name '*.sql' -exec "sed -e 's/ , );/1,1);/g' '{}' | /usr/bin/mysql -D ootp" \;

Find all *.sql file that are not newer than  $oldest_to_keep excluding the  $oldest_to_keep file
find . -name \*.sql -not -samefile $oldest_to_keep -not -newer $oldest_to_keep

Find all *.srt files under directory named 'working' and show the first one found
find working -type f -name "*.srt" | head -1

Find all *.swp files/directories under current directory
find . -name "*.swp"

Find all *.swp files/directories under current directory and print the list to a file named 'rm'
find . -name "*.swp" > rm

Find all *.tar.gz files/directories under /directory/whatever which were modified more than $DAYS ago
find /directory/whatever -name '*.tar.gz' -mtime +$DAYS

Find all *.tar.gz files/directories under /directory/whatever which were modified more than $DAYS ago and show a message if no files were found
find /directory/whatever -name '*.tar.gz' -mtime +$DAYS | grep 'tar.gz' || echo "You don't have files older than $DAYS days"

Find all *.tex files/directories in maximum 2 levels down the current directory
find . -maxdepth 2 -name '*.tex'

Find all *.tex regular files in maximum 2 levels down the current directory
find . -type f -maxdepth 2 -name "*.tex"

Find all *.texi files in /usr/local/doc
find /usr/local/doc -name '*.texi'

Find all *.txt, *.html files under /basedir that match the case insensitive pattern *company* in their names
find /basedir/ \( -iname '*company*' -and \( -iname '*.txt' -or -iname '*.html' \) \) -print0

Find all *.txt and *.json files
find . -type f \( -name "*.txt" -o -name "*.json" \)

Find all *.txt and *.json files in current directory
find . -type f \( -name "*.txt" -o -name "*.json" \)

Fint all *.txt files/directories in entire file system without descending to other file system and without error reporting
find / -name  "*.txt" -mount 2> /dev/null

Fint all *.txt files/directories in entire file system without descending to other file system and without error reporting
find / -name  "*.txt" -xdev 2> /dev/null

Find all *.txt files/directories in entire file system
find / -name "*.txt"

Fint all *.txt files/directories under /mnt/msdos and without error reporting
find /mnt/msdos  -name "*.txt" 2> /dev/null

Find all *.txt files/directories under current directory
find -name '*.txt'

Find all *.txt files/directories under current directory
find -name \*.txt

Find all *.txt files/directories under current directory
find . -name "*.txt"

Find all *.txt files/directories under current directory
find . -name "*.txt" -print

Find all *.txt files/directories under current directory
find . -name '*.txt'

Find all *.txt files/directories under current directory
find . -name *.txt -print

Find all *.txt files/directories under current directory and execute process command for each of them
find . -name '*.txt' -exec process {} \;

Find all *.txt files/directories under current directory and execute process for each of them
find . -name \*.txt -exec process {} \;

Find all *.txt files/directories under current directory and execute process for each of them
find . -name \*.txt -print0 | xargs -0 -I{} process {} argument

Find all *.txt files/directories under current directory and execute process once with all of them as arguments
find . -name \*.txt -exec process {} +

Find all *.txt files/directories under current directory and execute process once with all of them as arguments
find . -name \*.txt -print0 | xargs -0 process

Find all *.txt files/directories under current directory and execute process_one for each of them
find . -name "*.txt -exec process_one {} ";"

Find all *.txt files/directories under current directory and execute process_one for each of them
find . -name "*.txt" -print0 | xargs -0 -n 1 process_one

Find all *.txt files/directories under current directory and execute the python code 'import sys; print sys.argv[1:]' with the file paths as arguments
find . -name "*.txt" | xargs python -c 'import sys; print sys.argv[1:]'

Find all *.txt files/directories under current directory and execute the python script hello.py for each of them with the file path as an argument to the script
find . -name "*.txt" | python hello.py

Find all *.txt files/directories under current directory and execute the python script hello.py with all their paths as arguments
find . -name "*.txt" -print0 | xargs -0 python hello.py

Find all *.txt files/directories under current directory and execute the python script hello.py with all their paths as arguments
python hello.py `find . -name "*.txt"`

Find all *.txt files/directories under current directory and execute the python script myscript.py with all their paths as arguments to the script
find . -name "*.txt" -exec python myscript.py {} +

Find all *.txt files/directories under current directory discarding 'Permission denied' errors
find . -name "*.txt" -print | grep -v 'Permission denied'

Find all *.txt files/directories under current directory discarding errors
find . -name "*.txt" -print 2>/dev/null

Find all *.txt files/directories under current directory terminating their names/paths with null character
find . -name '*.txt' -print0

Find all *.txt files except for those on other file systems
find / -name  "*.txt" -mount 2> /dev/null

Find all *.txt files except for those on other file systems
find / -name  "*.txt" -xdev 2> /dev/null

Find all *.txt files in directory tree /mnt/msdos suppressing error messages
find /mnt/msdos  -name "*.txt" 2> /dev/null

Find all *.txt files under / and print their sizes and paths
find / -name '*.txt' -exec du -hc {} \;

Find all *.txt files under /foo and delete them
find /foo -name "*.txt" -delete

Find all *.txt files under /foo and print their total size
find /foo -name "*.txt" -exec du -hc {} + | tail -n1

Find all *.txt files under current directory and print their timestamps and paths
find . -name "*.txt" -printf "%T+ %p\n"

Find all *.txt files under current directory that contains the regex 'pattern' and list them with their filenames and matches
find . -type f -name '*.txt' -exec egrep pattern {} /dev/null \;

Find all *.txt files under current directory that match the regex c|d|z in their names
find . -name '*.txt' | perl -lne 'print if /c|d|z/'

Find all *.txt files under the current directory whose names are not "File.txt"
find . -maxdepth 1 -type f -name '*.txt' -not -name File.txt

Find all *.txt files under the current directory whose names are not "File.txt"
find . -maxdepth 1 -type f -regex '.*\.txt' -not -name File.txt

Find all *.txt (case insensitive) files of user root under / directory and show a few lines of output from the beginning
find / -user root -iname "*.txt" | head

Find all *.txt files of user Tecmint under /home directory
find /home -user tecmint -iname "*.txt"

Find all *.txt files on the vfat file system
find / -name  "*.txt" -fstype vfat 2> /dev/null

Find all *.txt files that reside under and below /home/wsuNID/
find /home/wsuNID/ -name "*.txt"

Find all *.wav files under current directory that match 'export' in their names and pipe the output to ./calc_space
find -type f -name "*.wav" | grep export | ./calc_space

Find all *.xml files under current directory
find -name *.xml

Find all *.xml.bz2 files under current directory
find . -name \*.xml.bz2

Find all *.xml.bz2 files under current directory
find . | grep ".xml.bz2$"

Find all *.xml.bz2 files under current directory and run the command find_graph with -build_graph, $i.graph and $i as it's arguments where $i is expanded to each file path
for i in `find . | grep ".xml.bz2$"`; do find_graph -build_graph $i.graph $i; done

Find all *.zip files under current directory and unzip them in the same directory as the files
find . -name '*.zip' -exec sh -c 'unzip -d "`dirname \"{}\"`" "{}"' ';'

Find all *.zip files under current directory and unzip them in the same directory as the files
find . -name '*.zip' -exec sh -c 'unzip -d `dirname {}` {}' ';'

Find all *.zip files under current directory and unzip them in the same directory as the files
find . -name '*.zip' -execdir unzip '{}' ';'

Find all *1234.56789* files/directories under current directory
find . -name '*1234.56789*'

Find all *Company* files/directories under /root/of/where/files/are directory
find /root/of/where/files/are -name *Company*

Find all *FooBar* files/directories under current directory and copy them to ~/foo/bar
find -name '*FooBar*' -print0 | xargs -0 cp -t ~/foo/bar

Find all *FooBar* files/directories under current directory and copy them to ~/foo/bar
find . -name "*FooBar*" -exec sh -c 'cp -- "$@" ~/foo/bar' sh {} +

Find all *FooBar* files/directories under current directory and copy them to ~/foo/bar
find . -name '*FooBar*' -exec cp -t ~/foobar -- {} +

Find all *bar files/directories under current directory
find -name *bar

Find all *blue* files/directories under /myfiles
find /myfiles -name '*blue*'

Find all *company* files/directories under /root/of/where/files/are directory
find /root/of/where/files/are -name *company*

Find all *conf* files recursively under current directory
find . -name *conf*

Find all *conf* files recursively under current directory, search for any lines matching the string 'matching_text' in those files and redirect the output to matching_text.conf.list
find . -name *conf* -exec grep -Hni 'matching_text' {} \; > matching_text.conf.list

Find all *fink* files/directories under current directory
find . -name "*fink*" -print

Find all *foo files/directories under current directory
find . -name '*foo'

Find all *foo files/directories under current directory (error prone)
find . name *foo

Find all *fstab* files under and below /etc
find /etc -name *fstab*

Find all *gz files under asia and emea directory and print their names and line counts to file_count.txt
find asia emea -type f -name "*gz" | while IFS= read -r fname; do printf "%s %s\n" "$fname" $(gzip -dc "$fname" | wc -l) >> file_count.txt; done

Find all *shp* directories under current directory and move '*' (literal) file/directory inside those directories to shp_all
find . -name '*shp*'   -execdir mv '{}/*' shp_all ';'

Find all *shp* directories under current directory and move all regular files inside those directories to ../shp_all/
mv $(find $(find . -name "*shp*" -printf "%h\n" | uniq) -type f) ../shp_all/

Find all *shp* directories under current directory and move their contents to ../shp_all/
mv $(find . -name "*shp*" -printf "%h\n" | uniq)/* ../shp_all/

Find all *shp* files/directories under current directory
find . -name '*shp*'

Find all *shp* files/directories under current directory and move them to ../shp_all/
find . -name "*shp*" -exec mv {} ../shp_all/ \;

Find all *stat files/directories under /usr
find /usr -name *stat

Find all *weservice* (case insensitive) files under current directory and restart the services provided by them
find -iname '*weservice*'|xargs -I {} service {} restart

Find all .* files excluding list_files (case insensitive) under current directory
find . -iname ".*" \! -iname 'list_files'

find all .bak files in or below the current directory and move them to ~/.old.files directory:
find . -name "*.sh" -print0 | xargs -0 -I {} mv {} ~/back.scripts

Find all .bak files starting from the current directory and delete them
find . -iname "*.bak" -type f -print | xargs /bin/rm -f

Find all .c, .h files in the current directory tree and search them for string "expr"
find . -name '*.[ch]' | xargs grep -E 'expr'

Find all .c and .h files in the current directory tree and search them for "expr"
find -name '*.[ch]' | xargs grep -E 'expr'

Find all .core files on the system starting from / and delete them
find / -name "*.core" -print -exec rm {} \;

Find all .core files on the system starting from / and delete them
find / -name "*.core" | xargs rm

Find all .gif files in the /var/www directory tree
find /var/www -name *.gif

Find all .gif files in the /var/www directory tree that are between 5 kB and 10 kB in size
find /var/www -name *.gif -size +5k -size -10k

Find all .gz archives in the /path/to/dir directory tree
find /path/to/dir -name "*.gz" -type f

Find all .gz archives in the current directory tree
find . -name '*.gz'

Find all .gz archives in the current directory tree and check if they are valid
find "*.gz" -exec gunzip -vt "{}" +

Find all .gz archives in the current directory tree and check if they are valid
find . -name '*.gz' | xargs gunzip -vt

Find all .gz archives in the current directory tree and check if they are valid
find . -name *.gz -exec gunzip '{}' \;

Find all .java files under and below the current directory
find . -name '*.java'

Find all .java files  under current directory
find . -print | grep '\.java'

Find all .java files starting from the current folder
find * -name "*.java"

Find all .java files starting from the current folder
find . -name "*.java"

Find all .java files whose name contains "Message"
find . -print | grep '.*Message.*\.java'

Find all .jpg files in the current directory and below
find -name '*.jpg

Find all .jpg files in the current directory and below.
find . -name “*.jpg”

Find all .less files in the current directory tree
find . -name *.less

Find all .mp3 files starting from the current directory
find . -type f -iname *.mp3

Find all .mp3 files starting from the current directory and delete them
find . -type f -iname *.mp3 -delete

Find all .mp3 files with more than 10MB and delete them
find / -type f -name *.mp3 -size +10M -exec rm {} \;

Find all .mp3 files with more then 10MB and delete them from root directory .
find /  -type f -name *.mp3 -size +10M -exec rm  {} \;

Find all .php files in all directory trees matching pattern `/srv/www/*/htdocs/system/application/' and search those files for string "debug ("
find /srv/www/*/htdocs/system/application/ -name "*.php" -exec grep "debug (" {} \; -print

Find all .php files in all directory trees matching pattern `/srv/www/*/htdocs/system/application/' and search those files for string "debug ("
find /srv/www/*/htdocs/system/application/ -name "*.php" -exec grep -H "debug (" {} +

Find all .php files in all directory trees matching pattern `/srv/www/*/htdocs/system/application/' and search those files for string "debug ("
find /srv/www/*/htdocs/system/application/ -name "*.php" -print0 | xargs -0 grep -H "debug ("

Find all .php files starting from the root directory /
find / -name "*.php"

Find all .php files starting from the root directory and ignoring /media
find / -name "*.php" -print -o -path '/media' -prune

find all .pm, .pl files in /users/tom and search for multiple pattern in same files and display the matched file names
find /users/tom -name '*.p[lm]' -exec grep -l -- '->get(' {} + | xargs grep -l '#hyphenate'

Find all .py files in the current directory except "setup.py" and those beginning with "test_"
find . -maxdepth 1 -mindepth 1 \( -name '*.py' -not -name 'test_*' -not -name 'setup.py' \)

Find all .rb files owned by root in the /apps/ folder and below that have been accessed in the last two minutes.
find /apps/ -user root -type f -amin -2 -name *.rb

Find all .rpm files and change their permissions to 755
find / -name *.rpm -exec chmod 755 '{}' \;

Find all .sh files in or below the current directory and move them to folder ~/back.scripts
find . -name "*.sh" -print0 | xargs -0 -I file mv file ~/back.scripts

Find all .sh files in or below the current directory and move them to folder ~/back.scripts
find . -name "*.sh" -print0 | xargs -0 -I {} mv {} ~/back.scripts

Find all .sh files in the current directory tree and remove them
find . -name "*.sh" -exec rm -rf '{}' \

Find all .sh files in the current directory tree and remove them
find . -name "*.sh" -print0 | xargs -0 rm -rf

Find all .sh files in the current directory tree and remove them
find . -name "*.sh"| xargs rm -rf

Find all .sql files in the current directory recursively and apply script "scriptname" to them
find . -name '*.sql' -exec scriptname {} +

Find all .sql files in the current directory recursively and print their path names separated by zeroes
find . -name '*.sql' -print0

Find all .tmp files under and below the /tmp/ directory and remove them
find /tmp -name "*.tmp"| xargs rm

Find all .txt files except README.txt
find . -type f -name "*.txt" ! -name README.txt -print

Find all .txt files in current  directory and rename with  .html .
find  . -type f -name "*.txt" -exec mv {} `basename {} .html` .html \;

Find all .txt files in the /home/user1 directory tree and copy them to /home/backup
find /home/user1 -name '*.txt' | xargs cp -av --target-directory=/home/backup/ --parents

Find all .txt files in the current directory tree and edit them with `vim'
find . -name "*.txt" | parallel -Xj1 --tty vim

Find all .txt files in the current directory tree and edit them with `vim'
find . -name "*.txt" | parallel -j1 --tty vim

Find all .txt files in the current directory tree and edit them with `vim'
find . -name "*.txt" | xargs bash -c '</dev/tty vim "$@"' ignoreme

Find all .txt files in the current directory tree and save their path names to /tmp/logfile
find /full/path/to/dir -name '*.txt' -print0 | xargs -0 >/tmp/logfile

Find all .txt files in the current directory tree on a BSD system and edit them with `vim'
find . -name "*.txt" | xargs -o vim

Find all .txt files in the dir/ directory tree and copy them along with times, permissions, and ownership to dir_txt/
find dir/ -name '*.txt' | xargs cp -a --target-directory=dir_txt/ --parents

Find all .txt files in the user's home directory and below.
find ~/ -name '*.txt'

Find all .txt files under the current directory and below
find -name \*.txt

Find all .txt files under the current directory and below
find . -name "*.txt"

Find all .txt files under the current directory and below
find . -name '*.txt' -print0

Find all .txt files under the current directory and below suppressing error messages
find . -name "*.txt" -print 2>/dev/null

Find all .txt  files list & List the first lines of text files
find $HOME/. -name *.txt -exec head -n 1 -v {} \; > report.txt

Find all .txt files of user Tecmint under /home directory
find /home -user tecmint -iname "*.txt"

Find all .zip files in the current directory tree
find . -depth -name *.zip

Find all .zip files in the current directory tree and unzip them
find . -depth -name '*.zip' -exec /usr/bin/unzip -n {} \;

Find all .zip files in the current directory tree and unzip them deleting the archives on success
find . -depth -name '*.zip' -exec /usr/bin/unzip -n {} \; -delete

Find all .zip files in the current directory tree and unzip them deleting the archives on success
find . -depth -name '*.zip' -exec /usr/bin/unzip -n {} \; -exec rm {} \;

Find all .zip files starting from the current directory which are owned by user tommye
find . -type f -user tommye -iname "*.zip"

Find all /path/to/check/* regular files without descending into any directory
find /path/to/check/* -maxdepth 0 -type f

Find all 0644 permission files/directories under current directory tree and show only the first 10 of them
find . -perm 0644 | head

Find all 1.txt, 2.txt and 3.txt files under current directory and change the permission to 444
find . \( -name 1.txt -o -name 2.txt -o -name 3.txt \) -print|xargs chmod 444

Find all 100MB+ files and delete them
find / -size +100M -exec rm -rf {} \;

Find all 100MB files in file system and delete them using rm command
find / -size +100M -exec rm -rf {} \;

Find all 15MB files
find / -size 15M

Find all 15MB files in entire file system
find / -size 15M

Find all 1US* files/directories under current directory
find . -name '1US*'

Find all 2*.data files/directories under jcho directory
find jcho -name 2*.data

Find all 400 permission files under /data directory
find /data -type f -perm 400

Find all 400 permission files under /data directory
find /data -type f -perm 400 -print

Find all 400 permission files under /data directory and change their permission to 755
find /data -type f -perm 400 -print | xargs chmod 755

Find all 400 permission files under /data directory and print 'Modifying ' appended with file path for each of them
find /data -type f -perm 400 -exec echo Modifying {} \;

Find all 50MB files
find / -size 50M

Find all 50MB files in file system
find / -size 50M

Find all 664 permission files/drectories under current directory tree
find . -perm -664

Find all 755 permission regular files under current directory tree
find . -type f -perm 755

Find all 777 permission directories under current directory and  set permissions to 755
find . -type d -perm 777 -print -exec chmod 755 {} \;

Find all 777 permission files/directories under current directory tree
find -perm 777

Find all 777 permission files and use chmod command to set permissions to 644
find / -type f -perm 0777 -print -exec chmod 644 {} \;

Find all 777 permission files in entire file system and set permissions to 644
find / -type f -perm 0777 -print -exec chmod 644 {} \;

Find all 777 permission regular files and use chmod command to set permissions to 644
find / -type f -perm 0777 -print -exec chmod 644 {} \;

Find all ES* and FS_* files under current directory
find . -type f \( -iname "ES*" -o -iname "FS_*" \)

Find all Lemon*.mp3 files under current directory and run mplayer with these files
find . -name 'Lemon*.mp3' -exec mplayer {} ';'

Find all Lemon*.mp3 files under current directory and run mplayer with these files
find . -name 'Lemon*.mp3' -print0 | xargs -0 mplayer

Find all Lemon*.mp3 files under current directory and run mplayer with these files
find . -name 'Lemon*.mp3' -print0 | xargs -­0 -i mplayer '{}'

Find all Name* files under ../../$name-module and rename them by replacing 'Name' with $Name (will be expanded in the current shell) in their names
find ../../$name-module -name 'Name*' -type f -exec bash -c "mv \"\$1\" \"\${1/Name/$Name}\"" -- {} \;

Find all Name* files under ../../$name-module and rename them by replacing 'Name' with $Name (will be expanded in the current shell) in their names
find ../../$name-module -print0 -name 'Name*' -type f | xargs -0 rename "s/Name/$Name/"

Find all Name* files under ../../$name-module and rename them by replacing 'Name' with $Name (will be expanded in the sub-shell) in their names
find ../../$name-module -name 'Name*' -type f -exec bash -c 'mv "$1" "${1/Name/$Name}"' -- {} \;

Find all hard links to file1 under /home directory
find /home -xdev -samefile file1

Find all hard links to file /path/to/file that exist under the current directory tree
find . -samefile /path/to/file

Find all flies under current directory excluding *.png files and print the file paths (with match count) that match the case insensitive regex 'foo=' in their contents
find . -not -name '*.png' -o -type f -print | xargs grep -icl "foo="

Find all aliencoders.[0-9]+ files under /home/jassi/ directory
find /home/jassi/ -type f -name "aliencoders.[0-9]+"

find all log files larger then 100MB  in /home directory and delete them .
find /home -type f -name *.log -size +100M -exec rm -f {} \;

Find all strings matching pattern "^${KEY}${DELIMITER}" in $FILE file and print rest of string after $DELIMITER
cat "$FILE" | grep "^${KEY}${DELIMITER}" | cut -f2- -d"$DELIMITER"

Find all broken symlinks in maximum 1 level down the $path directory
find -L $path -maxdepth 1 -type l

Find all broken symlinks including cyclic links under /path/to/search directory
find /path/to/search -type l -exec test ! -e {} \; -print

Find all broken symlinks under current directory
find -L . -type l

Find all broken symlinks under current directory
find -type l -xtype l

Find all broken symlinks under current directory
find -xtype l

Find all broken symlinks under current directory
find . -type l -! -exec test -e {} \; -print

Find all broken symlinks under current directory
find . -type l -exec sh -c "file -b {} | grep -q ^broken" \; -print

Find all broken symlinks under current directory
find . -type l -xtype l

Find all broken symlinks under current directory
find . -xtype l

Find all broken symlinks under current directory
find ./ -type l -exec file {} \; |grep broken

Find all btree*.c files under current directory
find . -type f -name 'btree*.c'

Find all build* directories under /var/www/html/ and print all but first 5 appending with the string 'rf '
find /var/www/html/ -type d -name "build*" | sort | tail -n +5 | xargs -I % echo -rf %

Find all build* directories under /var/www/html/ and reverse sort them
find /var/www/html/ -type d -name "build*" | sort -r

Find all C source code files from the current directory tree that contain "keyword" in their pathnames, ignoring the case
find . -type f \( -iname “*.c” \) |grep -i “keyword”

find all case-insensitive php or pthml files, which whole path does not contain /some/directory case-insensitivily , and excute xgettext which whole name as   parameter
find /project/directory -iname '*.php' -or -iname '*.phtml' | grep -iv '/some/directory' | xargs xgettext

Find all catalina* files/directories under /path/to/search/in
find /path/to/search/in -name 'catalina*'

find all class files or sh script files  in the current folder
find . -type f \( -name "*.class" -o -name "*.sh" \)

Find and compress all .pl files in the current directory tree
find . -name "*.pl" | xargs tar -zcf pl.tar.gz

Find and uncompress all files in the current directory tree ending in ".csv.gz"
find . -name '*.csv.gz' -exec gzip -d {} \;

Find and uncompress all files in the current directory tree ending in ".csv.gz"
find . -name '*.csv.gz' -print0 | xargs -0 -n1 gzip -d

find all configuration files in a folder
find /home/pat -iname "*.conf"

find all CSS files that do something with your HTML ID #content
find . -name "*.css" -exec grep -l "#content" {} \;

Find all CSS files
find . -name "*.css"

Find all CSS files that do something with HTML ID #content
find . -name "*.css" -exec grep -l "#content" {} \;

find all data files in current folder which have not been changed in the last 60 minutes and display their name without extension
find . -iregex "./[^/]+\.dat" -type f -cmin +60 -exec basename {} \;

Find and delete all hard links in the /home directory to file1
find /home -xdev -samefile file1 -exec rm {} +

Find and delete all hard links in the /home directory to file1
find /home -xdev -samefile file1 -print0 | xargs -0 rm

Find and delete all hard links in the /home directory tree to file1
find /home -xdev -samefile file1 | xargs rm

Find and delete all core files in the user's home directory and below.
find ~/ -name 'core*' -exec rm {} \

Finds and deletes all empty folders (ones that contain no files or subfolders).
find ./ -type d -exec rmdir --ignore-fail-on-non-empty {} 2>/dev/null \;

Find all directories and for each of them, print an mv command to move it to /new/location
find . -type d   -execdir echo /bin/mv {} /new/location \;

Find all directories at level 3 of directory tree $from_dir
find $from_dir -mindepth 3 -maxdepth 3 -type d

Find all directories by the name `httpdocs' on the system
find / -type d -name 'httpdocs'

Find all directories by the name `httpdocs' on the system
find / -type d -name httpdocs

Find all directories by the name `httpdocs' on the system
find / -type d -name httpdocs 2> /dev/null

Find all directories containing 'linux' in their names under '/root' directory tree
find  /root -type d -iname "*linux*"

Find all directories in /path/to/dir/ without going into sub-directories
find /path/to/dir/ -mindepth 1 -maxdepth 1 -type d

Find all directories in /path/to/dir/ without going into sub-directories and append a null character at the end of each paths
find /path/to/dir/ -mindepth 1 -maxdepth 1 -type d -print0

Find all directories in 1 level down the current directory
find . -mindepth 1 -maxdepth 1 -type d

Find all directories in current directory (non-recursive) excluding . and print a sorted list in the file a
find . -maxdepth 1 -type d ! -name . | sort > a

Find all directories in directory tree `httpdocs'
find httpdocs -type d

Find all directories in entire file system which are larger than 50KB
find / -type d -size +50k

Find all directories in level 1 down the $queue directory
echo "$queue" | xargs -I'{}' find {} -mindepth 1 -maxdepth 1 -type d

Filnd all directory in root directory with 777 permission and change permision755  with chmod commad .
find / -type d  -perm 777 -print -exec chmod 755 {} \;

Find all directories in maximum 1 level down the current directory that were modified less than 1 day ago
find -maxdepth 1 -type d -mtime -1

Find all directories in maximum 2 levels down the /tmp directory
find /tmp -maxdepth 2 -mindepth 1 -type d

Find all directories in the /data1/realtime directory tree that were last modified more than 5 minutes ago but less than 60 minutes ago
find /data1/realtime -mmin -60 -mmin +5 -type d

Find all directories in the /path/to/base/dir tree
find /path/to/base/dir -type d

find all directories in the current directory which have the name foo and do not have the extension "bar"
find . -name '*foo*' ! -name '*.bar' -type d -print

find all directories in the current folder
find -type d

find all directories in the current folder and do not search in sub directories
find . -type d -maxdepth 1

Find all directories in the current directory tree
find -type d

Find all directories in the current directory tree excluding hidden directories and create them in "../demo_bkp"
find . -not -path \*/.\* -type d -exec mkdir -p -- ../demo_bkp/{} \;

Find all directories in the current directory tree that are not accessible by all
find -type d ! -perm -111

Find all directories in the current directory tree that do not have `execute' permissions for anyone
find . -type d ! -perm -111

Find all directories in the current directory tree that were last modified more than 5 minutes ago but less than 60 minutes ago
find . -mmin -60 -mmin +5

Find all directories in the current directory tree whose names do not contain '.' and move their contents to the current directory
find . -type d ! -iname '*.*' | while read d; do mv $d/* .; done

Find all directories in the current directory tree with "music_files" in their names
find . -type d -iname \*music_files\*

Find all directories in the current one recursively which have the write bit set for "other"
find . -type d -perm -o=w

Find all directories in the current one with "linkin park" in their names and copy them to /Users/tommye/Desktop/LP
find . -maxdepth 1 -type d -iname "*linkin park*" -exec cp -r {} /Users/tommye/Desktop/LP \;

Find all directories under $1/.hg and set their SGID bit
find "$1"/.hg -type d -print0 | xargs chmod g+s

Find all directories under $1/.hg and set their SGID bit
find $1/.hg -type d -exec chmod g+s {} \;

Find all directories under $FOLDER, take the first fields (dot (.) as the delimiter) from their timestamps and reverse sort them numerically
find "$FOLDER" -type d -printf "%T@\n" | cut -f 1 -d . | sort -nr

Find all directories under $ROOT_DIR and show the sub-directories of the directories before the directories themselves
find $ROOT_DIR -type d -depth -print

Find all directories under $d directory and set read-write-execute permission for owner and group and no permission for other for those directories
find $d -type d -exec chmod ug=rwx,o= '{}' \;

Find all directories under $path
find $path -type d

Find all directories under $root and replace all newlines with : (colon) in the output
find $root -type d | tr '\n' ':'

Find all directories under $x directory and set read-write-execute permission for owner and group and no permission for other for those directories
find ${x} -type d -exec chmod ug=rwx,o= '{}' \;

Find all directories under '.cache/chromium/Default/Cache' that are bigger than 100 MB in size excluding single letter directory names
find .cache/chromium/Default/Cache/ -type d -print0 | du -h | grep '[0-9]\{3\}M' | cut -f2 | grep -v '^.$'

Find all directories under '/var/www' directory tree excluding '/var/www/web-release-data' and '/var/www/web-development-data' directories and their sub-directories
find /var/www -type d \( ! -wholename "/var/www/web-release-data/*"  ! -wholename "/var/www/web-development-data/*" \)

Find all directories under 'A' directory tree excluding paths containing the directory 'a'
find A -type d \( ! -wholename "A/a/*" \)

Find all directories under 'project' directory without going into subdirectories that do not match the POSIX egrep regex $PATTERN in their paths and are not empty
find project -maxdepth 1 -mindepth 1 -regextype posix-egrep ! -iregex  $PATTERN  ! -empty -type d

Find all directories under 'test' directory tree that match the regex '.*/course[0-9.]*' in their paths
find test -type d -regex '.*/course[0-9.]*'

Find all directories under 'test' directory tree that match the regex '[course*]' in their paths
find test -regex "[course*]" -type d

Find all directories under 'test' directory tree whose paths match the regex '.*/course[0-9]\.[0-9]\.[0-9]\.[0-9]$'
find test -type d -regex '.*/course[0-9]\.[0-9]\.[0-9]\.[0-9]$'

Find all directories under /directory-path and change their permission to 2755
find /directory-path  -type d -exec sudo chmod 2775 {} +

Find all directories under /fss/fin
find /fss/fin -type d

Find all directories under /home that doesn't contain a file/directory named 'bin'
find /home -type d ! -exec test -e '{}/bin' \; -print

Find all directories under /home/me
find /home/me -type d

Find all directories under /home/me/"$d"
find /home/me/"$d" -type d

Find all directories under /home/me/target_dir_1
find /home/me/target_dir_1 -type d

Find all directories under /home/mywebsite/public_html/sites/all/modules and set their permission to 750
find /home/mywebsite/public_html/sites/all/modules -type d -exec chmod 750 {} +

Find all directories under /home/username/public_html/modules  and set their permission to 750
find /home/username/public_html/modules -type d -exec chmod 750 {} +

Find all directories under /home/username/public_html/sites/all/modules and set their permission to 750
find /home/username/public_html/sites/all/modules -type d -exec chmod 750 {} +

Find all directories under /home/username/public_html/sites/all/themes and set their permission to 750
find /home/username/public_html/sites/all/themes -type d -exec chmod 750 {} +

Find all directories under /home/username/public_html/sites/default/files and set their permission to 770
find /home/username/public_html/sites/default/files -type d -exec chmod 770 {} +

Find all directories under /myfiles directory
find /myfiles -type d

Find all directories under /path/to/Dir and set their permission to 755
sudo find /path/to/Dir -type d -print0 | xargs -0 sudo chmod 755

Find all directories under /path/to/base/cache, /path/to/base/tmp, /path/to/base/logs  and change their permission to 755
find /path/to/base/cache /path/to/base/tmp /path/to/base/logs -type d -exec chmod 755 {} +

Find all directories under /path/to/base/dir and change their permission to 755
chmod 755 $(find /path/to/base/dir -type d)

Find all directories under /path/to/base/dir and change their permission to 755
find /path/to/base/dir -type d -exec chmod 755 {} +

Find all directories under /path/to/base/dir and change their permission to 755
find /path/to/base/dir -type d -print0 | xargs -0 chmod 755

Find all directories under /path/to/dir (no sub-directories) and archive them (with relative paths excluding the preceding './') into files with .tar.gz extension
find /path/to/dir -mindepth 1 -maxdepth 1 -type d -execdir sh -c 'd=${1##*/}; sudo tar -zcpvf "$d".tar.gz "$d"' - {} \;

Find all directories under /path/to/dir (no sub-directories) and archive them (with relative paths) into files with .tar.gz extension
find /path/to/dir -mindepth 1 -maxdepth 1 -type d -execdir sudo tar -zcpvf {}.tar.gz {} \;

Find all directories under /path/to/dir and change their permission to 755
find /path/to/dir -type d -exec chmod 755 {} +

Find all directories under /var/www directory and set their permission to 755
sudo find /var/www -type d -print0 | xargs -0 chmod 755

Find all directories under /var/www/some/subset and set their SGID bit
sudo find /var/www/some/subset -type d -print0 | xargs -0 chmod g+s

Find all directories under and below /home/admin/public_html/, and change their permissions to 755
find /home/admin/public_html/ -type d -exec chmod 755 {} \;

Find all directories under and below /root that match pattern "*linux*", case insensitive
find  /root -type d -iname "*linux*"

Find all directories under and below directory "folder_name", and change their permissions to 775
find folder_name -type d -exec chmod 775 ‘{}’ \;

Find all directories under and below parent_directory
find parent_directory -type d

Find all directories under current directory
find -type d

Find all directories under current directory
find . -type d

Find all directories under current directory
find . -type d -print

Find all directories under current directory and change their permission to 500
find . -type d -exec chmod 500 {} \;

Find all directories under current directory and change their permission to 644
find -type d -print0|xargs -0 chmod 644

Find all directories under current directory and change their permission to 700
find . -type d -exec chmod 700 {} \;

Find all directories under current directory and change their permission to 755
find . -type d -exec chmod 755 {} \;

Find all directories under current directory and set their permission to 755
find -type d exec chmod 755 {} +

Find all directories under current directory and set read-write-execute permission for owner and group and no permission for other for those directories
find . -type d -exec chmod ug=rwx,o= {} \;

Find all directories under current directory and set read-write-execute permission for owner, read-execute permission for group and other for those directories
find . -type d -exec chmod u=rwx,g=rx,o=rx {} \;

Find all directories under current directory and set read-write-execute permission for owner, read-execute permission for group and execute permission for other for those directories
find . -type d -exec chmod u=rwx,g=rx,o=x {} \;

Find all directories under current directory and run ./script.sh for each of them
find . -type d -exec ./script.sh {} \;

Find all directories under current directory and run  /path/to/script.sh for each of them
find . -type d -exec /path/to/script.sh '{}' \;

Find all directories under current directory and run  /path/to/script.sh for each of them
find . -type d -exec /path/to/script.sh \{} \;

Find all directories under current directory and run a command changing into every directory/sub-directory
find . -type d -depth 1 -print0 | xargs -0 sh -c 'for dir; do pushd "$dir" && latexmk -c && popd; done' fnord

Find all directories under current directory excluding  directories (along with their contents) that start with a . (dot) in their names
find -type d -a ! -name '.?*' -o ! -prune

Find all directories under current directory excluding  directories (along with their contents) that start with a . (dot) in their names
find . -type d -a ! -name '.?*' -o -name '.?*' -a ! -prune

Find all directories under current directory excluding those which match the regex /\. in their names
find . -type d | grep -v '/\.'

Find all directories under current directory tree that match the case insensitive regex '^\./course\([0-9]\.\)*[0-9]$' in their paths
find . -type d -iregex '^\./course\([0-9]\.\)*[0-9]$'

Find all directories under current directory tree that were modified $FTIME days ago
find . -type d -mtime $FTIME

Find all directories under current directory whose names are 33 characters long
find . -type d -name "?????????????????????????????????"

Find all directories under current directory whose paths are 5 characters long
find . -regextype posix-extended -type d -regex ".{5}"

Find all directories under minimum 1 level down the  $GIVEN_DIR directory
find "$GIVEN_DIR" -type d -mindepth 1

Find all directories under minimum 1 level down the  $GIVEN_DIR directory with null character as the delimiter
find "$GIVEN_DIR" -type d -mindepth 1 -print0

Find all directories under maximum 1 level down the /parent  directory and set their permission to 700 recursively
find /parent -maxdepth 1 -type d -print0 | xargs -0 chmod -R 700

Find all directories under maximum 1 level down the current directory and set their permission to 700
find . -mindepth 1 -type d | xargs chmod 700

Find all directories under maximum 1 level down the current directory and set their permission to 700 recursively
find . -maxdepth 1 -type d -exec chmod -R 700 {} \;

Find all directories under minimum 1 level down the current directory and set their permission to 755
find  . -type d -mindepth 1 -print -exec chmod 755 {}/* \;

Find all directories under minimum 2 levels down the mydir directory
find mydir -mindepth 2 -type d

Find all directories under media/ directory and change their permission to 700
find media/ -type d -exec chmod 700 {} \;

Find all directories under dir whose names are 33 characters long
find dir -name '?????????????????????????????????'

Find all directories under present working directory
find $PWD -type d

Find all directories under the current directory that is on the same filesystem, execute "/tmp/count_em_$$" with the directory as an argument, sort the result numerically from least value to greatest value
find . -mount -type d -print0 | xargs -0 -n1 /tmp/count_em_$$ | sort -n

Find all directories under var/ directory and change their permission to 700
find var/ -type d -exec chmod 700 {} \;

Find all directories under ~/code without descending into hidden directories and print them appended with : (colon)
find ~/code -name '.*' -prune -o -type d -printf ':%p'

Find all directories named "0" in the current directory tree and create a single tar archive of their RS* subdirectories
find . -type d -name "0" -execdir tar -cvf ~/home/directoryForTransfer/filename.tar RS* \;

Find all directories named "D" in the "A" directory tree
find A -type d -name 'D'

Find all directories named "D" in the current directory tree
find . -name "D" -type d

Find all directories named "D" in the current directory tree
find ./ -type d -name 'D'

Find all directories named "nasa"
find . -name nasa -type d

Find all directories named '.texturedata' under '/path/to/look/in/' directory tree
find /path/to/look/in/ -type d -name '.texturedata'

Find all directories named 'local' in entire file system
find / -name local -type d

Find all directories named 'modules' that don't include any other directory named 'modules'
find . -name modules \! -exec sh -c 'find {} -mindepth 1 -name modules|read' \; -print

Find all directories named 'mydir' under 'local' and '/tmp' directory tree
find local /tmp -name mydir -type d -print

Find all directories named 'octave' under current directory tree
find . -name "octave" -type d

Find all directories named build under the current directory
find . -type d -name build

Find all directories name nasa in the current directory and below.
find . -name nasa -type d

Find all directories named essbase under /fss/fin
find /fss/fin -type d -name  "essbase" -print

Find all directories named CVS, and deletes them and their contents.
find . -type d -name CVS -exec rm -r {} \;

finds all directories named CVS, and deletes them and their contents.
find . -type d -name CVS -exec rm -r {} \;

Find all directories on the system whose size is greater than 50k
find / -type d -size +50k

Find all directories recursively starting from / and skipping the contents of /proc/, and count them
find / -path /proc -prune -o -type d | wc -l

Find all directories starting from / that have permissions 777
find / -type d -perm 0777

Find all directories starting from root that contain the string "99966" in their names
find / -type d -name "*99966*" -print 2>/dev/null

find all directories that names are 'project.images'
find  / -type d -name "project.images"

find all directories that names are 'project.images' and display details
find  / -type d -name "project.images" -ls

Find all directories that start with stat
find . -type d –iname stat*

Find all directories that have been accessed $FTIME days ago under current directory tree
find . -type d -atime $FTIME

Find all directories that have been modified in the last seven days.
find . -mtime -7 -type d

Find all directories whose name is root in / directory
find / -type d -name root

Find all directories whose status were changed $FTIME days ago
find . -type d -ctime $FTIME

Find all directories with 755 permission and change the permission to 700
find . -type d -perm 755 -exec chmod 700 {} \;

Find all directories with permissions 777 under and below /var/www/html, and change their permissions to 755
find /var/www/html -type d -perm 777 -print -exec chmod 755 {} \;

find all directories with the name test in a directory
find /home/john -type d -name test -print

find all directories with the name root in the entire file system.
find / -type d -name root

find all directories with the name like "????-??-??" and which have not been modified in the last 24 hours in the folder /volume1/photo/ipcam and send them as input to the script in the exec section
find /volume1/photo/ipcam -maxdepth 1 -type d -name "????-??-??" -mtime +0 -exec sh -c 'echo /home/pi/Dropbox-Uploader/dropbox_uploader.sh move /ipcam/$(basename {}) /ipcam/archive' \;

Find and display contents of somefile.cf in a Weblogic domain directory
find $(/usr/ucb/ps auwwx | grep weblogic | tr ' ' '\n' | grep security.policy | grep domain | awk -F'=' '{print $2}' | sed -e 's/weblogic.policy//' -e 's/security\///' -e 's/dep\///' | awk -F'/' '{print "/"$2"/"$3"/"$4"/somefile.cf"}' | sort | uniq) 2> /dev/null -exec ls {} \; -exec cat {} \;

Find all duplicate ".jar" files in the current directory tree
find . -type f -printf "%f\n" -name "*.jar" | sort -f | uniq -i -d

Find all empty directories in the current one and delete them
find . -type d -maxdepth 1 -empty -delete

Find all empty directories in the current one and delete them
find . -type d -maxdepth 1 -empty -print0 | xargs -0 /bin/rmdir

Find all empty directories under $somedir and copy /my/configfile into those directories
find "$somedir" -type d -empty -exec cp /my/configfile {} \;

Find all empty directories under /tmp
find /tmp -type d -empty

Find all empty directories under current directory
find . -type d -empty

Find all empty directories recursively starting from the current one and delete them
find . -type d -empty -delete

Find all empty directories recursively starting from the current one and delete them
find . -type d -empty -print0 | xargs -0 /bin/rmdir

find all empty files
find / -empty

find all empty files in /tmp directory .
find /tmp -type f -empty

find all empty files in home directory
find ~ -empty

find all empty files in the current directory ( empty file = size 0 bytes )
find . -size 0

Find all empty files in /tmp
find /tmp -type f -empty

Find all empty files (zero byte files) in your home directory and its sub-directories.
find ~ -empty

Find all empty files in home directory
find ~ -empty

Find all empty files in the current directory and delete them
find . -empty -maxdepth 1 -exec rm {} \;

Find all empty files in the current directory and delete them
find . -maxdepth 1 -type f -empty -delete

Find all empty files in the current directory and delete them
find . -type f -maxdepth 1 -empty -print0 | xargs -0 /bin/rm

Find all empty files under /tmp
find /tmp -type f -empty

Find all empty files under /tmp and below
find /tmp -type f -empty

Find all empty files under a certain path
find /tmp -type f -empty

Find all empty files starting from the current directory and delete them
find . -type f -empty -delete

Find all empty files starting from the current directory and delete them
find . -type f -empty -print0 | xargs -0 /bin/rm

Find all empty folders in the current directory and below
find . -type d -empty

Find all empty regular files in the current directory tree
find . -size 0c -type f

find all java files in the current folder and search for the pattern REGEX
find . -name '*.java' -exec grep REGEX {} \;

find all executable files
find / -executable

find all executable files in /home directory.
find  /home -type f -perm /a=x

Find all Executable files
find / -perm /a=x

Find all executable files
find / -perm /a=x

Find all Executable files in the file system
find / -perm /a=x

Find all executable files under current directory and reverse sort them
find . -perm -111 -type f | sort -r

Find all executable files under current directory and show a few lines of output from the beginning
find . -perm /a=x | head

Find all executables in the current directory tree
find ./ -executable

Find all executable symlinks or upvoter-* files under maximum 1 level down the {} directory
find {} -name 'upvoter-*' -type f -or -type l -maxdepth 1 -perm +111

Find all executable symlinks or upvoter-* files under maximum 1 level down the {} directory
find {} -name 'upvoter-*' -type f -or \( -type l \) -maxdepth 1 -perm +111

Find all executable upvoter-* files (following symlinks) under maximum 1 level down the current directory
find -L -maxdepth 1 -name 'upvoter-*' -type f -perm /111

find all text files in current folder and delete all the files that have the word foo in their name
find . -name ".txt" | grep "foo" | xargs rm

find all text files in current folder and delete them
find . -name ".txt" -exec rm "{}" \;

find all text files in current folder and display all files that have the alphabet a in their name
find . -name ".txt" | grep a

find all text files in current folder and trim the extra spaces in all lines in these files and save it to the original file
find . -type f -name "*.txt" -exec sh -c 'for i;do sed 's/[[:space:]]*$//' "$i">/tmp/.$$ && mv /tmp/.$$ "$i";done' arg0 {} +

find all text files in current folder; which have been modified exactly 5 days ago
find . –name "*.txt" –mtime 5

find all text files in the current directory and display them page wise
find . -name "*.txt" -print

find all text files in the current folder
find -name "*.txt"

find all text files in the current folder which have been modified after the file /tmp/newerthan
find . -name "*.txt" -newer /tmp/newerthan

find all text files in the folder "FFF" and find the md5sum for them
find FFF -name "*.txt" -exec md5sum '{}' \;

find all text files in the folder "FFF" and find the md5sum for them and save the output to a file
find FFF -name "*.txt" -exec md5sum '{}' \; > $TMP_ORI

find all text files in user/directory/ which have been modified today and display the last line of these files
find /user/directory/ -name "*txt" -mtime 0 -type f -exec printf '%s: ' {} \; -exec tail -1 {} \;

find all text files in user/directory/ which have been modified today and display the last line of these files
find /user/directory/ -name "*txt" -mtime 0 -type f -printf '%p: ' -exec tail -1 {} \;

find all text files which have extra extensions in the current folder
find . -name '*.text' -exec $SHELL -c '[ ! -f ${1%.*} ]' $SHELL '{}' ';' -print

find all text files which have extra extensions in the current folder
find . -name '*.text' -exec sh -c 'for i do if [ ! -f "${i%.text}" ]; then echo == $i; fi;done' sh {} +

find all text files which have extra extensions in the current folder
find . -name '*.text' -exec sh -c 'if [ ! -f "$(dirname "$1")/$(basename "$1" .text)" ]; then echo == $1; fi' sh {} \;

Find all text files in the home directory
find ~/ -name '*.txt'

Find all fglrx-libGL* files under and below debian/fglrx/
find debian/fglrx/ -name 'fglrx-libGL*'

Find all fglrx-libglx* files under and below debian/fglrx/
find debian/fglrx/ -name 'fglrx-libglx*'

Filnd all files in root directory with 777 permission and change permision 644  with chmod commad .
find / -type f -perm 777 -print -exec chmod 644 {} \;

Find all file.ext files/directories under /home/kibab directory and print . for each of them
find /home/kibab -name file.ext -exec echo . ';'

Find all file.ext files/directories under present working directory and print . for each of them
find `pwd` -name "file.ext" -exec echo $(dirname {}) \;

Find all file1 and file9 files/directories under current directory
find . -name file1 -or -name file9

find all files & dircetiry in current directory which  have .tmp extension and delete them .
find . -type f -name "*.tmp"  -exec rm -rf {} \;

find all files and directories under the current directory and display the filesize followed by the filename, using the stat command on FreeBSD/OSX
find . -type f -exec stat -f "%z %N" {} \;

find all files and directories under the current directory and display the inode of each one, using printf
find . -printf "%i \n"

find all files and directories under the current directory and display the inode of each one, using the stat command on FreeBSD/OSX
find . -print0 | xargs -0 stat -f '%i '

find all files beneath the current directory that begin with the letters 'Foo' and delete them.
find . -type f -name "Foo*" -exec rm {} \;

find all files ending with ".fq" and give is as input to the fastQC command
find . -name "*.fq" | xargs -n 1 fastqc

find all files ending with "js.compiled" in current folder
find . -type f -name "*.js.compiled"

find all files ending with "js.compiled" in current folder (print0 is used to handle files with newlines in their names)
find ./js/ -name "*.js.compiled" -print0

find all files ending with "js.compiled" in current folder and rename them.
find . -name "*.js.compiled" -exec rename -v 's/\.compiled$//' {} +

find all files having certain word in its name in the current folder
find . -name "*bsd*" -print

find all files in a  directory with default depth size and compress them to lpicpio.2 file
find ~/lpi103-2/ -depth -print0 | cpio --null -o > ../lpicpio.2

find all files in current folder and display the total lines in them
find . | xargs wc -l

find all files in current folder having the name pattern "some_pattern" and move them to folder target_location (GNU VERSION)
find . -name some_pattern -print0 | xargs -0 -I % mv % target_location

find all files in current folder having the name pattern "some_pattern" and move them to target_location (BSD VERSION)
find . -name some_pattern -print0 | xargs -0 -J % mv % target_location

find all files in current folder having the name pattern "some_pattern" and move them to the folder target_location (GNU VERSION)
find . -name some_pattern -print0 | xargs -0 -i mv {} target_location

find all files in current folder using name patterns
find . -iregex ".*packet.*"

find all files in current folder which are bigger than 1 MB and move them to another folder
find . -size +1M -exec mv {} files \+

find all files in current folder which are bigger than 1 MB and move them to another folder
find . -size +1M -print0 | xargs -0 -I '{}' mv '{}' files

find all files in current folder which are bigger than 1MB
find ./ -size +1000k

find all files in current folder which are bigger than 270MB and less than 300MB
find . -size +270M -size -300M

find all files in current folder which are more than 300MB
find . -size +300M

find all files in current folder which are less than 300MB
find . -size -300M

find all files in current folder which have been accessed exactly 10 minutes ago
find . -amin 10

find all files in etc which have been changed in the last 25 hours
find /etc -ctime -1

find all files in home folder which have been modified after a timestamp
find ~ -newer /tmp/timestamp

find all files in home folder which have been modified exactly 1 day before
find ~ -mtime 1 -daystart

find all files in the a direcotry which have been modified in exactly 1 day back
find /home/bozo/projects -mtime 1

find all files in the current directory and sub-directories that were accessed after modifying /etc/hosts
find -anewer /etc/hosts

find all files in the current directory and sub-directories that were modified after the /etc/passwd file was modified
find -newer /etc/passwd

find all files in the current directory excluding those that end with .js or have the words .min or console in their name
find . -type f \( -name "*.js" ! -name "*-min*" ! -name "*console*" \)

find all files in the current directory do not display the files which are not readable
find . ! -readable -prune

find all files in the current directory do not display the files which do not have read permission to all users
find . ! -perm -g+r,u+r,o+r -prune

find all files in the current directory which are bigger than 2MB
find -size +2M

find all files in the current directory which are bigger than 4MB
find . -size +4096k -print

find all files in the current directory with default depth size and compress them to lpicpio.1 file
find . -depth -print0 | cpio --null -o > ../lpicpio.1

find all files in the current folder and search for a word in them.
find . -type f -exec grep "applicationX" {} \;

find all files in the current folder that are modified exactly 1 minute ago
find -mmin 1 -print

find all files in the current folder that are modified exactly 2 minutes ago
find -mmin 2 -print

find all files in the current folder that are not modified in the last 10 minutes
find . -mmin +10 -print

find all files in the current folder that are not modified in the last 240 hours
find . -mtime +10 -print

find all files in the current folder that have a single letter in their name and have not been modified today
find . -name \? -mtime +0

find all files in the current folder that end with ",txt"
find . -name "*,txt"

find all files in the current folder which are bigger than 10bytes
find . — size +10 -print

find all files in the current folder which are bigger than 10MB and less than 50 MB
find . -size +10M -size -50M -print

find all files in the current folder which are of size 0 bytes.
find . -type f -empty

find all files in the current folder which are of size 0 bytes.
find . -type f -size 0b

find all files in the current folder which have only the write permission for the others
find . -perm -0002 -print

find all files in the current folder which have not been accessed in the last 7 days or which are bigger than 20KB
find . -atime +7 -o -size +20480 -print

find all files in the current folder which have not been accessed in the last 7 days or which are bigger than 20KB
find . -atime +7 -o -size +`expr 10 \* 1024 \* 2` -print

find all files in the current folder which have not been changed in the last 48 hours
find ./ -daystart -ctime +2

find all files in the current folder which have not been modified today and whose file name is of length 1
find . -name \? -mtime +0

find all files in the current folder which have been accessed in the last 30 minutes
find . -amin -30

find all files in the current folder which have been modified after /etc/passwd
find -newer /etc/passwd

find all files in the current folder which have been modified after a specific time stamp and do not search in the subfolders;
find -maxdepth 1 -type f newermt "$timestamp"'

find all files in the current folder which have been modified in the last 24 hours
find . -mtime -1 -print

find all files in the current folder which have been modified in the last 24 hours and whose file name is of length 1
find . -name \? -mtime -1

find all files in the current folder which end with macs
find -name '*macs'

find all files in the current folder which start with pro
find . -name pro\*

find all files in the current folder whose size is less than 50KB
find . -size -50k

find all files in the entire file system whose size is more than 100MB
find / -size +100M

find all files in the file system which are modified after the file /tmp/checkpoint
find / -newer /tmp/checkpoint

find all files in the file system which have no user and no group
find / -nouser -nogroup

find all files in the file system which have not been accessed in the last 2 days
find / -atime +2

find all files in the file system which have been accessed in the last 24 hours
find / -atime 0

find all files in the file system which belong to the group users and having the word "filename" in their name.
find / -group users -iname "filename"

find all files in the file system which belong to the user pat and having the word "filename" in their name.
find / -user pat -iname "filename"

find all files in the file system whose size is bigger than 3GB
find / -size +3G

find all files in the file system whose size is exactly 2KB
find / -size 2048c

find all files in the file system with the permissions 777 and having the word "filename" in their name.
find / -perm 777 -iname "filename"

find all files in the folder "myfiles" which are exactly 5 bytes
find /myfiles -size 5

find all files in the folder "myfiles" which have not been accessed in the last 30*24 hours
find /myfiles -atime +30

find all files in the folder /etc which have been modified after /tmp/foo
find /etc -newer /tmp/foo

find all files in the folder /path/to/dir which have been modified between two dates
find /path/to/dir -newermt yyyy-mm-dd ! -newermt yyyy-mm-dd -ls

find all files in the home folder that are modified in the last 24 hours
find $HOME -mtime -1

find all files in the home folder that are modified in the last 7 days
find $HOME -mtime -7

find all files in the home folder which are modified in the last 2 days.
find ~ -type f -mtime -2

find all files under "/usr"
find /usr -print

find all files under the /etc directory and display IP address patterns in them
find /etc -type f -exec cat '{}' \; | tr -c '.[:digit:]' '\n' \ | grep '^[^.][^.]*\.[^.][^.]*\.[^.][^.]*\.[^.][^.]*$'

find all files under the /etc directory and display any IP address patterns in them
find /etc -exec grep '[0-9][0-9]*[.][0-9][0-9]*[.][0-9][0-9]*[.][0-9][0-9]*' {} \;

find all files under the /etc/sysconfig directory that were accessed in the last 30 minutes
find /etc/sysconfig -amin -30

find all files under the current directory, filtering the output through a regular expression to find any lines that contain the word foo or bar.
find ./ | grep -E 'foo|bar'

find all files under the current directory, redirecting error messages to the output and filtering any lines containing the text "Permission denied", writing the remaining output to some_file
find . 2>&1 | grep -v 'Permission denied' > some_file

find all files under the current directory that end in "foo" and execute somecommand on each quoted filename
find . -name "*.foo" -exec somecommand "{}" \;

find all files under the current directory that end in "foo" and, using xargs, execute somecommand once for each filename found
find . -name '*.foo' -print0 | xargs -0 -n 1 somecommand

find all files under the current folder except dir1 dir2 dir3  folder
find . -type d \( -path dir1 -o -path dir2 -o -path dir3 \) -prune -o -print

finds all files modified within a certain time frame recursively
find . -type f -newermt "2013-06-01" \! -newermt "2013-06-20"

find all files not ending in ".html"
find . -type f -not -name "*.html"

find all files read less than 1 minute ago
find . -amin -1

find all files starting with capital letter in the current folder
find . — name "[A‑Z]*" — print

find all files that are readable and writable by their owner
find . -perm -600 -print

find all files that are readable or writable by their owner
find . -perm +600 -print

find all files that have been modified yesterday
find /some/dir -mmin -$((currtime + (24 * 60))) -a -mmin +$((${currtime} + 1))

find all files that have been used more than two days since their status was last changed
find -used +2

find all files that belong to root user
find . -uid 0 -print

find all files  the current folder which have not been accessed in the last 7 days and which are bigger than 20KB
find . -atime +7 -size +20480 -print

find all  files that match "[a-f0-9\-]{36}\.jpg" of grep
find . * | grep -P "[a-f0-9\-]{36}\.jpg"

find all files that were modified between 90 to 100 days ago in home directory and delete then .
find /home -type f -mtime +90 -mtime -100  -exec rm  {} \;

find all files  that names are 'apt'
find  / -name "apt"

find all files  that names are 'apt' and display detailed list
find  / -name "apt" -ls

find all files that names are dir-name-here
find / -name "dir-name-here"

find all files that names are game
find / -name game

find all files that do not have read permission to all
find . -type f ! -perm -444

find all files which name contain 'foo' and path is not dir1 or dir2
find ! -path "dir1" ! -path "dir2" -name "*foo*"

find all files with pattern` '*.mp3'
find / -name *.mp3

find all files with pattern` '*.mp3' and send output into nameoffiletoprintto file
find / -name *.mp3 -fprint nameoffiletoprintto

find all files with the first letter “e” or “f” and last one x in /usr/bin directory:
find /usr/bin -name [ef]*x

find all files without 777 permision
find / -type f ! perm 777

Find all filenames ending with .c in the /usr directory tree
find /usr -name "*.c"

Find all filenames ending with .c in the current directory tree
find -name "*.c"

Find all filenames ending with .c in the current directory tree, case insensitive
find -iname "*.c"

Find all filename.* files/directories under /root/directory/to/search
find /root/directory/to/search -name 'filename.*'

Find all files/directores under '/usr/local' directory tree that contain the word 'blast' in their names
find /usr/local -name "*blast*"

Find all files/directores under '/usr/local' directory tree that case insensitively contain the word 'blast' in their names
find /usr/local -iname "*blast*"

Find all files/directores under /etc and run the file command on each of them
find /etc -print0 | xargs -0 file

Find all files/directores under /etc filter them by searching for 'test' in their name and run the file command on each of them
find /etc -print0 | grep -azZ test | xargs -0 file

Find all files/directores that are newer than /etc/motd and conain the string 'top' at the beginning of their names under user's home directory tree
find ~ -name 'top*' -newer /etc/motd

Find all files & directory which have write permission for group , remove the permission from group
find . -perm -20 -exec chmod g-w {} ;  or  find . -perm -20 -print | xargs chmod g-w

Find all files accessed on the 29th of September, 2008, starting from the current directory
find . -type f -newerat 2008-09-29 ! -newerat 2008-09-30

Find all files/directories 1 level down the current directory and redirect the sorted output to file a
find . -maxdepth 1 | sort > a

Find all files/directories 1 level down the current directory that are enlisted in file 1
comm -12 <(find . -maxdepth 1 | sed -e 's/^.\///' ) <(cat 1)

Find all files/directories 1 level down the ~/bin/FilesDvorak/ directory and redirect the sorted output to file b
(cd ~/bin/FilesDvorak/; find . -maxdepth 1 | sort > b)

Find all files and directories and count them
find ./ | wc -l

Find all files/directories newer than ttt or owned by user 'wn' in entire file system
find / \( -newer ttt -or -user wnj \) -print

Find all files/directories containing 'blah' (case insensitive) in their names that were modified in less than 2 days ago uder current directory tree
find . -iname '*blah*' -mtime -2

Find all files/directories containing 'farm' in their names under '/usr/share' directory tree
find /usr/share -name '*farm*'

Find all files/directories containing 'foo' in their names under current directory tree
find . -name '*foo*'

Find all files/directories containing the case insensitive string something' in their names under current directory tree
find . -iname '*something*'

Find all files/directories following symbolic links under current directory tree that are owned by 'root' user
find . -follow -uid 0 -print

Find all files/directories following symlinks under /path/to/dir/* paths and print the timestamp in YmdHMS format along with their paths
find -L /path/to/dir/* -printf "%TY%Tm%Td%TH%TM%TS|%p\n"

Find all files/directories ignoring *~ files/directories without descending into .snapshot directory with null character as the delimiter
find . -name .snapshot -prune -o \( \! -name *~ -print0 \)

Find all files/directories in 1 level down the current directory
find -mindepth 1 -maxdepth 1

Find all files/directories in all paths expanded by the glob pattern *
find *

Find all files/directories in current directory and execute multiple ANDed commands (cmd1 and cmd2) for each file
find . -exec cmd1 \; -exec cmd2 \;

Find all files/directories in current directory and execute myscript for each of them
find . -exec myscript {} \;

Find all files/directories in current directory and execute myscript with minimal invocation for those files/directories
find . -exec myscript {} +

Find all files/directories in current directory and execute the script itself with minimal invocation for those files/directories
find . -exec $0 {} +

Find all files/directories in current directory and run the command 'command' on each of them invoking the command as few times as possible
find -exec command {} +

Find all files/directories in directories/files taken from the glob pattern '/tmp/test/*' that were modified within the last day (day counted from today)
find /tmp/test/* -daystart -mtime -1

Find all files/directories in entire file system for which owner has at least read/write permissions, or the group has at least read permission, or others have at least read permission
find / -perm /u+rw,g+r,o+r

Find all files/directories in entire file system less than 50 bytes
find / -size -50c

Find all files/directories in entire file system more than 700 Megabytes
find / -size +700M

Find all files/directories in entire file system that are exactly 50 bytes
find / -size 50c

Find all files/directories in entire file system that are owned by "shadow" group
find / -group shadow

Find all files/directories in entire file system that are owned by "syslog" user
find / -user syslog

Find all files/directories in entire file system that match the pattern '<name_pattern>' in their names and print a sorted list of their unique parent directory paths
find / -name '<name_pattern>' | perl -pe 's/(.*\/).*$/$1/' | sort | uniq

Find all files/directories in entire file system that have  "write" bit set for either the owner, the group, or others
find / -perm /222

Find all files/directories in entire file system that have  "write" bit set for either the owner, the group, or others
find / -perm /a+w

Find all files/directories in entire file system that have  "write" bit set for either the owner, the group, or others
find / -perm /u+w,g+w,o+w

Find all files/directories in level $i down the current directory with all positional parameters appended with the find command
find -mindepth $i -maxdepth $i "$@"

Find all files/directories in level 1 down the $queue directory with all positional parameters appended with the find command
echo "$queue" | xargs -I'{}' find {} -mindepth 1 -maxdepth 1 $*

Find all files/directories in maximum 1 level down the current directory which do not have only read permission for 'other'
find . -maxdepth 1 ! -perm  -o=r

Find all files and directories in the current directory tree with "linkin park" in their names and copy them to /Users/tommye/Desktop/LP
find . -iname "*linkin park*" -exec cp -r {} /Users/tommye/Desktop/LP \;

Find all files and directories in the current directory with "linkin park" in their names and copy them to /Users/tommye/Desktop/LP, preserving path hierarchy
find . -iname "*linkin park*" > temp;rsync -arhv --files-from=temp  /Users/tommye/Desktop/LP;rm temp

Find all files/directories in the entire file system and redirect the output to masterfilelist.out file
find  /   -print > masterfilelist.out

Find all files/directories in the paths expanded by the glob pattern '.*'
find .*

Find all files/directories excluding paths that match '.git' or '.gitignore'
find -print0 | grep -vEzZ '(\.git|\.gitignore/)'

Find all files/directories under $1 which have at least execute permission for their owner and set execute permission for group for these files/directories
find "$1" -perm -u+x -print0 | xargs chmod g+x

Find all files/directories under $1 which have at least execute permission for their owner and set execute permission for group for these files/directories
find $1 -perm -u+x -exec chmod g+x {} \;

Find all files/directories under $1 which have at least read permission for their owner and set read permission for group for these files/directories
find "$1" -perm -u+r -print0 | xargs chmod g+r

Find all files/directories under $1 which have at least read permission for their owner and set read permission for group for these files/directories
find $1 -perm -u+r -exec chmod g+r {} \;

Find all files/directories under $TARGET_DIR directory tree matching the posix extended regular expression \".*/$now.*\" (where $now is a variable) and save the output in file $FILE_LIST
find $TARGET_DIR -regextype posix-extended -regex \".*/$now.*\" -fprint $FILE_LIST

Find all files/directories under $dir directory
find "$dir"

Find all files/directories under $dir directory tree which have been modified in the last 3 days
find $dir -mtime -3

Find all files/directories under ${CURR_DIR} directory
cd ${CURR_DIR} && find .

Find all files/directories under '/abs/path/to/directory' directory non-recursively that match the pattern '.*invalidTemplateName.*' in their names
find /abs/path/to/directory -maxdepth 1 -name '.*invalidTemplateName.*'

Find all files/directories under '/directory_path' directory tree that have been modified within the last day
find /directory_path -mtime -1 -print

Find all files/directories under '/etc' directory tree that are greater than 5MB and print their sizes and names
find /etc -size +5M -exec ls -sh {} +

Find all files/directories under '/home/exampleuser/' directory tree whose names end with 'conf' and were modified exactly 3 days ago
find /home/exampleuser/ -name "*conf" -mtime 3

Find all files/directories under '/home/user/' directory tree whose status were changed 10 minutes ago
find /home/user/ -cmin 10 -print

Find all files/directories under '/usr' directory tree that have not been modified in the last 356 days counting days from today
find /usr -mtime +356 -daystart

Find all files/directories under '/usr' directory tree that have been modified exactly 5 minutes ago
find /usr -mmin 5

Find all files/directories under '/usr/local' containing 'blast' (case insensitive) in their names
find /usr/local -iname "*blast*"

Find all files/directories under '/usr/local/games' directory tree that contain the string 'xpilot' in their names
find /usr/local/games -name "*xpilot*"

Find all files/directories under '/usr/share/data' directory tree that match the posix extended regex ".*/20140624.*" in their paths and save the list to '/home/user/txt-files/data-as-of-20140624.txt'
find /usr/share/data -regextype posix-extended -regex ".*/20140624.*" -fprint /home/user/txt-files/data-as-of-20140624.txt

Find all files/directories under '/usr/share/doc' directory tree that contain 'readme' (case insensitive) at the beginning of their names
find /usr/share/doc -iname readme\*

Find all files/directories under '/usr/share/doc' directory tree whose name start with 'README'
find /usr/share/doc -name README\*

Find all files/directories under '/var/log' directory tree that bave been modified today (from the start of the day)
find /var/log -daystart -mtime 0

Find all files/directories under '/var/tmp' directory tree that belong to a user with user id 1000
find /var/tmp -uid 1000

Find all files/directories under 'A' directory tree excluding directory 'A/a' and all of it's contents
find A \! -path "A/a/*" -a \! -path "A/a"

Find all files/directories under 'A' directory tree excluding the paths containing the directory 'a'
find A \! -path "A/a/*"

Find all files/directories under 'my key phrase' directory
find 'my key phrase'

Find all files/directories under 'my key phrase' directory and redirect the output to mylist.txt
find 'my key phrase' > mylist.txt

Find all files/directories under .. directory and copy them to ~/foo/bar
find .. -exec cp -t ~/foo/bar -- {} +

Find all files/directories  under  /eserver6 directory and follow symlinks if needed
find /eserver6 -L

Find all files/directories under /export/home/someone directory in a remote host (somehost) and upload the files/directories to ftp://somehost/tmp/
ssh someone@somehost "cd /export/home/someone && find . -name '*' -print | parallel -j1 'sleep 10;curl -u someone:password ftp://somehost/tmp/ -vT'

Find all files/directories under /export/home/someone directory in a remote host (somehost) and upload the files/directories to ftp://somehost/tmp/
ssh someone@somehost "cd /export/home/someone && find . -name '*' -print| xargs -n1 curl -u someone:password ftp://somehost/tmp/ -vT"

Find all files/directories under /export/home/someone directory in a remote host (somehost) and upload the files/directories to ftp://somehost/tmp/
ssh someone@somehost 'cd /export/home/someone && find . -name "*" -print| (while read file; do curl -u someone:password ftp://somehost/tmp/ -vT "$file"; sleep 10; done)'

Find all files/directories under /home/baumerf/public_html/ that were modified less than 60 minutes ago excluding *.log files/directories
find /home/baumerf/public_html/ -mmin -60 -not -name \*.log

Find all files/directories under /home/baumerf/public_html/ that were modified less than 60 minutes ago excluding error_log files/directories
find /home/baumerf/public_html/ -mmin -60 -not -name error_log

Find all files/directories under /home/bozo/projects directory that were modified 1 day ago
find /home/bozo/projects -mtime 1

Find all files/directories under /home/foo/public_html/ that were modified less than 60 minutes ago
grep ! error_log | find /home/foo/public_html/ -mmin -60

Find all files/directories under /myfiles that are 2560 bytes in size
find /myfiles -size 5

Find all files/directories under /myfiles that were accessed more than 30 days ago
find /myfiles -atime +30

Find all files/directories under /non-existent/directory directory with ~/bin/find
~/bin/find /non-existent/directory -name '*.plist' -print

Find all files/directories under /path directory that were modified more than 30 minutes ago
find /path -mtime +30m

Find all files/directories under /path/to/dir and set directory permission to 0755 and file permission to 0644
find /path/to/dir -type d -exec chmod 0755 '{}' \; -o -type f -exec chmod 0644 '{}' \;

Find all files/directories under /path/to/dir/* paths and print the timestamp along with their paths and stat them
find /path/to/dir/* -printf "%T@|%p|%l" -exec stat -Lc "|%Y.0000000000" {} \;

Find all files/directories under /path/to/dir/* paths and print the timestamp in YmdHMS format along with their paths and object of symlinks
find /path/to/dir/* -printf "%TY%Tm%Td%TH%TM%TS|%p|%l\n"

Find all files/directories under /path/to/files/* paths and print the timestamp in YmdHMS format along with their paths and object of symlinks, stat them and apply the sed replacement "s/(.*\|)([0-9]{4})\-([0-9]{2})\-([0-9]{2}) ([0-9]{2})\:([0-9]{2})\:([0-9]{2}\.[0-9]{9}).*/\1\2\3\4\5\6\7/g" on the output
find /path/to/files/* -printf "%TY%Tm%Td%TH%TM%TS|%p|%l" -exec stat -Lc "|%y" {} \; | sed -r "s/(.*\|)([0-9]{4})\-([0-9]{2})\-([0-9]{2}) ([0-9]{2})\:([0-9]{2})\:([0-9]{2}\.[0-9]{9}).*/\1\2\3\4\5\6\7/g"

Find all files/directories under /proc and run ls command on each.
find /proc -exec ls '{}' \;

Find all files/directories under /usr/tom which matches the extended regex '*.pl| *.pm'  in their names
find /usr/tom | egrep '*.pl| *.pm'

Find all files/directories under /var/www/some/subset and change their owner and group to www-data
sudo find /var/www/some/subset -print0 | xargs -0 chown www-data:www-data

Find all files and directories under current directory
find .

Find all files/directories under current directory
find -print

Find all files/directories under current directory
find -print0 | xargs -0

Find all files/directories under current directory
find .

Find all files/directories under current directory
find ./

Find all files/directories under current directory
find | xargs

Find all files/directories under current directory and append a null character at the end of each path
find -print0

Find all files/directories under current directory and count the number of lines for the output
find |wc -l

Find all files/directories under current directory and put the output into full_backup_dir variable
full_backup_dir="`find . -depth -print0`"

Find all files/directories under current directory and sort them
find | sort

Find all files/directories under current directory and print them
find . -print0 | xargs -I{} -0 echo {}

Find all files/directories under current directory and print them twice in each line
find | xargs -i sh -c "echo {} {}"

Find all files/directories under current directory and print them with newline as the delimiter
find -print | xargs -d'\n'

Find all files/directories under  current directory and rename them by replacing all blank spaces with _ in their paths
IFS=$'\n';for f in `find .`; do file=$(echo $f | tr [:blank:] '_'); [ -e $f ] && [ ! -e $file ] && mv "$f" $file;done;unset IFS

Find all files/directories under current directory and run <script> for each of them
find -exec <script> {}\;

Find all files/directories under current directory and run ipython nbconvert for each of them with the file/directory path as a argument by changing into the parent directory
find -execdir ipython nbconvert {} \;

Find all files/directories under current directory appending a null character at the end of each file name/path
find -print0

Find all files/directories under current directory bypassing file hierarchies in lexicographical order
find -s

Find all files/directories under current directory following symlinks if needed
find -L

Find all files/directories under current directory in maximum 3 levels deep
find -maxdepth 3

Find all files/directories under current directory excluding the paths that match the POSIX extended regex ".*def/incoming.*|.*456/incoming.*"
find . -regex-type posix-extended -regex ".*def/incoming.*|.*456/incoming.*" -prune -o -print

Find all files/directories under current directory matching the case insensitive pattern 'pattern'
find -iname pattern

Find all files/directories under current directory that are greater than 10MB in size
find . -size +10M

Find all files/directories under current directory that match the case insensitive extended regex .*/(EA|FS)_.*
find -E . -iregex '.*/(EA|FS)_.*'

Find all files/directories under current directory that match the case insensitive regex .*/\(EA\|FS\)_.*
find . -iregex '.*/\(EA\|FS\)_.*'

Find all files/directories under current directory that match the case insensitive regex ./\(EA\|FS\)_.*
find . -iregex './\(EA\|FS\)_.*'

Find all files/directories under current directory that were accessed 30 minutes ago
find -amin 30

Find all files/directories under current directory that were accessed less than 1 day ago
find . -atime -1 -print

Find all files/directories under current directory that were accessed more than 25 but less than 35 minutes ago
find -amin +25 -amin -35

Find all files/directories under current directory that were modified exactly 30 minutes ago
find . -mmin 30

Find all files/directories under current directory that were modified later than /reference/file
find . -newer /reference/file

Find all files/directories under current directory tree
find | xargs

Find all files/directories under current directory tree excluding files/directories with name 'query_to_avoid'
find -not -name "query_to_avoid"

Find all files/directories under current directory tree excluding files/directories with name 'query_to_avoid'
find \! -name "query_to_avoid"

Find all files/directories under current directory tree excluding hidden files/directories
find . -not -path '*/\.*'

Find all files/directories under current directory tree that are newer than backup.tar.gz by modification time
find . -newer  backup.tar.gz

Find all files/directories under current directory tree that are owned by 'root'
find . -uid 0 -print

Find all files/directories under current directory tree that belong to the group 'compta'
find -group compta

Find all files/directories under current directory tree that belong to the user 'tom'
find ./ -user tom

Find all files/directories under current directory tree that belong to user 'john'
find . -user john

Find all files/directories under current directory tree that contain '1' or 'k' in their names
find . -name "*[1k]*"

Find all files/directories under current directory tree that contain 'pattern' in their names
find -name "*pattern*"

Find all files/directories under current directory tree that start with 'R' and end with 'VER' in their names and were modified more than 1 day ago
find . -name "R*VER" -mtime +1

Find all files/directories under current directory tree that start with 'test' in their names without descending into directories with the same name pattern
find . -name 'test*' -prune

Find all files/directories under current directory tree that have modified in the last 2 days and contain 'blah' (case insensitive) in their names
find . -iname '*blah*' \( -type d -o -type f \) -mtime -2

Find all files/directories under current directory tree whose names start with 'some_text_2014.08.19'
find . -name 'some_text_2014.08.19*'

Find all files/directories under current directory tree whose names start with 'test' followed by two digits and end with '.txt' extension
find . -regextype sed -regex "./test[0-9]\{2\}.txt"

Find all files/directories under current directory tree whose paths match the pattern '*ACK*1'  (case insensitive)
find . -iwholename "*ACK*1"

Find all files/directories under current directory tree with '.old' extension
find . -name ”*.old” -print

Find all files/directories under current directory tree with inode number 211028 and move them to 'newname.dir'
find . -inum 211028 -exec mv {} newname.dir \;

Find all files/directories under current directory tree wihout descending into './src/emacs' directory
find . -path './src/emacs' -prune -o -print

Find all files/directories under current directory with 'FooBar' in their paths and copy them to ~/foo/bar
find . | grep "FooBar" | (mapfile -t; cp "${MAPFILE[@]}" ~/foobar)

Find all files/directories under current directory with 'FooBar' in their paths and copy them to ~/foo/bar
find . | grep "FooBar" | tr \\n \\0 | xargs -0 -I{} cp "{}" ~/foo/bar

Find all files/directories under current directory with 'FooBar' in their paths and copy them to ~/foo/bar
find . | grep FooBar | xargs -I{} cp {} ~/foo/bar

Find all files/directories under current directory with 'FooBar' in their paths and copy them to ~/foo/bar
find .|grep "FooBar"|xargs -I{} cp "{}" ~/foo/bar

Find all files/directories under current directory with 'FooBar' in their paths and copy them to ~/foo/bar
find .|grep "FooBar"|yargs -l 203 cp --after ~/foo/bar

Find all files/directories under current directory with 'foo' in their paths and copy them to ~/bar
while read line ; do cp "$line" ~/bar ; done < <(find . | grep foo)

Find all files/directories under current directory with 'foobar' (case insensitive) in their names and copy them to ~/foo/bar
find . -iname "*foobar*" -exec cp "{}" ~/foo/bar \;

Find all files/directories under current directory with null character as the delimiter
find -print0

Find all files/directories under current directory with null character as the delimiter
find . -print0

Find all files/directories under current directory which have read-write permission for owner and only read permission for group and others
find -perm -644

Find all files and directories under current directory without crossing over to other partitions
find . -xdev -print0

Find all files and directories under current directory without crossing over to other partitions and archive them into path_to_save.cpio.gz
find . -xdev -print0 | cpio -oa0V | gzip > path_to_save.cpio.gz

Find all files/directories under directory '.cache/chromium/Default/Cache/' which are bigger than 100MB and which are atleast 1 level deep and delete them
find .cache/chromium/Default/Cache/ -mindepth 1 -size +100M -delete

Find all files/directories under test directory
find test

Find all files/directories under Mainfolder directory and redirect the output to outputfle
find Mainfolder > outputfile

Find all files/directories under minimum 1 level down the $FOLDER directory and sort them
find "$FOLDER" -mindepth 1 | sort

Find all files/directories under maximum 1 level down the current directory and print their inode numbers and names
find . -maxdepth 1 -print0 | xargs -0 stat -c '%i %n'

Find all files/directories under minimum 2 level down the current directory and set their permission to 700
find . -mindepth 2 | xargs chmod 700

Find all files/directories under mnt/naspath that were modified in last 24 hours, calculate the total size and redirect the result to /tmp/size.log file
find /mnt/naspath -mtime 0 -print0 | du --files0-from=- -hc | tail -n1 >> /tmp/size.log

Find all files/directories under mnt/naspath without descending into .snapshot directory, calculate the total size and redirect the result to /tmp/size.log file
find /mnt/naspath -mtime 0  -name .snapshot -prune -o \( \! -name *~ -print0 \) | du --files0-from=- -hc | tail -n1 >> /tmp/size.log

Find all files/directories under whatever and ... directory and copy them to /var/tmp
find whatever ... | xargs -d "\n" cp -t /var/tmp

Find all files and directories last modified less than a day ago and copy to "../changeset" creating directories as needed
find * -mtime -1 -daystart -print0 | cpio -pd0 ../changeset

Find all files/directories matching the regex .*sql.*
find -regex .*sql.*

Find all files/directories matching the regex pattern ".*\\.rb$" under current directory
find . -regex ".*\\.rb$"

Find all files/directories named $something under current directory
find -name "$something"

Find all files/directories named '.todo' under $STORAGEFOLDER directory tree and print their parent paths
find "$STORAGEFOLDER" -name .todo -printf '%h\n'

Find all files/directories named '.todo' under $STORAGEFOLDER directory tree and print the parent directory names
find "$STORAGEFOLDER" -name .todo  -exec dirname {} \;

Find all files/directories named '.todo' under $STORAGEFOLDER directory tree and print the parent directory names
find "$STORAGEFOLDER" -name .todo -printf '%h\n'

Find all files/directories named 'Desktop' under current directory
find ./ -name Desktop

Find all files/directories named 'FindCommandExamples.txt' under '/root' directory tree
find /root -name FindCommandExamples.txt

Find all files/directories named 'FindCommandExamples.txt' that belong to the user 'root' in the entire filesystem
find / -user root -name FindCommandExamples.txt

Find all files/directories named 'Waldo' under 'Books' directory tree that is located in user's home directory
find ~/Books -name Waldo

Find all files/directories named 'articles.jpg' under '/home/username/public_html/images' directory tree
find /home/username/public_html/images -name "articles.jpg"

Find all files/directories named 'articles.jpg' under 'images' directory tree
find images -name "articles.jpg"

Find all files/directories named 'articles.jpg' under current directory tree
find . -name "articles.jpg"

Find all files/directories named 'com.apple.syncedpreferences.plist' (case insensitive) under ~/Library directory tree
find ~/Library/ -iname "com.apple.syncedpreferences.plist"

Find all files/directories named 'date' under /usr
find /usr -name date

Find all files/directories named 'document' in maximum 4 levels down the '/usr' directory
find /usr -maxdepth 4 -name document -print

Find all files/directories named 'document' in the entire filesystem
find / -name document -print

Find all files/directories named 'document' in the root filesystem partition
find / -xdev -name document -print

Find all files/directories named 'file' and print them with null character as the delimiter instead of newline
find -name file -print0

Find all files/directories named 'file' without descending into directories with the same name under current directory tree
find -name file -prune

Find all files/directories named 'file1' under current directory tree
find . -name file1 -print

Find all files/directories named 'filename' that belong to user 'username' and group 'groupname' in the entire filesystem
find / -user username -group groupname -name filename

Find all files/directories named 'findcommandexamples.txt' (case insensitive) in the entire filesystem
find  / -iname findcommandexamples.txt

Find all files/directories named 'foo.rb' under current directory tree
find . -name foo.rb

Find all files/directories named 'fprintf.c' under '/usr/src' directory tree
find /usr/src -name fprintf.c

Find all files/directories named 'game' under current directory tree
find . -name game

Find all files/directories named 'java' under /usr directory
find /usr -name java

Find all files/directories named 'javac' under current directory
find . -name 'javac'

Find all files/directories named 'my.txt' in the entire filesystem
find / -name "my.txt"

Find all files/directories named 'myfile' under your home directory
find ~ -name myfile

Find all files/directories named 'pattern' under current directory tree
find . -name "pattern" -print

Find all files/directories named 'photo.jpg' (case insensitive) under current directory tree
find . -iname "photo.jpg"

Find all files/directories named 'photo.jpg' under current directory tree
find -name photo.jpg

Find all files/directories named 'photo?.jpg' under current directory tree
find . -name photo\?.jpg

Find all files/directories named 'photoA.jpg' under current directory tree
find . -name photoA.jpg

Find all files/directories named 'query' (case insensitive) under current directory
find -iname "query"

Find all files/directories named 'query' under current directory
find -name "query"

Find all files/directories named 'query' (case insensitive) under current directory tree
find -iname "query"

Find all files/directories named 'query' under current directory tree
find -name "query"

Find all files/directories named 'test' under current directory tree
find . -name test

Find all files/directories named 'testfile.txt' under current directory tree
find . -name testfile.txt

Find all files/directories named 'top' (case insensitive) in the entire filesystem
find / -iname top

Find all files/directories named 'top' in the entire filesystem
find / -name top

Find all files/directories named file1 in maximum 2 levels down the current directory
find -maxdepth 2 -name file1

Find all files/directories named file1 under current directory
find -name file1

Find all files/directories named Root under current directory and copy them to newRoot
find . -name Root | xargs cp newRoot

Find all files/directories named modules under current directory
find . -name modules

Find all files/directories named modules under current directory and list them twice
find . -name modules \! -exec sh -c 'find -name modules' \;

Find all files/directories named file in 2 and 3 levels down the current directory
find -mindepth 2 -maxdepth 3 -name file

Find all files/directories named file in minimum 4 levels down the current directory
find -mindepth 4 -name file

Find all files/directories named orm.properties in entire file system
sudo find / -name "orm.properties"

Find all files/directories named orm.properties under  /eserver6 directory
find /eserver6 -name "orm.properties"

Find all files/directories named orm.properties under  /eserver6/share/system/config/cluster directory
find /eserver6/share/system/config/cluster -name "orm.properties"

Find all files/directories named orm.properties under current directory
find . -name "orm.properties"

Find all files and directories on the system whose name is `filedir'
find / -name filedir

Find all files/directories owned by the user 'bob' under '/home' directory tree
find /home -user bob

Find all files/directories owned by user 'joebob' under '/some/directory' directory tree
find /some/directory -user joebob -print

Find all files/directories owned by user 'michel' under current directory
find -user michel

Find all files/directories not with the name 'query_to_avoid' under current directory
find -not -name "query_to_avoid"

Find all files/directories not with the name 'query_to_avoid' under current directory
find \! -name "query_to_avoid"

Find all files and directories starting from the current directory
find .

Find all files/directories starting with 'onlyme' in their names under current directory tree in minimum 1 level deep
find . -mindepth 1 -name 'onlyme*'

Find all files/directories startring with 'onlyme' in their names under current directory without going into sub-directories
find . -maxdepth 1 -name 'onlyme*'

Find all files/directories starting with 'readme' (case insensitive) under '/usr/share/doc' directory tree
find /usr/share/doc -name '[Rr][Ee][Aa][Dd][Mm][Ee]*'

Find all files/directories that are newer than 'backup.tar.gz' by modification time
find . -newer  backup.tar.gz

Find all files/directories that are newer than 'ttt' by modification time or owned by the user 'wnj' in the entire filesystem
find / \( -newer ttt -or -user wnj	\) -print

Find all files/directories that are not newer than Jul 01 by modification time
find /file/path ! -newermt "Jul 01"

Find all files/directories that are owned by user 'dave' under current user's home directory tree
find ~ -user dave -print

Find all files/directories that are owned by user 'eric' under current directory tree
find -user eric -print

Find all files/directories that are owned by user 'takuya' under current directory tree
find -user takuya

Find all files/directories that are owned by user 'wnj' and are newer than 'ttt' by modification time in the entire filesystem
find / -newer ttt -user wnj -print

Find all files/directories that belong to the group 'accts' under '/apps' directory tree
find /apps -group accts -print

Find all files/directories that belong to the group 'audio' under '/dev' directory tree
find /dev -group audio

Find all files/directories that belong to the group 'staff' under '/usr' directory tree
find /usr -group staff

Find all files/directories that contain 'packet' (case insensitive) in their names excluding directories that are bigger than 1500 bytes in size
find . -iregex ".*packet.*" ! -type d -size +1500c

Find all files/directories that contain 'target' (case insensitive) in their names under current directory no-recursively
find -maxdepth 1 -iname "*target*"

Find all files/directories that contain the string literal '$VERSION' in their names under current directory tree
find . -name '*$VERSION*'

Find all files/directories that contain the string literal '`$VERSION`' in their names under current directory tree
find . -name '*`$VERSION`*'

Find all files/directories that do not belong to any user under '/home' directory tree
find /home -nouser -print

Find all files/directories that do not contain 'photo' in their names under current directory tree
find . ! -name "*photo*"

Find all files and directories that do not match the pattern given as the $controlchars variable
find . ! -name "$controlchars"

Find all files/directories that start with 'onlyme' in their names under maximum 2 levels down the current directory
find . -maxdepth 2 -name 'onlyme*'

Find all files/directories that start with 'readme' (case insensitive) in their names under '/usr/share/doc' directory tree
find /usr/share/doc -name '[Rr][Ee][Aa][Dd][Mm][Ee]*'

Find all files/directories that start with 'screen' (case insensitive) in their names under user's home directory tree
find ~ -iname "screen*"

Find all files/directories that have read, write, execution permission for user and belong to the user 'my_user' under current directory tree
find . -user my_user -perm -u+rwx

Find all files and directories that have been modified in the last seven days.
find . -mtime -7

Find all files/directories that were modified after February 1st under '/usr' directory tree
find /usr -newermt "Feb 1"

Find all files/directories that were modified more than 2 days ago and redirect the list to ~/output.file
find . -mtime +2 | perl -pe 's{^}{\"};s{$}{\"}' > ~/output.file

Find all files/directories whose names start with 'readme' (case insensitive) under '/usr/share/doc' directory tree
find /usr/share/doc -iname readme\*

Find all files/directories with '.bar' extension in maximum 2 levels down the current directory
find . -name *.bar -maxdepth 2 -print

Find all files/directories with '.err' extension under '/home/username' directory tree
find /home/username/ -name "*.err"

Find all files/directories with '.js' extension under current directory tree excluding paths that contain the directory './directory'
find -name "*.js" -not -path "./directory/*"

Find all files/directories with '.js' extension under current directory tree without descending into './directory'
find . -path ./directory -prune -o -name '*.js' -print

Find all files/directories with '.js' extension under current directory tree without descending into  and ignoring './directory' completely
find . -not \( -path ./directory -prune \) -name \*.js

Find all files/directories with '.log' extension that belong to the group 'adm' under '/var/log' directory tree
find /var/log -group adm -name "*.log"

Find all files/directories with '.log' extension whose names start with 'app-', have been modified in the last 5 minutes and show the first one found
find /var/log/crashes -name app-\*\.log -mmin -5 -print | head -n 1

Find all files/directories with '.o' extension under '/lib/modules' directory tree
find /lib/modules -name '*.o'

Find all files/directories with '.pdf' extension excluding 'pdfs' directory and all of its contents
find . -name "*.pdf" -print | grep -v "^\./pdfs/"

Find all files/directories with '.tar.gz' extension under $DIR/tmp/daily/ directory tree, sort them numerically and show the last 3 of them
find $DIR/tmp/daily/ -name '*.tar.gz' | sort -n | tail -3

Find all files/directories with '.txt' extension under '/home' directory tree that are exactly 100KB in size
find /home -name "*.txt" -size 100k

Find all files/directories with '.what_to_find' extension under current directory tree and show the list by excluding paths that contain 'excludeddir1' and 'excludeddir2'
find . -name '*.what_to_find' | grep -v exludeddir1 | grep -v excludeddir2

Find all files/directories with '.xml' extension that start with 'log4j' in their names under '/cygdrive/e/MyDocs/Downloads/work/OATS Domain related/' directory tree, search for files that contain the string 'CONSOLE' in their contents, then search for the string 'ASYNC' in the matched files and display the matched lines along with their filenames
find "/cygdrive/e/MyDocs/Downloads/work/OATS Domain related/" -iname "log4j*.xml" | xargs -I % grep -ilr "CONSOLE" "%" | xargs -I % grep -H "ASYNC" %

Find all files/directories with 'my key phrase' in their names under current directory
find . -name '*my key phrase*'

Find all files/directories with 'my key phrase' in their names under current directory and redirect the output to mylist.txt
find -name '*my key phrase*' > mylist.txt

Find all files/directories with 'my key phrase' in their names under current directory, search for 'my key phrase' in all files under current directory and print a sorted and unique list of output
{ find . -name '*my key phrase*'; grep -rl 'my key phrase' *; } | sed "s/^\.\///" | sort -u

Find all files/directories with 'my key phrase' in their names under current directory, search for 'my key phrase' in all files under current directory and print a sorted and unique list of output
{ find . -name '*my key phrase*'; grep -rl 'my key phrase' .; } | sort -u

Find all files/directories with 644 permission in entire file system
find / -perm 644

Find all files/directories with 664 permission under current directory tree
find -perm 664

Find all files/directories with 755 permission under current directory tree
find ./ -perm 755

Find all files/directories with 777 permission under '/apps/audit' and strip write permission for 'other' from them
find /apps/audit -perm -7 -print | xargs chmod o‑w

Find all files/directories with 777 permission under current directory tree
find . -perm 777 -print

Find all files/directories with case insensitive name pattern $TARGET that are located in minimum 10 level down the current directory
find -mindepth 10 -iname $TARGET

Find all files/directories with execute permission by group or others
find /path -perm /011

Find all files/directories with inode number 16187430 and move them to 'new-test-file-name'
find -inum 16187430 -exec mv {} new-test-file-name \

Find all files/directories with name pattern $nombre that are at most 2 levels down the $DIR_TEMPORAL and $DIR_DESCARGA directories and show only the file names (without parent path) appended with '.torrent'
find "$DIR_TEMPORAL" "$DIR_DESCARGA" -maxdepth 2 -name "$nombre" -printf '%f.torrent\n'

Find all files/directories with space in their names under $1 directory
find $1 -name '* *'

Find all files/directories with space in their names under  /tmp/ directory and rename them by replacing all spaces with _
find /tmp/ -depth -name "* *" -execdir rename " " "_" "{}" ";"

Find all files/directories with space in their names under  /tmp/ directory and rename them by replacing all spaces with _
find /tmp/ -depth -name "* *" -execdir rename 's/ /_/g' "{}" \;

Find all files/directories with space in their names under current directory
find . -name '* *'

Find all files/directories with space in their names under current directory and rename them by replacing all spaces with _
find . -depth -name "* *" -execdir rename "s/ /_/g" "{}" \;

Find all files/directories with space in their names under current directory and rename them by replacing all spaces with _
find . -depth -name '* *' | while IFS= read -r f ; do mv -i "$f" "$(dirname "$f")/$(basename "$f"|tr ' ' _)" ; done

Find all files/directories with permission $permissions under $directory directory tree
find "$directory" -perm "$permissions"

Find all files and directories with permissions 664
find . -perm 664

Find all files/directories which have been modified from the start of the day in directories/files taken from the glob pattern '/tmp/test/*'
find /tmp/test/* -daystart -mtime -0

Find all files/directories which have been modified within the last day in the drectories/files taken from the glob pattern '/tmp/test/*'
find /tmp/test/* -mtime -1

Find all files/directories with spaces in their names under ~/Library directory
find ~/Library -name '* *'

Find all files newer than httpd.conf under and below the current directory
find . -newer httpd.conf

Find all files beneath the current directory that end with the extension .java and contain the characters String ignoring case.  Print the name of the file where a match is found.
find . -type f -name "*.java" -exec grep -il string {} \;

Find all files beneath the current directory that end with the extension .java and contain the characters StringBuffer.  Print the name of the file where a match is found.
find . -type f -name "*.java" -exec grep -l StringBuffer {} \;

Find all files called "file1.txt" that reside under and below /home/wsuNID/
find /home/wsuNID/ -name file1.txt

Find all files changed on the 29th of September, 2008, starting from the current directory
find . -type f -newerct 2008-09-29 ! -newerct 2008-09-30

Find all files except files with '.gz' extension in the current directory non-recursively and compress them with gzip
find . -maxdepth 1 -type f ! -name '*.gz' -exec gzip "{}" \;

Find all files files under the current directory except *.txt
find . -maxdepth 1 -type f -not -regex '.*\.txt'

Find all files, folders, symlinks, etc matching pattern "*.php" in the current directory recursively
find . -name \*.php

Finds all files having text "texthere" recursively in a current folder, and precedes found string with string number in file and file name.
find -type f -exec grep -Hn "texthere" {} +

Findx all files having text "texthere" recursively in a current folder, and prints only file names with matching strings.
find -type f -exec grep -l "texthere" {} +

Find all files in "/home/" which contain "string1", "string2" or the host name in its filename
find /home/ -type f -regextype posix-extended -regex ".*(string1|string2|$(hostname)).*"

Find all files in $dir directory without going into sub-directories
find "$dir" -maxdepth 1 -type f

Find all files in /dir1 and print only the filenames (not paths)
find ./dir1 -type f -exec basename {} \;

Find all files in /dir1 and print only the filenames (not paths)
find /dir1 -type f -printf "%f\n"

Find all files in /home/kos and below whose names end in ".tmp"
find /home/kos -name *.tmp -print

Find all files in /home/user/ that were created or changed 10 minutes ago
find /home/user/ -cmin 10 -print

Find all files in /var/www/html/zip/data/*/*/*/*/* that are older than 90 days
find /var/www/html/zip/data/*/*/*/*/* -type f -mtime +90

Find all files in /var/www/html/zip/data/*/*/*/*/* that are older than 90 days and print only unique parent directory paths
find /var/www/html/zip/data/*/*/*/*/* -type f -mtime +90 -printf "%h\n" | sort | uniq

Finds all files in a '/path' folder and prints long listing for them.
find /path -type f -exec ls -l \{\} \;

Find all files in and below all subdirectories of the current directory
find . -mindepth 2

Find all files in and below the home directory that have been modified in the last 90 minutes
find ~ -mmin -90

Find all files in current directory and search for 'searchName' in those files
find ./ -name "*" | xargs grep "searchName"

Find all files in current directory and execute 'echo first; false' for each file
find . -type f -exec sh -c 'echo first; false' \; -exec echo second \;

Find all files in current directory and execute command1 and command2 for each file
find . -type f \( -exec command1 \; -false -o -exec command2 \; \)

Find all files in current directory and execute multiple commands for each file
find . -type f -exec sh -c 'echo first; true' \; -exec echo second \;

Find all files in current directory and execute multiple commands for each file
find . -type f \( -exec sh -c 'echo first; false' \; -false -o -exec echo second \; \)

Find all files in current directory excluding hidden files and put the output into full_backup_dir variable
full_backup_dir=$(find . -depth '(' -wholename './.*' ')' -prune -o -print)

Find all files in current directory excluding hidden files, archive them and put the output into variable  full_backup_dir
full_backup_dir="$(find . -depth \( -wholename \./\.\* \) -prune -o -print | cpio -oav)"

Find all files in current directory that were modified less than 1 day ago, and create cpio archive in $backup_dir
find . -mtime -1 | cpio -oa 2>/dev/null | ( cd $backup_dir && cpio -imd)

Find all files in current directory that were modified less than 1 day ago excluding hidden files  and archive them and put the output into the variable file_changed
file_changed=$(find . -depth \( -wholename \./\.\* \) -prune -o -mtime -1 -print | cpio -oav)

Find all files in current directory that were modified less than 1 day ago excluding hidden files and put the output to full_backup_dir variable
full_backup_dir=$(find . -depth \( -wholename \./\.\* \) -prune -o -mtime -1 -print)

Find all files in current directory with the extension ".ext" and remove all "^M" in those files
find $(pwd) -type f -name "*.ext" | while read file; do sed -e 's/^M//g' -i "$file"; done;

Find all files in directory tree /tmp/foo and pass them as arguments to script /tmp/echoargs
find /tmp/foo -exec /tmp/echoargs {} +

Find all files in entire file system which are larger than 20000KB
find / -type f -size +20000k

Find all files in your home directory and below that are exactly 100M.
find ~ -size 100M

Find all files in your home directory and below that are larger than 100M.
find ~ -size +100M

Find all files in maximum 1 level down the current directory that were modified less than 1 day ago
find -maxdepth 1 -type f -mtime -1

Find all files in maximum 1 level down the current directory that were modified less than 1 day ago from today
find -maxdepth 1 -type f -daystart -mtime -1

Find all files in maximum 2 levels down the current directory
find . -maxdepth 2  -type f

Find all files in the `sourceDir' directory
find sourceDir -mindepth 1 -maxdepth 1

Find all files in the `sourceDir' directory tree
find sourceDir -mindepth 1

Find all files in the `work' directory tree, pass them to grep and search for "profit"
find ./work -print | xargs grep "profit"

Find all files in the /etc folder that have been modified within the last 30 days and copy them to /a/path/.
find /etc/ -mtime -30 | xargs -0 cp /a/path

Find all files in the /home/ directory tree that are owned by bob
find /home -user bob

Find all files in the /home/ directory tree that were last accessed more than 7 days ago
find /home -atime +7

Find all files in the /home/ directory tree that were last modified less than 7 days ago
find /home -mtime -7

Find all files in the /home/myuser directory recursively that are older than 7 days
find /home/myuser -mtime +7 -print

Find all files in the /myfiles directory tree following symbolic links
find -L /myfiles

Find all files in the /usr directory tree that are owned by group `staff'
find /usr -group staff

Find all files in the /var/tmp directory tree with uid=1000
find /var/tmp -uid 1000

Find all files in the current directory and below with extension .php and replace "php" with "html" in their names
find ./ -type f -name "*.php"  | xargs -r rename "s/php/html/"

Find all files in the current directory and its sub-directories that have not been assessed in more than 30 days.
find . -atime +30 -print

Find all files in the current directory and its sub-directories that have been modified sometime in the last 24 hours.
find . -mtime -1 -prin

Find all files in the current directory recursively with "linkin park" in their names and copy them to /Users/tommye/Desktop/LP
find . -type f -iname "*linkin park*" -exec cp -r {} /Users/tommye/Desktop/LP \;

Find all files in the current directory recursively with "linkin park" in their names and copy them to /Users/tommye/Desktop/LP, preserving path hierarchy
find . -type f -iname "*linkin park*" | cpio -pvdmu /Users/tommye/Desktop/LP

Find all files in the current directory tree containing "foo" in their names
find . -print | grep -i foo

Find all files in the current directory tree except .html, ignoring .svn directories
find . \( -type d -name '.svn' -o -type f -name '*.html' \) -prune -o -print0

Find all files in the current directory tree, except GIT files
find -type f -name .git -prune -o -print

Find all files in the current directory tree named 'FILES.EXT'
find . -name "FILES.EXT"

Find all files in the current directory tree that are newer than some_file
find . -newer some_file

Find all files in the current directory tree that are not newer than some_file
find . ! -newer some_file

Find all files in the current directory tree that match pattern 'a(b*'
find . -name 'a(b*' -print

Find all files in the current directory tree that were last changed $minutes minutes ago
find . -cmin $minutes -print

Find all files in the current directory tree whose names are ".DS_STORE"
find . -name ".DS_STORE"

Find all files in the current directory tree whose names are ".DS_STORE" and delete them
find . -name ".DS_STORE" -delete

Find all files in the current directory tree whose names are "YourProgram", change to the directories they are in, and execute them
find $(pwd) -name YourProgram -exec dirname {} \; | while read d; do cd "$d" && ./YourPrgram; done

Find all files in the current directory tree whose names are "file_name", except for those with pathnames matching pattern "./dirt to be Excluded/*"
find ./ -iname file_name ! -path "./dirt to be Excluded/*"

Find all files in the current directory tree whose names end with the suffix ".keep.$1", where $1 is the first command line argument, and remove that suffix
find . -type f -name "*.keep.$1" -print0 | while IFS= read -r -d '' f; do mv -- "$f" "${f%.keep.$1}"; done

Find all files in the current directory tree whose names end with the suffix ".keep.$1", where $1 is the first command line argument, and remove that suffix
find . -type f -name "*.keep.$1" -print0 | xargs -0 rename "s/\.keep\.$1$//"

Find all files in the current directory tree whose path names match pattern './sr*sc'
find . -path './sr*sc'

Find all files in the current directory tree whose pathnames match pattern "./sr*sc"
find . -path "./sr*sc"

Find all files in the current directory tree whose size is greater than 1MB
find . -size +1M

Find all files in the current directory tree whose size is greater than 1MB, and move them to the "files" folder
find . -size +1M -exec mv {} files \+

Find all files in the current directory tree whose size is greater than 1MB, and move them to the "files" folder
find . -size +1M -print0 | xargs -0 -I '{}' mv '{}' files

Find all files in the current directory tree whose size is greater than 1MB, and move them to the "files" folder with confirmation
find . -size +1M -ok mv {} files \+

Find all files in the current directory tree which do not belong to any user
find . -nouser

Find all files in the current directory tree with size bigger than 5 MB and sort them by size
find ./ -size +5M -type f | xargs -r ls -Ssh

Find all files in the current directory аргумент and its sub-directories with the optional constraints of опция_поиска, значение and/or значение.
find аргумент [опция_поиска] [значение] [значение]

Find all files in the directory $directory or below with the permissions specificed by $permissions.
find "$directory" -perm "$permissions"

Find all files in the home directory tree that are owned by another user
find ~ ! -user ${USER}

Find all files in the home directory tree that are owned by another user and change their ownership to the current user
find ~ ! -user $USER -exec sudo chown ${USER}:"{}" \;

Find all files in the home directory with open permissions
find ~ -perm 777

Find all files in the file system with the SUID bit
find / -perm -u+s -print

Find all files in ~/clang+llvm-3.3/bin/ and print 'basename /file/path' for each file
find ~/clang+llvm-3.3/bin/ -type f -exec echo basename {} \;

Find all files excluding *.gz files in the current directory tree and compress them with gzip
find . -type f ! -name '*.gz' -exec gzip "{}" \;

Find all files excluding files ending with 'gz', 'tmp' and 'xftp' in their names in the current directory tree and compress them with gzip not preserving timestamp and original name
find . -type f ! \( -name "*gz" -o -name "*tmp" -o -name "*xftp" \) -exec gzip -n '{}' \;

Find all files under $1, calculate their md5sums and redirect the results to $1__checksums.md5
find "$1" -type f -exec md5sum {} \; > "$1"__checksums.md5

Find all files under $1, calculate their md5sum and redirect the result to checksums.md5
find "$1" -type f -print0 | parallel -0 -X md5 > checksums.md5

Find all files under $1 not matching the regex '.*/\..*' and execute hashmove on each of them with the file path as its argument
find $1 -type f -not -regex '.*/\..*' -exec $0 hashmove '{}' \;

Find all files under $YOUR_DIR
find $YOUR_DIR -type f

Find all files under $d directory and set read-write permission for owner and group and no permission for other for those files
find $d -type f -exec chmod ug=rw,o= '{}' \;

Find all files under $dir
find "$dir" -type f

Find all files under $dir
find $dir -type f

Find all files under $dir directory
find "$dir" -type f

Find all files under $musicdir directory
find "$musicdir" -type f -print

Find all files under $root_dir
find $root_dir -type f

Find all files under $source_dir that match the regex .*\.\(avi\|wmv\|flv\|mp4\) in their paths and print them with null character as the delimiter
find "$source_dir" -type f -regex ".*\.\(avi\|wmv\|flv\|mp4\)" -print0

Find all files under $source_dir that match the regex expanded by $input_file_type in their paths
find "$source_dir" -type f|egrep "$input_file_type"

Find all files under ${searchpath} that match the regex '"${string1}".*"${string2}".*"${string3}"' (${string1} ... won't be expanded) in their contents
find `echo "${searchpath}"` -type f -print0 | xargs -0 grep -l -E '"${string1}".*"${string2}".*"${string3}"'

Find all files under 'dir' directory and print their md5 sums into file.txt
find dir -type f | xargs md5sum >> file.txt

Find all files under 'dir' directory with white space safety in their paths and print their md5 sums into file.txt
find dir -type f -print0 | xargs -0 md5sum >> file.txt

Find all files under ./lib/app and sort them
find ./lib/app -type f | sort

Find all files under ./lib/app and sort them, then print their contents to myFile
find ./lib/app -type f | sort | xargs awk 'ENDFILE {print ""} {print}' > myFile

Find all files under ./lib/app and redirect their sorted list to myFile
find ./lib/app -type f | sort | tee myFile

Find all files under /home that belong to user tecmint
find /home -user tecmint

Find all files under /home/feeds/data without descending into *def/incoming* and *456/incoming* paths
find /home/feeds/data -type f -not -path "*def/incoming*" -not -path "*456/incoming*"

Find all files under /home/myfolder that match the regex 'abc.*def.*ghi' in their contents
find /home/myfolder -type f -print0 | xargs -0 grep -l -E 'abc.*def.*ghi'

Find all files under /home/mywebsite/public_html/sites/all/modules and set their permission to 640
find /home/mywebsite/public_html/sites/all/modules -type f -exec chmod 640 {} +

Find all files under /home/username/public_html/modules  and set their permission to 640
find /home/username/public_html/modules -type f -exec chmod 640 {} +

Find all files under /home/username/public_html/sites/all/modules and set their permission to 640
find /home/username/public_html/sites/all/modules -type f -exec chmod 640 {} +

Find all files under /home/username/public_html/sites/all/themes and set their permission to 640
find /home/username/public_html/sites/all/themes -type f -exec chmod 640 {} +

Find all files under /home/username/public_html/sites/default/files and set their permission to 660
find /home/username/public_html/sites/default/files -type f -exec chmod 660 {} +

Find all files under /home/username/public_html/themes and set their permission to 640
find /home/username/public_html/themes -type f -exec chmod 640 {} +

Find all files under /mnt/naspath directory without descending into .snapshot directory that were modified in last 24 hours with null character as the delimiter
find /mnt/naspath -name .snapshot -prune -o \( -type f -mtime 0 -print0 \)

Find all files under /mnt/naspath directory without descending into .snapshot directory that were modified in last 24 hours with null character as the delimiter
find /mnt/naspath \! \(-name .snapshot -prune\) -type f -mtime 0 -print0

Find all files under /mountpoint and below which have hard links
find /mountpoint -type f -links +1

Find all files under /myfiles with 647 permission
find /myfiles -type f -perm -647

Find all files under /myfiles with read-write access for others
find /myfiles -type f -perm -o+rw

Find all files under /path and below executable by `group' or `other'
find /path -perm /011

Find all files under /path and below writable by `group' and `other'
find /path -perm -022

Find all files under /path and below writable by `group' and `other'
find /path -perm -g+w,o+w

Find all files under /path and below writable by `group' and `other'
find /path -perm -go+w

Find all files under /path and below writable by `group' or `other'
find /path -perm /g+w,o+w

Find all files under /path and calculate their md5sum
find /path -type f -print0 | xargs -0 md5sum

Find all files under /path/to/base/dir and change their permission to 644
chmod 644 $(find /path/to/base/dir -type f)

Find all files under /path/to/base/dir and change their permission to 644
find /path/to/base/dir -type f -exec chmod 644 {} +

Find all files under /path/to/base/dir and change their permission to 644
find /path/to/base/dir -type f -print0 | xargs -0 chmod 644

Find all files under /path/to/dir and change their permission to 644
find /path/to/dir -type f -exec chmod 644 {} +

Find all files under /path/to/dir that were modified less than 7 days ago and show only first several lines of output
find /path/to/dir -type f -mtime -7 -print0 | xargs -0 ls -lt | head

Find all files under /path/to/file which are greater than 25600KB
find /path/to/file -type f -size +51200c 2>/dev/null

Find all files under /somefolder matching the case insensitive regex '\(.*error.*\)\|\(^second.*\log$\)\|\(.*FFPC\.log$\)' in their paths
find /somefolder -type f | grep -i '\(.*error.*\)\|\(^second.*\log$\)\|\(.*FFPC\.log$\)'

Find all files under /somefolder matching the extended case insensitive regex '\./(.*\.error.*|second.*log|.*FFPC\.log)$' in their paths
find -E /somefolder -type f -iregex '\./(.*\.error.*|second.*log|.*FFPC\.log)$'

Find all files under /somefolder matching the extended regex '\./(.*\.error.*|second.*log|.*FFPC\.log)$' in their paths
find -E /somefolder -type f -regex '\./(.*\.error.*|second.*log|.*FFPC\.log)$'

Find all files under /somefolder matching the pattern expanded by $FILE_PATTERN in thier names
find /somefolder -type f -name $FILE_PATTERN

Find all files under /usr/tom that matches the extended regex '*.pl| *.pm'   in their names and also matches the regex <PATTERN> in their contents
find /usr/tom | egrep '*.pl| *.pm' | xargs cat | grep <PATTERN>

Find all files under /var/www directory and set their permission to 644
sudo find /var/www -type f -print0 | xargs -0 chmod 644

Find all files under and below /dir that were accessed less than 60 minutes ago
find /dir -amin -60

Find all files under and below /dir that were changed or created less than 60 minutes ago
find /dir -cmin -60

Find all files under and below /dir that were modified less than 60 minutes ago
find /dir -mmin -60

Find all files under and below the current working directory with the word California in the file
find . -type f -exec grep California {} \; -print

Find all files under and below the current working directory with the word California in the file (case insensitive), and count the number of lines in the output
find . -type f -exec grep -i California {} \; -print | wc -l

Find all files under and below the current working directory with the word California in the file, and count the number of lines in the output
find . -type f -exec grep -n California {} \; -print | wc -l

Find all files under and below the current working directory with the word California in the file, and count the number of lines in the output
find . -type f -exec grep California {} \; -print | wc -l

Find all files under current directory
find "`pwd`" -type f

Find all files under current directory
find -type f

Find all files under current directory
find . -type f

Find all files under current directory
find . -type f -print

Find all files under current directory and append a null character at the end of each of their paths
find -type f -print0

Find all files under current directory and change their permission to 600
find . -type f -exec chmod 600 {} \;

Find all files under current directory and change their permission to 644
find . -type f -exec chmod 644 {} \;

Find all files under current directory and count the output line number
find . -type f | wc -l

Find all files under current directory and search for 'something' in those files
find . -exec grep something {} +

Find all files under current directory and search for 'something' in those files
find . -print | xargs grep something

Find all files under current directory and make them read-only for owner, read & writable by group and remove read-write-execute permission
find . -type f -exec chmod u+r-wx,g+rw-x,o-rwx {} \;

Find all files under current directory and print them appending a null character at the end of each file paths
find . -type f -print0

Find all files under current directory and print them by removing the leading ./ in their paths
find . -type f -exec bash -c 'f="{}"; echo "${f:2}"' \;

Find all files under current directory and print their md5 sums
find . -type f -printf '%f ' -exec openssl dgst -md5 {} \;

Find all files under current directory and print only the filenames (not paths)
find . -type f -execdir echo '{}' ';'

Find all files under current directory and print only the filenames (not paths)
find . -type f -printf "%f\n"

Find all files under  current directory and rename them by replacing all white spaces with _
find ./ -name "* *" -type f -d 1 | perl -ple '$file = $_; $file =~ s/\s+/_/g; rename($_, $file);'

Find all files under current directory and show their file information
find . -type f -exec file {} \;

Find all files under current directory and show their file information
find . -type f -print0 | xargs -0 file

Find all files under current directory and show their file information
find . -type f | xargs file

Find all files under current directory and pipe their contents to the wordfrequency command and then search for 'yourword' in the output
find . -type f | xargs cat | wordfrequency | grep yourword

Find all files under current directory and set their permission to 775
find -type f | xargs chmod 775

Find all files under current directory and set their permission to 775
find . -type f -exec chmod 775 {} +

Find all files under current directory and set read-write permission for owner and group and no permission for other for those directories
find . -type f -exec chmod ug=rw,o= {} \;

Find all files under current directory and set read-write permission for owner, read permission for group and no permission for other for those files
find . -type f -exec chmod u=rw,g=r,o= '{}' \;

Find all files under current directory and run /tmp/clever.sh for each of them with each file path as an argument
find . -type f -exec /tmp/clever.sh {} \;

Find all files under current directory and run the command fromdos for each of them with the file path as argument
find . -type f -exec fromdos {} \;

Find all files under current directory and write the paths without the leading ./ in the file outputfile
find . -type f -printf '%P\n' > outputfile

Find all files under current directory, calculate their md5sum
find . -type f -print0 | parallel -0 -X md5sum

Find all files under current directory, calculate their md5sum and print each of the outputs to filename.md5 files
find . -type f | while read f; do g=`md5sum $f` > $f.md5; done

Find all files under current directory, calculate their md5sum and print the output to MD5SUMS
find . -type f -exec md5sum {} \; > MD5SUMS

Find all files under current directory excluding hidden directories
find -name '.?*' -prune -o \( -type f -print0 \)

Find all files under current directory excluding hidden files
find . -depth -path './.*' -prune -o -print

Find all files under current directory excluding the $OUTPUT file, calculate their md5sum with $MD5SUM_OPTIONS options and redirect the result to $OUTPUT
find . -type f ! -name "$OUTPUT" -exec md5sum $MD5SUM_OPTIONS {} + > $OUTPUT

Find all files under current directory matching either of the patterns 'error.[0-9]*', 'access.[0-9]*', 'error_log.[0-9]*', 'access_log.[0-9]*', 'mod_jk.log.[0-9]*' in their names
find -type f -name 'error.[0-9]*' -o -name 'access.[0-9]*' -o -name 'error_log.[0-9]*' -o -name 'access_log.[0-9]*' -o -name 'mod_jk.log.[0-9]*'

Find all files under current directory matching the pattern '[error,access,error_log,access_log,mod_jk.log]*.[0-9]*' in their names
find -name '[error,access,error_log,access_log,mod_jk.log]*.[0-9]*' -type f

Find all files under current directory matching the posix-egrep type regex '^.*/[a-z][^/]*$'  in their names
find . -regextype posix-egrep -regex '^.*/[a-z][^/]*$' -type f

Find all files under current directory matching the posix-egrep type regex '^.*/[a-z][^/]*$' in their names with locale set to default C locale
LC_ALL=C find . -regextype posix-egrep -regex '^.*/[a-z][^/]*$' -type f

Find all files under current directory matching the regex '.*\(\(error\|access\)\(_log\)?\|mod_jk\.log\)\.[0-9]+' in their paths
find -type f -regex '.*\(\(error\|access\)\(_log\)?\|mod_jk\.log\)\.[0-9]+'

Find all files under current directory that are larger than 10KB in size
find . -type f -size +10k

Find all files under current directory that are read less than 1 minute ago
find . -amin -1

Find all files under current directory that match the case insensitive regex .\|./.git and replace (all occurrences) the text matching the case insensitive regex expanded by $1 with $upper2 in these files
find . -type f \! -iregex '.\|./.git' -exec perl -i'' -pe "s/$1/$upper2/gi" {} +

Find all files under current directory that match the case insensitive regex .\|./.git and replace the text matching the regex '$lower1'  (literal) with $lower2 (literal)in these files
find . -type f \! -iregex '.\|./.git' -exec perl -i -pe 's/$lower1/$lower2/g' {} \;

Find all files under current directory that match the case insensitive regex .\|./.git and replace (all occurrences) the text matching the regex expanded by $lower1 with $lower2 in these files
find . -type f \! -iregex '.\|./.git' -exec perl -i'' -pe "s/$lower1/$lower2/g" {} +

Find all files under current directory that match the regex ^.*666$ in their names
find . -type f -print0 | xargs -0 perl -nle 'print if /^.*666$/'

Find all files under current directory that were modified in the last 24 hours
find -mtime 0

Find all files under current directory that were modified in the last 24 hours and also include the files that were modified in less than 1 day ago
find -daystart -mtime +0

Find all files under current directory that were modified in the last 24 hours and also include the files that were modified in less than 1 day ago
find -mtime +0

Find all files under current directory that were modified less than 1 day ago
find -mtime -1

Find all files under current directory that were modified more than 1 day ago
find -mtime +1

Find all files under current directory that were modified more than 7 days ago and delete them
find . -type f -mtime +7 -print0 | xargs    -0 rm

Find all files under current directory tree named 'filename_regex' excluding '.svn' and '.pdv' directories and files then search for the case insensitive pattern 'your search string' in those files
find . -name "filename_regex"|grep -v '.svn' -v '.pdv'|xargs grep -i 'your search string'

Find all files under current directory whose file type description contains "image", display only path to each file.
find . -type f -exec file {} \; | grep -o -P '^.+: \w+ image'

Find all files under current directory whose file type description contains "image", display the paths to files and file type descriptions.
find . -name '*' -exec file {} \; | grep -o -P '^.+: \w+ image'

Find all files under current directory whose status was changed less than 3 days ago and show last 5 lines of output
find . -type f -ctime -3 | tail -n 5

Find all files under current directory with their timestamp and paths and print a sorted list
sort < <(find -printf "%T@ %p\n")

Find all files under current directory without descending into .git directory and replace the match of the regex \Q$1\E with \L$2\E in those files where $1 and $2 will be expanded in the current shell
find . -name .git -prune -o -type f -exec perl -i -pe "s/\Q$1\E/\L$2\E/i" {} +

Find all files under current directory without descending into .snapshot directory that were modified in last 24 hours with null character as the delimiter
find . -name .snapshot -prune -o \( -type f -mtime 0 -print0 \)

Find all files under foldername directory and set their permission to 644
sudo find foldername -type f -exec chmod 644 {} ";"

Find all files under Mainfolder directory and redirect the output to outputfle
find Mainfolder -type f > outputfile

Find all files under minimum 1 level down the current directory
find .  -mindepth 1 -type f

Find all files under media/ directory and change their permission to 600
find media/ -type f -exec chmod 600 {} \;

Find all files under dir and calculate their md5sum and save the output to dir.md5
find dir -type f -exec md5sum {} + > dir.md5

Find all files under dir and calculate their md5sum and save the output to dir.md5
find dir -type f -print0 | xargs -0 md5sum > dir.md5

Find all files under relative/path/to/dir, calculate their md5sum and redirect the result to sums.md5
find relative/path/to/dir -type f -exec md5sum {} + > sums.md5

Find all files under the current directory that are not the same file as "/home/nez/file.txt"
find . -maxdepth 1 -not -samefile /home/nez/file.txt

Find all files under the current directory whose filenames are not "file.txt", ignoring the case
find . -maxdepth 1 -not -iname file.txt

Find all files under the current directory whose pathnames do not end with "Video", ignoring the case
find . -maxdepth 1 -not -iwholename '*Video'

Find all files under trunk directory and upload them to https://PATH_TO_NEXUS/trunk/
find trunk -type f -exec curl --user user:pass --ftp-create-dirs -T {} https://PATH_TO_NEXUS/{} \;

Find all files under var/ directory and change their permission to 600
find var/ -type f -exec chmod 600 {} \;

Find all files inside all directories (non-recursive) in /tmp/test directory (recursive) and print the number of files in each directory and also print the file name and directory paths
find . -type d -print0 | xargs -0 -I {} sh -c ' echo "{}: \c" ; find {} -maxdepth 1 -type f | wc -l ; find {} -maxdepth 1 -type f -print | sed "s#.*/##" '

Find all files inside all directories (non-recursive) in /tmp/test directory (recursive) and print the number of files in each directory and also print the file/directory paths
find . -type d -print0 | xargs -0 -I {} sh -c ' echo "{}: \c" ; find {} -maxdepth 1 -type f | wc -l ; find {} -maxdepth 1 -type f -print'

Find all files inside all directories (non-recursive) in maximum 2 levels down the /tmp/test directory and print the number of files in each directory and also print the file/directory paths
find /tmp/test/ -maxdepth 2 -mindepth 1 -type d | while read dir; do printf "%s : " "$dir"; find "$dir" -maxdepth 1 -type f | wc -l; find "$dir" -maxdepth 1 -type f ; done;

Find all files larger than 100M and delete them
find / -size +100M -exec rm -rf {} \;

Find all files larger than 20000k
find / -type f -size +20000k

Find all files matching pattern '.#*' in the current directory tree
find -iname '.#*'

Find all files matching pattern '.#*' in the current directory tree and execute "foobar" for each of them with the file name as an argument
find . -iname '.#*' -print | while read -r i; do foobar "$i"; done

Find all files matching pattern '.#*' in the current directory tree and execute "foobar" for each of them with the file name as an argument
find . -iname '.#*' -print0 | while read -r -d '' i; do foobar "$i"; done

Find all files matching the pattern "${pattern}" in their name and execute ${my_command} for each of them with the file path as argument
find ${directory} -name "${pattern}" -print0 | xargs -0 ${my_command}

Find all files modified on "Mar 4" and unzip and search their contents for "12345"
ls -ltr | grep 'Mar 4' | awk '{print 9}' | xargs zcat -fq | grep 12345

Find all files named "MyCProgam.c" (ignoring the case) and calculate each file's md5sum.
find -iname "MyCProgram.c" -exec md5sum {} \;

Find all files named "file.ext" in the current directory tree and print the path names of the directories they are in
find $PWD -name "file.ext" -exec sh -c 'echo $(dirname {})' ';'

Find all files named "file.ext" in the current directory tree and print the path names of the directories they are in
find . -name "file.ext" -execdir pwd ';'

Find all files named "file.ext" in the current directory tree and print the path names of the directories they are in
find `pwd` -name "file.ext" -exec echo $(dirname {}) \;

Find all files named "file.ext" in the current directory tree and print the path names of the directories they are in
find `pwd` -name file.ext |xargs -l1 dirname

Find all files named "file.ext" under the current working directory tree and print its filename
find `pwd` -name "file.ext" -printf "%f\n"

Find all files named "file.ext" within the current folder and print the path where each one is located
find `pwd` -name "file.ext" -exec dirname {} \;

Find all files named "file.ext" within the current folder and print the path where each one is located
find `pwd` -name "file.ext" -exec echo $(dirname {}) \;

Find all files named "filename"
find -name "filename"

Find all files named "foo_bar" in the current directory recursively
find -name foo_bar

Find all files named "something" in the current folder and below and run them through the ls -l command in a one batch.
find . -name something | xargs -0 ls

Find all files named "something" in the current folder and below and run them through the ls -l command, one by one.
find . -name something -exec ls -l {} \;

Find all files named "test2" in the current directory
find -name test2 -prune

Find all files named "test2" in the current directory tree
find -name test2

Find all files named 'Makefile' in the /usr/ports directory tree and count the number of lines in them matching regular expression '^MASTER_SITE.*CPAN'
find /usr/ports/ -name Makefile -exec grep '^MASTER_SITE.*CPAN' '{}' '+' | wc -l

Find all files named 'Makefile' in the /usr/ports directory tree and count the number of lines in them matching regular expression '^MASTER_SITE_SUBDIR.*\.\./.*authors'
find /usr/ports/ -name Makefile -exec grep '^MASTER_SITE_SUBDIR.*\.\./.*authors' '{}' '+' | wc -l

Find all files named 'aaa.txt' under current directory tree and display their contents
cat `find . -name aaa.txt`

Find all files named 'file' in 1 level down the current directory whose status were changed more than 1 day ago
find . -maxdepth 1 -ctime +1 -name file

Find all files named 'file' in 1 level down the current directory whose status were changed more than 1 hour ago
find . -maxdepth 1 -cmin +60 -name file

Find all files named `file1' on the system
find / -name file1

Find all files named `file1' starting from /
find / -name file1

Find all files named 'foo' under current directory tree without descending into directories named 'foo'
find . -name foo -type d -prune -o -name foo -print

Find all files named 'foo' under your home directory and list them with confirmation prompt
find ~ -type f -name 'foo*' -ok ls -l '{}' ';'

Find all files named 'new' under current directory tree and display their contents
find . -name new -print -exec cat {} +

Find all files named 'new' under current directory tree and display their contents
find . -name new -print -exec cat {} \;

Find all files named 'test' in the current directory tree, not descending into "test" directories
find . -name test -prune

Find all files named 'text.txt' under current directory tree and display their contents
find . -name 'text.txt' -print -exec cat {} \;

Find all files name passwd in the root directory and all its sub-directories.
find / -name passwd

Find all files of the user with UID=1000
find -uid 1000

Find all files of the user with UID=1000
find -user 1000

Find all files on your system that are world writable
find / -wholename  '/proc' -prune  -o  -type f -perm -0002 -exec ls -l {} \;

Find all files on local host whose name contains "labra" and copy them to remote  host 11.11.11.11 connecting as ssh user "masi" and copying the files to the Desktop directory this user's home directory - this will not work with file/path names containing spaces.
locate labra | xargs -I{} scp '{}' masi@11.11.11.11:~/Desktop/

Find all files on the system that are larger than 600 MB
find / -size +600M -print

Find all files on the system that are world writable
find / -wholename  '/proc' -prune  -o  -type f -perm -0002 -exec ls -l {} \;

Find all files on the system that are world writeable
find / -perm -0002

Find all files on the system that have been modified in the last 10 minutes
find / -mmin -10

Find all files on the system whose names are 'autoload.php'
find / -name autoload.php

Find all files on the system whose names are 'composer.json'
find / -name composer.json

Find all files on the system whose names are 'drush'
find / -name drush

Find all files owned by group `group2'
find / -group group2

Find all files owned by group `root' in the current directory tree and change their user to `temp'
find . -group root -print | xargs chown temp

Find all files owned by the user daniel in the current directory and below.
find . -user daniel

Find all files owned by user `comp'
find / -user comp

Find all files owned by user vivek
find / -user vivek

Find all files more than 700 megabytes
find / -size +700M

Find all files recursively starting from / that have been modified in the past 30 minutes and list them
find / -mmin -30 -ls

Find all files recursively which end in ".php"
find . -name "*.php" -print

Find all files residing in /home/dm/Video or below that were changed less than 7 days ago
find /home/dm/Video -mtime -7

Find all files residing in /home/dm/Video or below that were last changed at least 10 days ago
find /home/dm/Video -mtime +10

Finds all files like "mylog*.log" newer than $2 and archives them with bzip2.
find . -type f -ctime -$2 -name "mylog*.log" | xargs bzip2

Find all files, starting from / but ignoring removable media, whose names end with ".rpm"
find / -xdev -name "*.rpm"

Find all files starting from / that belong to user1
find / -user user1

Find all files starting from / whose names end with ".rpm" and change their permissions to 755
find / -name *.rpm -exec chmod 755 '{}' \;

Find all files starting from the current directory that contain '.java' in their pathnames
find . -print | grep '\.java'

Find all files starting from the current directory that match regular expression '.*Message.*\.java'
find . -print | grep '.*Message.*\.java'

Find all files starting from the current directory which are exactly 100MB in size
find . -size 100M

Find all files starting from the current directory which are larger than 100MB
find . -size +100M

Find all files starting from the current directory which are owned by the user tommye
find . -user tommye

Find all files starting from the current directory which are smaller than 100MB
find . -size -100M

Find all files that are exactly 50 bytes
find / -size 50c

Find all files that are less than 50 bytes
find / -size -50c

Find all files that are set group ID to 10
find . -group 10 -perm -2000 -print

Find all files that are set user ID to root
find . -user 0 -perm -4000 -print

Find all files that are set user ID to root
find . -user root -perm -4000 -print

Find all files that belongs to group 'root' under / directory and show a few lines of output from the beginning
find / -group root | head

Find all files that belong to group developer
find /home -group developer

Find all files that belong to group root
find / -group root

Find all files that belong to user root
find / -user root

Find all files that belongs to user Tecmint under /home directory
find /home -user tecmint

Find all files that contain the case insensitive regex 'stringtofind' in maximum 1 level down the / directory without descending into other partitions
find / -maxdepth 1 -xdev -type f  -exec grep -li stringtofind '{}' \;

Find all files that contain the case insensitive regex 'stringtofind' in maximum 1 level down the / directory without descending into other partitions
find / -maxdepth 1 -xdev -type f -exec grep -Zli "stringtofind" {} +

Find all files that contain the case insensitive regex 'stringtofind' in maximum 1 level down the / directory without descending into other partitions
find / -maxdepth 1 -xdev -type f -print -exec grep -i "stringtofind" -q {} \;

Find all files that aren't owned by user www-data
find -not -user www-data

Find all files that matches both the case insensitive patterns *$1* and *$2* under /home/musicuser/Music/ directory and execute mplayer for each of them
find /home/musicuser/Music/ -type f  -iname "*$1*" -iname "*$2*" -exec mplayer {} \;

Find all files that have additional permissions
find / -perm -644

Find all files that have either a .php or a .js extension
find -regextype posix-egrep -regex '.*(php|js)$'

Find all files that have wrong permission
find / \( -perm -006 -o -perm -007 \) \( ! -type -l \) -ls

Find all files that have the SUID bit set
find / -perm -u+s -print

Find all files that have been modified in the last seven days.
find . -mtime -7 -type f

Find all files that were last accessed less than7 days ago under /home
find /home -mtime -7

Find all files that were last modified less than7 days ago under /home
find /home -mtime -7

Find all files that were modified later than ordinary_file in the current directory and its sub-directories.
find -newer ordinary_file

Find all files whose filename does not end with *.html.
find . -type f -not -name "*.html"

Find all files whose names begin with 'Makefile' at the /usr/ports directory tree's level 3 and count the number of lines with NOPORTDOCS or NOPORTEXAMPLES in them.
find /usr/ports/ -name Makefile\* -mindepth 3 -maxdepth 3 -exec egrep "NOPORTDOCS|NOPORTEXAMPLES" '{}' '+' | wc -l

Find all files whose names begin with 'Makefile' in the /usr/ports directory tree and count how many of them contain 'QMAKESPEC'
find /usr/ports/ -name Makefile\* -exec grep -l QMAKESPEC '{}' '+' | wc -l

Find all files whose names begin with 'Makefile' in the /usr/ports directory tree and count how many of them contain 'QTDIR'
find /usr/ports/ -name Makefile\* -exec grep -l QTDIR '{}' '+' | wc -l

Find all files whose names begin with 'Makefile' in the /usr/ports directory tree and count the number of lines in them containing ^M
find /usr/ports/ -name Makefile\* -exec grep `printf '\15'` -l '{}' '+' | wc -l

Find all files whose names contain 'patch-' in the /usr/ports directory tree and count the number of lines with ^M in them
find /usr/ports/ -name '*patch-*' -exec grep `printf '\15'` -l '{}' '+' | wc -l

Find all files whose names contain the string 'xpilot' which exist within '/usr/local/games'
find /usr/local/games -name "*xpilot*"

Find all files whose names end with "macs" in and below the current directory
find -name '*macs'

Find all files whose names end with "~" in the /home/peter directory tree, following symlinks, and delete them
find -L /home/peter -name *~ -exec rm '{}' +

Find all files whose names end with "~" in the /home/peter directory tree, following symlinks, and delete them
find -L /home/peter -name *~ -exec rm '{}' \;

Find all files whose names end with "~" in the /home/peter directory tree, following symlinks, and delete them
find -L /home/peter -name *~ -print0 |xargs -0 -r -n1000 rm

Find all files whose names end with "~" in the /home/peter directory tree, following symlinks, and delete them
find -L /home/peter -name *~ -print0 |xargs -0 -r rm

Find all files whose names end with "~" in the /home/peter directory tree, following symlinks, and delete them
find -L /home/peter -name *~ |xargs rm

Find all files whose names do not begin with "zsh" on ext3 file systems
find / -fstype ext3 -name zsh -ls 2> /dev/null

Find all files whose names do not begin with "zsh" on ext3 file systems
find / -fstype ext3 -name zsh*

Find all files whose owner is `user1'
find / -user user1

Find all files with '.db' extension (case insensitive) that belong to user 'exampleuser' and were modified exactly 7 days ago under '/home' directory tree
find /home -user exampleuser -mtime 7 -iname ".db"

Find all files with '.jpg' extension in the current directory ignoring sub-directories and archive them to a file named jpeg.tgz
find . -maxdepth 1 -iname "*.jpg" | xargs tar -czvf jpeg.tgz

Find all files with '.txt' (case insensitive) extension under $dir directory non-recursively and sort them numerically
find "$dir" -maxdepth 1 -type f -iname '*.txt' | sort -n

Find all files with 644 permission and change the permission to 664
find . -type f -perm 644 -exec chmod 664 {} \;

Find all files which  are accessed after modifying /etc/passwd files.
find -newer /etc/passwd

Find all files which  begin with 'a' or 'b' from current directory downwards and print them.
find . -name [ab]* -print

Find all files which belong to user lal and change their ownership to ravi
find / -user lal -exec chown ravi {} \;

Find all files with extension .aac in the /home directory tree
find /home -type f -name '*.aac'

Find all files with name "file.ext" under the current working directory tree and print each full path directory name
find `pwd` -name file.ext |xargs -l1 dirname

Find all files with name ending with .txt and display only the filenames without full paths
find ./ -name "*.txt" | rev | cut -d '/' -f1 | rev

Finds all files with names like "*.rm" in a '/home/me/download/' folder, launches ffmpeg conversion for each one, and deletes source file after.
find /home/me/download/ -type f -name "*.rm" -exec ffmpeg -i \{} -sameq \{}.mp3 \; -exec rm \{} \;

Finds all files with names like "*.rm" in a current folder, launches ffmpeg conversion for each one, and deletes source file after.
find . -type f -name "*.rm" -exec ffmpeg -i {} -sameq {}.mp3 \; -exec rm {} \;

Find all files with space in their names under current directory
find . -type f -name '* *'

Find all files which have 211028 inode number in current directory then Locating and renaming unprintable directories
find . -inum 211028 -exec mv {} newname.dir \;

Find all files with the extension jpg regardless of case
find . -type f -iname '*.jpg' -print0

Find all files with the name "MyProgram.c" in the current directory and all of it's sub-directories.
find -name "MyCProgram.c"

Find all files with the SUID bit set, starting from /
find / -perm -u+s

Find all first occurrences of directories named '.texturedata' under '/path/to/look/in' directory tree
find /path/to/look/in/ -type d -name '.texturedata' -prune

Finds all folders that contain 'ssh' file and have 'bin' in path.
dirname `find / -name ssh | grep bin`

Finds all folders that contain 'ssh' file and have 'bin' in path.
find / -name ssh|grep bin|xargs dirname

Find all fonts (in '/usr/local/fonts') that belong to the user 'warwick'
find /usr/local/fonts -user warwick

find all foo.bar files in the entire file system and discard the errors
find / -name foo.bar -print 2>/dev/null

find all foo.bar files in the entire file system and which are present in the same partition as root.
find / -name foo.bar -print -xdev

Find all foo.mp4 files in the current directory tree
find ./ -name "foo.mp4" -exec echo {} \;

Find all foo.mp4 files in the current directory tree and print the pathnames of their parent directories
find . -name foo.mp4 -exec dirname {} \;

Find all foo.mp4 files in the current directory tree and print the pathnames of their parent directories
find . -name foo.mp4 -printf '%h\n'

Find all foo.mp4 files in the current directory tree and print the pathnames of their parent directories
find ./ -name "foo.mp4" -printf "%h\n"

find all jar files in current folder and search for a file in all these jar's
find . -name "*.jar" -exec jar -tf {} \;|grep  "message_track.properties"

Find and kill a process by name
kill $(ps aux | grep '[p]ython csp_build.py' | awk '{print $2}')

find all teh script files in a directory
find /home/john -name "*.sh" -type f -print

Find all hidden directories starting from the current directory
find . -type d -name ".*"

find all hidden files in the current folder which have been modified after profile file
find . -type f -name ".*" -newer .cshrc -print

Find all hidden files
find /tmp -type f -name ".*"

Find all hidden files in the current directory
find . -type f -name ".*"

Find all hidden (regular) files under /tmp
find /tmp -type f -name ".*"

Find all hidden files under /tmp
find /tmp -type f -name ".*"

Find all hidden files starting from the directory given as variable $FOLDER
find $FOLDER -name ".*"

Find all hidden regular files starting from the current directory
find . -type f -name ".*"

Find all your text files
find . -name "*.txt" -print

find all html files in the current directory which have size greater than 100 bytes and display their details and discard all the errors.
find . \( -size 100 -o -size -100 \)  -name '*.html' \    -exec  ls -l {} \;  2> /dev/null

Find all HTML files starting with letter 'a' in the current directory and below
find . -name a\*.html

Find all HTML files starting with letter 'a' in the current directory and below ignoring the case
find . -iname a\*.html

find all html or cgi files in current folder
find ./ -type f -iregex ".*\.html$" -or -iregex ".*\.cgi$"

Find all httpd.conf files in entire file system
find / -name httpd.conf

find and image in current folder (case insensitive search)
find . -iname "Articles.jpg"

Find all image.pdf files/directories under ./polkadots
find ./polkadots -name 'image.pdf'

Find all image.pdf files/directories under ./polkadots with null character as the delimiter
find ./polkadots -name "image.pdf" -print0

Find all identical files in the /usr directory tree that are bigger than 10000 bytes and write the result to usr.dups
find /usr -type f | samefile -g 10000 >usr.dups

Find all identical files in the HOME directory and subdirectories and tell if there are hard links
find $HOME -type f | samefile -r

find all instances of a file in current folder and discard the errors
find . -name "my.txt" 2>/dev/null

find all instances of a file in current folder and display all errors apart from permission denied
find . -name "my.txt" 2>&1 | grep -v "Permission denied"

find all instances of a file in current folder and save the errors to a file
find . -name "my.txt" 2> find_error.txt

find all instances of a file in the current folder and create a backup of it in the floppy
find . -name nameoffile -print | cpio -iv > /dev/fd0

find all instances of a specific file in the current directory and discard all the errors.
find . -name "openssl" 2>/dev/null

find all instances of a specific file in the current directory and discard all the errors and remove all permission denied statements from search results
find . -name "openssl" 2>&1 | sed '/Permission denied/d;'

find all instances of a specific file in the entire file system and discard the errors
find / -name expect 2>/dev/null

Find all instances of first column with unique rest of line, and output a count for each first column that found in unique lines.
sort file | uniq | cut -f1 -d' ' | uniq -c | rev

Find all IP addresses in /etc directory files
find /etc -exec grep '[0-9][0-9]*[.][0-9][0-9]*[.][0-9][0-9]*[.][0-9][0-9]*' {} \;

find all javascript files under the current folder
find . -name '*.js'

find all jpg files in current folder
find . -type f -name "*.JPG"

find all jpg files in the current folder
find . -name "*.jpg"

find all jpg images starting with image in the folder "dir" and give them as input to the script, script.ksh
find dir -name image\*.jpg -exec /bin/ksh script.ksh {} \;

find all jpg,png,jpeg,pdf,tif,tiff,bmp and other image formats using regular expressions excluding those ending with "_ocr.pdf"
find /somepath -type f -iregex ".*\.(pdf\|tif\|tiff\|png\|jpg\|jpeg\|bmp\|pcx\|dcx)" ! -name "*_ocr.pdf" -print0

find all js files under the build direcotry except build/external and build/log directory.
find build -not \( -path build/external -prune \) -not \( -path build/blog -prune \) -name \*.js

find all js files under the build direcotry except build/external directory.
find build -not \( -path build/external -prune \) -name \*.js

find all js files which path does not contain ./node_modules/* nor './vendor/*"
find -name '*.js' -not -path './node_modules/*' -not -path './vendor/*'

find all js files which path neither ./dir1 nor ./dir2
find . -name '*.js' -not \( -path "./dir1" -o -path "./dir2/*" \)

find all js files which path neither ./dir1 nor ./dir2 nor  ./dir3
find . -name '*.js' -not \( -path "./dir1" -o -path "./dir2/*" -o -path "./dir3/*"\)

Find all leaf directories that include only one occurrence of "modules"
find -regex '.*/modules\(/.*\|$\)' \! -regex '.*/modules/.*/modules\(/.*\|$\)' -type d -links 2

Find all level 1 subdirectories of the current directory
find . -maxdepth 1 -type d

Find and list all regular files
find . -type f -ls

Find all lines matching "$USER" in "file" and number the output
grep  $USER file |nl

Find all links pointing to /path/to/foo.txt
find . -lname /path/to/foo.txt

Find all links to path/to/file
find -L -samefile path/to/file

Find hard links to the same file lpi104-6/file1 in the directory tree lpi104-6
find lpi104-6 -samefile lpi104-6/file1

find all readable files
find / -readable

Find all m? directories under current directory and run ./fixmbox with all of the directory paths as its arguments
find . -name 'm?' -type d -exec ./fixmbox {} +

Find all Makefile's in the current directory tree
find -type f -name "Makefile"

find all gif files in the file system
find / -name "*gif" -print

Find all MP3 files in the home directory tree that were modified in the last 24 hours
find ~ -type f -mtime 0 -iname '*.mp3'

Find all MP3s in the /home directory tree
find /home -type f -name '*.mp3'

Find all mysong.ogg files/directories under your home directory
find $HOME -name 'mysong.ogg'

find all PDFs owned by user “seamstress”
find / -user seamstress -iname “*.pdf”

Find all of jzb's files
find -user jzb

Find all of the distinct file extensions in current directory
find . -type f | perl -ne 'print $1 if m/\.([^.\/]+)$/' | sort -u;

find all of the executable files on your computer
find / -executable

find all of the files that are readable
find / -readable

Find all of the hidden files in the current directory and its sub-directories.
find . -type f -name ".*

Find all OGG files in the home directory larger than 20 megabytes
find $HOME -iname '*.ogg' -size +20M

Find all OGG files in the home directory that are at most 20 megabytes in size
find $HOME -iname '*.ogg' ! -size +20M

Find all or single file called FindCommandExamples.txt under / directory of owner root
find / -user root -name FindCommandExamples.txt

Find all or single file called tecmint.txt under the / directory of owner root
find / -user root -name tecmint.txt

Find all orm* files/directories under current directory
find . -name 'orm*'

Find all orm.* files/directories under current directory
find . -name "orm.*"

find all pdf files in current folder and rename all these files
find . \( -name '*.pdf' -or -name '*.PDF' \) -execdir sh -c 'mv -v "$1" "$(echo "$1" | tr " " "_" | tr -d "{()},\!'\''" | tr "A-Z" "a-z" | sed "s/_-_/_/g")"' _ {} \;

find all pdf files in the current folder
find . -name “*.pdf” -print

find all png files in the current folder
find . -type f -name '*.png'

Find all php files in a directory
find . -type f -name "*.php"

Find all php files in current directory and delete text matching the regex '<?php /\*\*/ eval(base64_decode("aWY.*?>' in those files
find ./ -name "*.php" -type f | xargs sed -i 's#<?php /\*\*/ eval(base64_decode("aWY.*?>##g'  2>&1

Find all pdf files in current directory and grep with the regex expanded by "$1" in the converted text output and print the paths to the matching files
find . -name '*.pdf' -exec sh -c 'pdftotext "{}" - | grep --with-filename --label="{}" --color "$1"' -- "$1" \;

Find all php files in the current directory
find . -type f -name "*.php"

Find all PHP files in the current directory recursively
find . -name \*.php -type f

Find all PHP files in the current directory recursively and search them for string "$test" with 8 simultaneous processes
find . -name \*.php -type f -print0 | xargs -0 -n1 -P8 grep -Hn '$test'

Find all pdf files excluding *_signed.pdf files under /some/dir with null character as the delimiter
find /some/dir -name "*.pdf" ! -name "*_signed.pdf" -print0

Find all pdf files under /dir/containing/unsigned with null character as the delimiter
find /dir/containing/unsigned -name '*.pdf' -print0

Find all PHP files under current directory
find . -type f -name *.php

Find all php files under current directory
find . -type f -name "*.php"

Find all PHP files under current directory that contain only one line
find -name '*.php' -exec bash -c '[[ "$(wc -l < "$0")" -eq 1 ]] && echo "$0"' '{}' ';'

Find all PHP files under current directory that contain only one line
find . -type f -name '*.php' -exec wc -l {} \; | egrep "^\s*1\s"

Find all php files whose name is tecmint.php in a current working directory
find . -type f -name tecmint.php

Find all php files whose name is tecmint.php in the current directory
find . -type f -name tecmint.php

find all png images in the current folder and convert the to jpg images.
find . -name "*.png" -print0 | xargs -0 mogrify -format jpg -quality 50

find all png images in the current folder and convert the to jpg images. print0 is used to handle the files which have new lines in their names
find . -name "*.png" -print0 | xargs -0 mogrify -format jpg -quality 50

Find all top level directories under /home that doesn't contain a file/directory named 'bin'
for d in /home/*/; do find "$d" -type d -name bin | grep -q . || echo "$d"; done

Find all top level directories under current directory that doesn't contain a file/directory named 'bin'
comm -3 <(printf '%s\n' */ | sed 's|/.*||' | sort) <(find */ -type d -name bin | cut -d/ -f1 | uniq)

Finds all php processes running in system.
pstree | grep php

Find and print the names of all files found in the current directory and all of its sub-directories
find . -print

Find and print the names of all files found in the current directory and all of its sub-directories.
find .

Find and print the names of all files found in the current directory and all of its sub-directories.
find . -print

find all python files in current folder and test if there is a makefile in all these fodlers where these are present
find . -name '*.py' -exec bash -c 'test -f $(dirname "$1")/Makefile' -- {} \; -print

Find all python files (.py files) in $topdir directory tree and search for 'Makefile' in all these folders and display all distinct folders having 'Makefile'
find "$topdir" -name '*.py' -printf '%h\0' | xargs -0 -I {} find {} -mindepth 1 -maxdepth 1 -name Makefile -printf '%h\n' | sort -u

find all read me files in a folder
find /usr/share/doc -name README

find all readme files in a folder
find /usr/share/doc -name README

Find all Read Only files
find / -perm /u=r

Find all read only files in  /home directory
find /home -type f -perm /u=r

Find all Read Only files in entire file system and show a few lines of output from the beginning
find / -perm /u=r | head

Find all read-only files
find / -perm /u=r

Find all readme.txt files/directories under your home directory
find ~ -name readme.txt

find all regex  ".*/[a-f0-9\-]\{36\}\.jpg" files
find . -regextype sed -regex ".*/[a-f0-9\-]\{36\}\.jpg"

find all regex "./[a-f0-9\-]\{36\}\.jpg" files
find . -regex "./[a-f0-9\-]\{36\}\.jpg"

find all regex  '\./[a-f0-9\-]\{36\}\.jpg' files
find . -regex '\./[a-f0-9\-]\{36\}\.jpg'

Find all regular *.css files
find . -type f -name "*.css"

Find all regular .abc files under and below /the/path and rename them prefixing their names with "version_1"
find /the/path -type f -name '*.abc' -execdir rename 's/\.\/(.+)\.abc$/version1_$1.abc/' {} \;

Find all regular .html files in the /var/www directory tree
find /var/www -type f -name "*.html"

Find all regular .mp3 files larger than 10M and delete them
find / -type f -name *.mp3 -size +10M -exec rm {} \;

find all regular file and create jw-htmlfiles.tar
find . -type f -name "*html" | xargs tar cvf jw-htmlfiles.tar -

find all regular files exclude .o and exclude *.swp and output line number of soc_attach if it has
find .  \( ! -path "./output/*" \) -a \( -type f \) -a \( ! -name '*.o' \) -a \( ! -name '*.swp' \) | xargs grep -n soc_attach

find all regular files in a folder using regular expressions which do not have a specific name pattern and send these files as input to the script.bash script file
find "$DIRECTORY_TO_PROCESS" -type f -iregex ".*\.$FILES_TO_PROCES"  ! -name "$find_excludes" -print0 | xargs -0 -I {} bash script.bash {}

find all regular/normal files in current folder and display the filename and size
find $(pwd)/* -type f -exec stat -c "f%15s %n" {} +

find all normal/regular files in current folder an save the output to the files /tmp/grep1 & /tmp/grep2
find ./ -type f | tee /tmp/grep1 /tmp/grep2 >/dev/null

find all regular files in current folder which are atleast 1 level deep and search in the alphabetical order of the directory names
find -s . -mindepth 1 -type f -print0; printf '\0';

find all regular/normal files in current folder which have been modified in the last 60 minutes
find -type f -mtime -60

find all normal/regular files in current folder which end with "~" or which begin and end with "#" and and and delete them
find . -maxdepth 1 -type f -name '*~' -delete  -or -name '#*#' -delete

find all normal/regular files in the current directory
find . -type f -print

find all regular/normal files in the current folder
find -type f

find all regular/normal files in the current folder and display them in the a format.
find -type f -exec perl -e 'printf qq[%s => %s\n], scalar @ARGV, length join q[ ], @ARGV' {} +

find all regular/normal files in the current folder whose name has the word photo or picture and which have been modified in the last 30 minutes
find . \( -iname "*photo*" -or -name "*picture*" \) -and ! -type d -and -mmin -30

find all normal/regular files in the entire file system having the word "filename" in their name.
find / -type f -iname "filename"

find all normal/regular files in the folder "//path/to/source/Directory" and calculate the md5sum of them and save the output to  file Output.txt
find //path/to/source/Directory -type f -exec md5sum {} + | awk '{print $0}' > Output.txt

find all regular/normal files in the folder "myfiles" which have read and write permission to the other users
find /myfiles -type f -perm -o+rw

find all regular/normal files in the folder "pathfolder" and display the count of files, save all the errors to err.txt file
find pathfolder -type f  2> err.txt | wc -l

find all regular files under the /etc/sysconfig directory that were accessed in the last 30 minutes
find /etc/sysconfig -amin -30 -type f

find all regular/normal files which have cpp folder in their path
find . -type f -path "*/cpp/*"

find all regular/normal files which have execute permission in current folder and copy them to another folder
cp `find -perm -111 -type f` /usr/local/bin

find all regular files  then display the number of occurrences of banana without lines not proper end
find . -type f -print0| xargs -0 grep -c banana| grep -v ":0$"

Find all regular files newer than '/tmp/$$' (where $$ expands to current process id) under '/tmefndr/oravl01' directory tree
find /tmefndr/oravl01 -type f -newer /tmp/$$

Find all regular files in /usr/bin modified less than within the last 10 days
find /usr/bin -type f -mtime -10

Find all regular files in <path> and execute process with all of them as arguments
find <path> -type f -exec sh -c 'for f; do echo process $f;  done' sh {} +

Find all regular files in and below the home directory that have been modified in the last 90 minutes
find ~ -type f -mmin -90

Find all regular files in current directory and /home/www directory
find * /home/www -type f

Find all regular files in minimum 1 level down the $dir directory
find "$dir" -mindepth 1 -type f

Find all regular files in the "$dir" directory
find $dir -maxdepth 1 -type f

Find all regular files in the "aaa" directory
find aaa/ -maxdepth 1 -type f

Find all regular files in the /path/to/base/dir tree
find /path/to/base/dir -type f

Find all regular files in the current directory and its subdirectories.
find . -type f

Find all regular files in the current directory and search them for "example"
find -maxdepth 1 -type f | xargs grep -F 'example'

Find all regular files in the current director and set their permissions to '644'.
find ./ -type f -exec chmod 644 {} \;

Find all regular files in the current directory tree and count them
find -type f -printf '.' | wc -c

Find all regular files in the current directory tree and count them
find -type f | wc -l

Find all regular files in the current directory tree and search them for "example"
find -type f -print0 | xargs -r0 grep -F 'example'

Find all regular files in the current directory tree and print a command to move them to the current directory
find . -type f -exec echo mv -t . {} +

Find all regular files in the current directory tree, except GIT files
find .  -name .git -prune -o -type f -print

Find all regular files in the current directory tree ignoring directory ./source/script
find . -path ./source/script -prune -o -type f -print;

Find all regular files in the current directory tree ignoring GIT and SVN directories
find . \( -type d -regex '^.*/\.\(git\|svn\)$' -prune -false \) -o -type f -print0

Find all regular files in the current directory tree last modified between 1 and 3 days ago and list them using find's -ls option
find ./ -daystart -mtime -3 -type f  ! -mtime -1 -exec ls -ld {} \;

Find all regular files in the current directory tree last modified between 1 and 3 days ago and list them using format '%TY %p\n'
find ./ -daystart -mtime -3 -type f  ! -mtime -1  -printf '%TY %p\n'

Find all regular files in the current directory tree that are not readable by anyone
find . -type f ! -perm -444

Find all regular files in the current directory tree that match pattern 'btree*.c'
find . -type f -name 'btree*.c'

Find all regular files in the current directory tree that do not contain a whitespace
find . -type f \( -exec grep -q '[[:space:]]' {} \; -o -print \)

Find all regular files in the current directory tree that have been modified within the last 10 minutes
find . –type f -mmin -10

Find all regular files in the current directory tree whose names are "YourProgramName", change to the directories they are in, and execute them with parameter "YourParameterFile"
find . -type f -name YourProgramName -execdir ./YourProgramName YourParameterFile \;

Find all regular files in the current directory tree whose names end with ".DS_Store" and delete them
find . -type f -name '*.DS_Store' -ls -delete

Find all regular files in the home directory tree that were modified in the last 24 hours
find ~ -type f -mtime 0

Find all regular files in the the user's home/mail directory and search for the word "Linux".
find ~/mail -type f | xargs grep "Linux"

Find all regular files under $DIR directory tree whose paths match the regex ".*\.${TYPES_RE}" where ${TYPES_RE} expands as a variable
find ${DIR} -type f -regex ".*\.${TYPES_RE}"

Find all regular files under $DIR directory tree with ".$TYPE" extension (case insensitive) where $TYPE expands in the current shell
find $DIR -type f -iname "*.$TYPE"

Find all regular files under $DIR/tmp/daily/, sort them in reverse numerical order and copy the first two files to $DIR/tmp/weekly/
find $DIR/tmp/daily/ -type f -printf "%p\n" | sort -rn | head -n 2 | xargs -I{} cp {} $DIR/tmp/weekly/

Find all regular files under $DIRECTORY_TO_PROCESS matching the case insensitive regex ".*\.$FILES_TO_PROCES" where $FILES_TO_PROCES is a variable and not matching the name pattern '$find_excludes' where $find_excludes is another variable, then print the files with null delimiter instead of newline
find "$DIRECTORY_TO_PROCESS" -type f -iregex ".*\.$FILES_TO_PROCES" ! -name "$find_excludes" -print0

Find all regular files under $FILES_PATH directory tree and save the output to 'FILES' variable
FILES=$(find $FILES_PATH -type f -name "*")

Find all regular files under $FOLDER directory tree that start with '".' and end with '"' in their names and were modified in less than $RETENTION days excluding the files whose contents match one of the regular expressions defined per line in file $SKIP_FILE
find ${FOLDER} -type f ! -name \".*\" -mtime -${RETENTION} | egrep -vf ${SKIP_FILE}

Find all regular files under $d directory tree and change their permissions to 777
find "$d/" -type f -print0 | xargs -0 chmod 777

Find all regular files under $dir
find $dir -type f

Find all regular files under $dir directory tree that are bigger than $size MB in size and print them along with their sizes in decreasing order of size
find $dir -type f -size +"$size"M -printf '%s %p\n' | sort -rn

Find all regular files under  $somedir directory and print each of their paths after a string literal 'Found unexpected file '
find "$somedir" -type f -exec echo Found unexpected file {} \;

Find all regular files under ${S} directory
find "${S}" -type f

Find all regular files under ${path} without following symlinks
find ${path} -P -type f

Find all regular files under '/directory_path' directory tree that have been modified within the last day
find /directory_path -type f -mtime -1 -print

Find all regular files under '/home/john' directory tree that start with 'landof' in their names
find /home/john -name "landof*" -type f -print

Find all regular files under '/home/john/scripts' directory tree excluding files with '.ksh' extension
find /home/john/scripts -type f -not -name "*.ksh" -print

Find all regular files undee '/usr/bin' directoryt tree that are less than 50 bytes in size
find /usr/bin -type f -size -50c

Find all regular files under '/usr/bin' directory tree that are less than 50 bytes in size
find /usr/bin -type f -size -50c

Find all regular files under ./Desktop directory
find ./Desktop -type f

Find all regular files under /home/www and replace every occurrences of 'subdomainA.example.com' with 'subdomainB.example.com' in those files
cd /home/www && find . -type f -print0 | xargs -0 perl -i.bak -pe 's/subdomainA\.example\.com/subdomainB.example.com/g'

Find all regular files under /home/www and replace every occurrences of 'subdomainA.example.com' with 'subdomainB.example.com' in those files
find /home/www/ -type f | xargs perl -pi -e 's/subdomainA\.example\.com/subdomainB.example.com/g'

Find all regular files under /home/www and replace every occurrences of 'subdomainA.example.com' with 'subdomainB.example.com' in those files invoking perl as few times as possible and also keep backups with .bak extension.
find /home/www/ -type f -exec perl -i.bak -pe 's/subdomainA\.example\.com/subdomainB.example.com/g' {} +

Find all regular files under and below /home/admin/public_html/, and change their permissions to 644
find . /home/admin/public_html/ -type f -exec chmod 644 {} \;

Find all regular files under and below /home/user/demo/
find /home/user/demo -type f -print

Find all regular files under and below /root that match pattern "*linux*", case insensitive
find /root -type f -iname "*linux*"

Find all regular files under and below dir/ and change their names from UTF8 to the ASCII/TRANSLIT encoding
find dir/ -type f -exec mv {} $(echo {}.fix | iconv -f UTF8 -t ASCII//TRANSLIT ) \;

Find all regular files under current directory
find . -depth -type f -print

Find all regular files under current directory
find . -type f

Find all regular files under current directory tree containing 'some text' in their names without descending into hidden directories and excluding hidden files
find . -type d -path '*/\.*' -prune -o -not -name '.*' -type f -name '*some text*' -print

Find all regular files under current directory tree excluding files from './dir1' (except './dir1/subdir1/) and './dir2' directories
find . \( -not -path './dir1/*' -and -not -path './dir2/*' -or -path './dir1/subdir1/*' \) -type f

Find all regular files under current directory tree that match the regex 'tgt/etc/*' in their paths
find . -type f -name \* | grep "tgt/etc/*"

Find all regular files under current directory tree that were accessed $FTIME days ago
find . -type f -atime $FTIME

Find all regular files under current directory tree whose names end with 'cache' or 'xml' or 'html'
find . -type f \( -name "*cache" -o -name "*xml" -o -name "*html" \)

Find all regular files under current directory tree without descending into './dir1' (except './dir1/subdir1*' pattern) and './dir2' directories
find . \( -path './dir1/*' -and -not -path './dir1/subdir1*' -or -path './dir2' \) -prune -or -type f -print

Find all regular files under test directory
find test -type f

Find all regular files matching the name pattern '*.?htm*' under '/srv/www' and '/var/html' directory tree
find /srv/www /var/html -name "*.?htm*" -type f

Find all regular files named 'Chapter1' under current directory tree
find . -name Chapter1 -type f -print

Find all regular files named 'Waldo' under 'Books' directory tree that is located in user's home directory
find ~/Books -type f -name Waldo

Find all regular files named 'Waldo' under ~/Books directory tree
find ~/Books -type f -name Waldo

Find all regular files named 'whatever' under current directory tree excluding all paths that contain any hidden directory
find . \( ! -regex '.*/\..*' \) -type f -name "whatever"

Find all regular files named postgis-2.0.0 under current directory
find . -type f -name "postgis-2.0.0"

Find all regular files named postgis-2.0.0 under your home directory
find ~/ -type f -name "postgis-2.0.0"

Find all regular files on the system whose names are 'myfile'
find / -name myfile -type f -print

Find all regular files recursively in the current directory
find . -type f

Find all regular files residing in the current directory tree and search them for string "/bin/ksh"
find . -type f -print | xargs grep -i 'bin/ksh'

Find all regular files starting from / that have permissions 777
find / -type f -perm 0777

Find all regular files starting from level 3 of directory tree ~/container and move them one level up
find ~/container  -mindepth 3 -type f  -execdir mv "{}" $(dirname "{}")/.. \;

Find all regular files starting from level 3 of directory tree ~/container and move them one level up
find ~/container  -mindepth 3 -type f | while read file; do mv "$file" "$(dirname "$file")/.."; done

Find all regular files starting from level 3 of directory tree ~/container and move them one level up
find ~/container  -mindepth 3 -type f | xargs -i bash -c 'mv "{}" $(dirname "{}")/..'

Find all regular files starting from level 3 of directory tree ~/container and move them one level up
find ~/container -mindepth 3 -type f -execdir mv "{}" ./.. \;

Find all regular files starting from level 3 of directory tree ~/container and move them to the current directory
find ~/container  -mindepth 3 -type f -exec mv {} . \;

Find all regular files starting from level 3 of directory tree ~/container and move them to the current directory's parent
find ~/container  -mindepth 3 -type f -exec mv {} .. \;

Find all regular files starting from the current directory
find . -type f

Find all regular files that contain 'linux' (case insensitive) in their names under '/root' directory tree
find  /root -type f -iname "*linux*"

Find all regular files that reside in the current directory tree and were last modified 1 day ago
find . -type f -mtime 0

Find all regular files that reside in the current directory tree and were last modified at least 1 day ago
find . -type f -mtime +0

Find all regular files that reside in the current directory tree and were last modified more than 1 day ago
find . -type f -mtime +1

Find all regular files that reside in the current directory tree and were last modified more than 2 days ago
find . -type f -mtime +2

Find all regular files that reside in the current directory tree and were last modified more than 3 days ago
find . -type f -mtime +3

Find all regular files that reside in the current directory tree and were last modified more than 5 days ago
find . -type f -mtime +5

Find all regular files that reside in the current directory tree and were last modified more than 7 days ago
find . -type f -mtime +7

Find all regular files that start with stat
find . -type f –iname stat*

Find all regular files that were modified $FTIME days ago under current directory tree
find . -type f -mtime $FTIME

Find all regular files that were modified more than 60 days ago under '/path-to-directory' directory tree, sort them according to timestamp and print the filenames preceded with the timestamps
find /path-to-directory -type f -mtime +60 -printf "%T@ %p\n" | sort

Find all regular files whose names contain "@" in directory tree ~/$folder
find ~/$folder -name "*@*" -type f

Find all regular files whose names contain "@" in directory tree ~/$folder
find ~/$folder -name "*@*" -type f -print0

Find all regular files whose names contain a case insensitive pattern composed of space separated positional arguments and display a long listing of them
find . -type f -iname '*'"$*"'*' -ls

Find all regular files whose names do not end in "*.html"
find . -type f -not -name "*.html"

Find all regular files with '.jpg' (case insensitive) extension, sort them by name, print the output  and also save the list to file 'file_list.txt'
find . -type f|grep -i "\.jpg$" |sort| tee file_list.txt

Find all regular files with '.r' and '.c' in their names under current directory tree
find ./ -type f \( -name '*.r*' -o -name '*.c*' \) -print

Find all regular files with '.txt' extension excluding 'README.txt' files under current directory tree
find . -type f -name "*.txt" ! -name README.txt -print

Find all regular files with 400 permission under '/data' directory tree
find /data -type f -perm 400 -print

Find all regular files with 755 permission under current directory tree and change their permission to 644
find . -type f -perm 755 -exec chmod 644 {} \;

Find all regular files with name pattern $filename under $fileloc directory tree
find "$fileloc" -type f -prune -name "$filename" -print

Find all regular files with space in their names under current directory and rename them by replacing all spaces with _
find -name "* *" -type f | rename 's/ /_/g'

Find all regular files with permissions 777 under and below /home/user/demo/
find /home/user/demo -type f -perm 777 -print

Find all regular files with permissions 777 under and below /home/user/demo/, and change their permissions to 755
find /home/user/demo -type f -perm 777 -print -exec chmod 755 {} \;

Find all regular files with the group read permission set in your home directory and below and output detailed information about each file.
find . -perm -g=r -type f -exec ls -l {} \;

Find all regular non-hidden files in the current directory and its subdirectories
find . -not -path '*/\.*' -type f \( ! -iname ".*" \)

Find and remove all .mp3 regular files under the current directory and below
find . -type f -name "*.mp3" -exec rm -f {} \;

Find and remove all .txt regular files under the current directory and below
find . -type f -name "*.txt" -exec rm -f {} \;

Find and remove multiple *.mp3 files
find . -type f -name "*.mp3" -exec rm -f {} \;

Find and remove multiple *.txt files
find . -type f -name "*.txt" -exec rm -f {} \;

Fiind and remove multiple files such as *.mp3 or *.txt
find . -type f -name "*.txt" -exec rm -f {} \;

Find and remove multiple files such as *.mp3 or *.txt
find . -type f -name "*.mp3" -exec rm -f {} \;

Find and remove multiple files such as *.mp3 or *.txt under current directory
find . -type f -name "*.mp3" -exec rm -f {} \;

Find and remove multiple files such as *.mp3 or *.txt under current directory
find . -type f -name "*.txt" -exec rm -f {} \;

Find and remove the .rhosts file in the /home directory tree
find /home -name .rhosts -print0 | xargs -0 rm

Find and remove the file with inode number 782263 in the current directory tree
find . -inum 782263 -exec rm -i {} \;

Find and remove zero bytes files from user's directories .
find /usr/* -size 0c -exec rm {} \;

Find and replace xxx with yyy in whole directory tree
find . -type f -exec perl -pi -e 's|xxx|yyy|g' {} ;

Find all xml files under current directory
find . -name '*.xml'

Find all xml files under current directory and archive them to .bz2 archives
find -name \*.xml -print0 | xargs -0 -n 1 -P 3 bzip2

Find all xml files under current directory and archive them to .bz2 archives
find . | grep ".xml$" | parallel bzip2

Find all xml files under current directory and archive them to .bz2 archives
for i in `find . | grep ".xml$"`; do bzip2 $i&; done

Find all xml files under current directory and archive them to .bz2 archives
for i in `find . | grep ".xml$"`; do bzip2 $i; done

Find all sample* files/directories under current directory and print 'program {}-out {}' where {} will expand to file paths
find . -name "sample*" | parallel --dry-run program {}-out {}

Find all sample* files/directories under current directory and print 'program {}-out {}' where {} will expand to file paths
find . -name "sample*" | xargs -i echo program {}-out {}

Find all sample*_1.txt files/directories under current directory
find . -name "sample*_1.txt"

Find all sample*_1.txt files/directories under current directory, remove _1.txt from the end of file paths and pipe them to the command `parallel program {}-out {}_1.txt {}_2.txt`
find . -name "sample*_1.txt" | perl -pe 's/_1\.txt$//' | parallel program {}-out {}_1.txt {}_2.txt

Find and show all files in the current directory tree that are exactly 2000 kB
find . -size 2000k

Find and show all files in the current directory tree that are smaller than 500 kB
find . -size -500k

Find and show all files on the system that are larger than 900 MB
find / -size +900M

Find all file in current directory with have .c extenstion & have 777 permission . delete then
find . -name "*.c" -a  -perm -777 | xargs rm -rf

Find all file names in the current directory tree that begin with "headdump" and write them to file `delete.txt'
find . -name headdump* >delete.txt

Find all file paths under current directory, sort them numerically and show last 10 lines of output with only their paths
find . -type f -printf '%T@ %p\n' | sort -n | tail -10 | cut -f2- -d" "

Find all file paths under current directory, perform a reverse numerical sort and show first 10 file paths with their status change time
find . -type f -printf "%C@ %p\n" | sort -rn | head -n 10

Find all file which have more the 2 hard link
find .  -type f -links +2 -exec ls -lrt {} \;

find all gzip files in a folder
find /home/foo -name "*.gz"

Find all SGID files
find / -perm /g=s

Find all SUID files .
find /  -perm /u=s

Find all SGID files in entire file system
find / -perm +2000

Find all SGID files in entire file system
find / -perm +g=s

Find all SUID files in entire file system
find / -perm +4000

Find all SUID files in entire file system
find / -perm +u=s

Find all SGID set files
find / -perm /g=s

Find all SUID set files
find / -perm /u=s

Find all SGID set files in the file system
find / -perm /g=s

Find all SUID set files in the file system
find / -perm /u=s

Find all SGID set files under current directory and show a few lines of output from the beginning
find . -perm /g+s | head

Find all SUID set files under current directory and show a few lines of output from the beginning
find . -perm /u=s | head

Find all socket files in the current directory and its sub-directories.
find . -type s

Find all Perl source code files
find . -name "*.pl"

find all sqlite files in the current directory.
find ./ -name "*.sqlite"

Find all status.c files in the current directory tree and show stat's information on them
find . -name status.c -exec stat --format "%A %s %x %n" {} \;

Find all subdirectories of the current directory except hidden ones
find -maxdepth 1 -type d ! -name ".*"

Find all symbolic links containing 'javaplugin' in their names under '/usr' directory tree
find /usr/ -lname *javaplugin*

Find all symbolic links containg 'vim' in their names under '/usr/bin' directory tree
find /usr/bin -name '*vim*' -type l

Find all symbolic links containing 'vim' in their names uder '/usr/bin' directory tree
find /usr/bin -name '*vim*' -type l

Find all symbolic links in the current directory tree
find -type l

Find all symbolic links in the current working directory that link to files outside the current working directory
find . -type l -exec sh -c 'echo $(readlink -f "{}") "<-- {}"' \; | grep -v "^$(readlink -f ${PWD})"

Find all symbolic links under '/proc/$pid/fd' directory tree with name pattern '$save_path/sess_\*' and update their timestamps
find "/proc/$pid/fd" -ignore_readdir_race -lname "$save_path/sess_\*" -exec touch -c {}

Find all symbolic links under '/some/directory' driectory tree
find /some/directory -type l -print

Find all symbolic links under '/some/directory' tree
find /some/directory -type l -print

Find all symbolic links under current directory that are not hard links
find . -type f -links 1 -print

Find all symbolic links under the current folder and below
find –L –xtype l

Find all symbolic links starting from the current directory and list them
find . -type l -ls

Find all symlinks in the /myfiles directory tree
find /myfiles -type l

Find all symlinks under /myfiles directory
find /myfiles -type l

Find all symlinks under current directory
find . -type l

Find all symlinks under current directory
find ./ -type l

Find all syslog directories under /var/log directory
find /var/log -name "syslog" -type d

Find all test.txt files/directories under current directory
find . -name test.txt

Find all test1.h files under current directory
sudo find . -name test1.h

Find all test2.h files under current directory
sudo find . -name test2.h

find all the ".JPG" files in current folder and display their count
find ./ -name '*.JPG' -type f | wc -l

find all the ".c" files in the folder "/home/you" which have been accessed in the last 30*24 hours
find /home/you -iname "*.c" -atime -30 -type -f

find all the ".c" files in the folder /home/david which have been modified in the last 48 hours
find /home/david -mtime -2 -name '*.c'

find all the ".flac" files in the current folder and convert them to mp3 with 128k bit rate
find -name "*.flac" -exec ffmpeg -i {} -acodec libmp3lame -ab 128k {}.mp3 \;

find all the ".flac" files in the current folder and convert them to mp3 with 160k bit rate
find . -name "*.flac" -exec ffmpeg -i {} -ab 160k -map_metadata 0 -id3v2_version 3 {}.mp3 \;

find all the ".flac" files in the current folder and create a sub shell and convert these to mp3 with 128k bit rate
find -name "*.flac" -exec bash -c 'ffmpeg -i "{}" -y -acodec libmp3lame -ab 128k "${0/.flac}.mp3"' {} \;

find all the ".jpg" files in current folder and display their count
find ./ -name '*.jpg' -type f | wc -l

find all the ".mov" files in the current folder and give it as an input to the myffmpeg.sh script file
find . -iname "*.mov" -exec /path/to/myffmpeg.sh {} \;

find all the ".mov" video files in the current folder and convert them to flv using ffmpeg. print0 is used to handle files with newline in their names
find . -iname "*.mov" -print0 | xargs -0 -i sh -c 'ffmpeg -i {} -f flv `basename {}`'

find all the ".sh" files in the current folder ( case insensitive search)
find -iname *.SH

find all the ".wma" files in the folder "$current_directory"
find "${current_directory}" -type f -iname "*.wma"

find all the "jpg" file in a folder.
find /win/C -iname *JPG

find all the "passwd" files in the entire file system
find / -iname passwd

Find all the *.c files at any level of directory Programming under any 'src' directory
find ~/Programming -path '*/src/*.c'

find all the *.conf files under / (root)
find / -name "*.conf"

find all the *.conf files under / (root) redirecting error messages to /dev/null
find / -name "*.conf" 2>>/dev/null

Find all the *.pl files (Perl files) beneath the current directory.
find . -name "*.pl"

Find all the .c files in the current directory tree that contain the string ‘stdlib.h’
find . -name '*.c' | xargs grep 'stdlib.h'

Find all the .c files in the current directory tree that contain the string ‘stdlib.h’
find . -name ‘*.c’ | xargs egrep stdlib.h

find all the .jpg files in / and copy them to the current folder.
find / -type f -name *.jpg  -exec cp {} . \;

Find all the .mp3 files in the music folder and pass to the ls command, -print0 is required if any filenames contain whitespace
find ./music -name "*.mp3" -print0 | xargs -0 ls

Find all the .mp3 files in the music folder recursively and pass them to the ls command
find ./music -name "*.mp3" -print0 | xargs -0 ls

find all the log files in the file system
find / -name "*.log"

find all the backup files in the current folder and delete them
find . -type f -name "*.bak" -exec rm -f {} \;

find all the backup files in the current folder and delete them
find . -type f -name “FILE-TO-FIND” -delete;

find all the backup files in the current folder and delete them after user confirmation
find . -type f -name "*.bak" -exec rm -i {} \;

find all the bit map files (.bmp) in the current folder and convert them to .png
find . -name "*bmp" -print0 | xargs -0 -l -i basename "{}" ".bmp" | xargs -0 -l -i convert "{}.bmp" "{}.png"

find all the config(.conf files) files in the folder /home/pat
find /home/pat -iname "*.conf"

find all the configuration files in /etc folder along with the last access & modification time
find /etc -name "*.conf" -printf "%f %a, %t\n"

find all the configuration files in the file system
find / -name "*.conf"

find all the configuration files in the files system and donot display any errors.
find / -name "*.conf" 2>>/dev/null

find all the configuration files which have been accessed in the last 30 minutes.
find /etc/sysconfig -amin -30

find all the configuration or text files in current directory
find . -type f \( -name "*.conf" -or -name "*.txt" \) -print

find all the cpp(C++ source files), java, header files in the current directory
find . -name *.cpp -o -name *.h -o -name *.java

find all the css files
find -name '*.css'

find all the cpp files in current folder
find -name "*.cpp"

find all the cpp files in the current folder
find . -iname '*.cpp' -print

find all the cpp files in the current folder and move them to another folder
find . -type f -iname '*.cpp' -exec mv {} ./test/ \;

find all the cpp files in the current folder and move them to another folder(plus takes the bulk output of the find command and gives it as input to the move command in exec)
find . -type f -iname '*.cpp' -exec mv -t ./test/ {} \+

find all the JSON files in the directory "PROD/140725_D0" and send them as input to the python script "/tmp/test.py"
find /PROD -type d -execdir sh -c 'for f in *.json; do /tmp/test.py "$f"; done' \;

find all the core files in the entire file system and  delete them
find / -name core -exec rm -f {} \;

find all the database files in the folder /var/named
find /var/named -type f -name *.db

find all the directory's from root which have the sticky bit on and display their details. Do not display any errors on the standard output.
find / -type d  -perm -1000  -exec ls -ld {} \; 2> /dev/null

find all the directories in current folder and delete them
find . -type d -delete

find all the directories in current folder and do not search in sub directories
find . -maxdepth 1 -type d -print0

find all the directories in current folder which start with test
find . -type d -name "test*"

find all the directories in the $LOGDIR folder which have been modified in the last 24 hours and compress them
find $LOGDIR -type d -mtime +0 -exec compress -r {} \;

find all the direcories in the current folder
find -type d

find all the directories in the current folder
find -type d

find all the directories in the current folder
find . -type d -print

find all the directories in the current folder and change to these directories and run a command
find . -type d -exec sh -c 'cd -P -- "{}" && pwd -P' \;

find all the directories in the current folder and create the same directory structure in a remote machine using ssh
find -type d | ssh server-B 'xargs -I% mkdir -p "/path/to/dir/%"'

find all the directories in the current folder excluding search in the sub directories and create these directories in another path
find . -maxdepth 1 -type d | xargs -I X mkdir '/new/directory/X'

find all the directories in the current folder which have been modified in 24 hours and move them to the folder  /path/to/target-dir
find . -depth -type d -mtime 0 -exec mv -t /path/to/target-dir {} +

find all the directories in the current folder which have been modified in 24 hours and move them to the folder  /path/to/target-dir
find . -type d -mtime -0 -exec mv -t /path/to/target-dir {} +

find all the directories in the current folder which have been modified in 24 hours and move them to the folder  /path/to/target-dir
find . -type d -mtime -0 -print0 | xargs -0 mv -t /path/to/target-dir

find all the directories in the current folder which have been modified in 24 hours and move them to the folder  /path/to/target-dir
find . -type d -mtime 0 -exec mv {} /path/to/target-dir \;

find all the directories in the different folders excluding search in the sub directories and create these folders in the current directory
find /media/New\ Volume/bhajans -maxdepth 1 -type d | xargs -0 mkdir -p

find all the directories in the file system which have read, write and execute to all the users
find / \( -type d -a -perm -777 \) -print

find all the directories in the file system which begin with "man"
find / -type d -name 'man*' -print

find all the directories in the folder /raid with the extension local_sd_customize.
find /raid -type d -name ".local_sd_customize" -print

find all the directories in the home folder and make create the directory junk. If any errors (like permission denied) occur discard them.
find ~ -type d -exec mkdir junk {} \; 2> /dev/null

find all the directories in the home folder do not search in sub directories
find /home -maxdepth 1 -type d

find all the directories starting with the name "someNamePrefix" which have not been modified in the last 10 days and force delete them
find /somePath -type d -name ‘someNamePrefix*’ -mtime +10 -print | xargs rm -rf ;

find all the directories with the name "DIRNAME" in the current folder and force delete them
find . -type d -name “DIRNAME” -exec rm -rf {} \;

find all the directories  with the name "c" in the current folder which are at least 3 levels deep and which are not present in the path "/p/".
find -mindepth 3 -type d ! -path '*/p/*' -name c -print

find all the directories  with the name "c" in the current folder which are at least 3 levels deep and which are not present in the path "/p/".
find -mindepth 3 -type d -path '*/p/*' -prune -o -name c -print

find all the directories with the name "some-dir" in the current folder and move them to another folder and do not search in subfolders
find ./ -maxdepth 1 -name "some-dir" -type d -print0 | xargs -0r mv -t x/

find all the directories with the name "uploads" in current folder
find . -type d -name 'uploads'

find all the patch files in current folder and copy them to separate folder patches
find -name '*.patch' -print0 | xargs -0 -I {} cp {} patches/

find all the empty directories in current folder and delete them
find ./ -empty -type d -delete

find all the empty directories in the current folder
find . -type d -empty

find all the empty directories in the current folder and all its sub directories too
find . -depth -empty -type d

find all the empty in the current folder do not search in sub directories
find . -maxdepth 1 -type d -empty

find all the empty regular/normal files in the current folder and delete them
find . -type f -empty -delete

find all the error, access, ssl_engine and rewrite logs which are bigger than 300MB and are less then 5GB in the folder /opt
find /opt \( -name error_log -o -name 'access_log' -o -name 'ssl_engine_log' -o -name 'rewrite_log' -o  -name 'catalina.out' \) -size +300000k -a -size -5000000k

find all the wav files in the current folder and do not search in the sub directories
find . -name '*.wav' -maxdepth 1

find all the text files in current folder and force delete them
find . -name "*.txt" | xargs rm -rf

find all the text files in current folder and move all these to another folder appending ".bar" at the end of these files
find . -name "*.txt" | xargs -I '{}' mv '{}' /foo/'{}'.bar

find all the text files in the home directory
find ~/ -name '*.txt'

find all the text files in the home folder
find ~ -name "*.txt" — print

find all the text files in the home folder and display the first lines. Save the output to the file report.txt
find $HOME/. -name *.txt -exec head -n 1 -v {} \; > report.txt

find all the text files in the current directory which have been modified in the last 4 days and not today and copy them to another folder
find . -name "*.txt" -type f -daystart -mtime -4 -mtime +0|xargs -i cp {} /home/ozuma/tmp

find all the text files in the current folder
find . -name "*.txt" -print

find all the text files in the current folder
find . -type f -name '*.txt' -print

find all the text files in the current folder
find . — name "*.txt" — print

find all the text files in the current folder and display their Permissions and size along with their name
find . -name "*.txt" -printf "%M %f \t %s bytes \t%y\n"

find all the text files in  the current folder and do not search in somedir, bin directories
find . -name somedir -prune , -name bin -prune -o -name "*.txt" -print

find all the text files in  the current folder and do not search in somedir, bin directories
find . \( -name somedir -prune \) , \( -name bin -prune \) -o \( -name "*.txt" -print \)

find all the text files in the current folder and do not  search in the sub directories
find -maxdepth 1 -iname "*.txt"

find all the text files in the current folder expect those which are in the path "sk"
find . -path "./sk" -prune -o -name "*.txt" -print

find all the text files in the current folder starting with "somefiles-"
find . -name "somefiles-*-.txt" -type f

find all the text files in the file system and search only in the disk partition of the root.
find / -mount -name "*.txt"

find all the text files in the file system and search only in the disk partition of the root.
find / -xdev -name "*.txt"

find all the text files in the folder /home/calvin and do not search beyond 2 levels
find /home/calvin/ -maxdepth 2  -name “*.txt”

find all the text files in the folder /tmp/1 and display only those files which have spaces in their names
find "/tmp/1/" -iname "*.txt" | sed 's/[0-9A-Za-z]*\.txt//g

find all the text files present in the current directory excluding the search in certain paths.
find . -type f -name "*.txt" ! -path "./Movies/*" ! -path "./Downloads/*" ! -path "./Music/*"

find all the text files that have modified in the last 2 days and not modified today
find . -name "*.txt" -type f -daystart -mtime +0 -mtime -2

find all the text files which are present in the current directory excludinghidden files.
find . -type f \( -iname "*.txt" ! -iname ".*" \)

find all the files from root folder which have nogroup or noname and dispaly their details.
find / \( -nogroup -o -noname \) -ls

find all the files ending with ".coffee" in the current folder and search for the words "re" in each line
find . -name \*.coffee -exec grep -m1 -i 're' {} \;

find all the files ending with ".foo" in the folder /usr
find /usr -name '*.foo' -print

find all the files ending with ".mkv" in a folder and send them as an argument to a shell script
find /volume1/uploads -name "*.mkv" -exec /tmp/rename.sh \{\} \;

find all the files ending with ".sh" in the folder /dir excluding those wth the names foo and bar.
find /dir \( -name foo -prune \) -o \( -name bar -prune \) -o -name "*.sh" -print

find all the files ending with "clj" in the current folder and search for a pattern
find . -name '*.clj' -exec grep -r resources {} \;

find all the files ending with "clj" in the current folder and search for a pattern
find . -name *.clj | xargs grep -r resources

find all the files ending with "mkv" in current folder
find -name "*.mkv"

find all the files ending with "~" in current folder and move them to temp folder
find -name '*~' -print0 | xargs -0 -I _ mv _ /tmp/

find all the files ending with .ini in the current directory.
find . -name *.ini

find all the files ending with .mp3 or .jpg
find . \( -name '*.mp3' -o -name '*.jpg' \) -print

find all the files ending with emlx in a folder and save the output to a list file
find /path/to/folders/ -name \*.emlx -print0 > filelist

find all the files ending with undo in the current folder and calculate the total size of these files
find -name *.undo -exec stat -c%s {} \; | awk '{total += $1} END {print total}'

find all the files ending with undo in the current folder and calculate the total size of these files
find . -name "*.undo" -ls | perl -lane '$t += $F[6]; END{print $t}'

find all the files older than 30 days
find /tmp -mtime +30 -print

find all the files in current directory of size exactly 6MB.
find . -size 6M

find all the files in current directory of size greater than 10MB and less than 20 MB.
find . -size +10M -size -20M

find all the files in current directory of size greater than 2GB.
find . -size +2G

find all the files in current directory of size smaller than 10KB.
find . -size -10k

find all the files in current folder ending with "ini" and display all files which contain several patterns
find . -name *.ini -exec sh -c "grep -q PROJECT_A {} && grep -q CONFIG_A {} && echo {}" \;

find all the files in current folder ending with "ini" and search for a word in all these files
find . -name *.ini -exec grep -w PROJECT_A {} \; -print | grep ini

find all the files in current folder which have spaces and save the long listing of these files to log file before deleting them
find . -name "filename including space" -print0 | xargs -0 -I '{}' sh -c 'ls -aldF {} >> log.txt; rm -rdf {}'

find all the files in current folder which end with ".bak" or ".backup" which have not been accessed in the last 30 days and delete the files if they exist
find . ( -name '*.bak' -o -name *.backup ) -type f -atime +30 -exec csh -c 'if ( -f $1:r ) rm $1' '{}' ;

find all the files in current folder which end with a speicifc regular expression and display their count
find ./ -type f -regex ".*\.[JPGjpg]$" | wc -l

find all the files in home folder which have been modified in the last 24 hours
find $HOME -mtime -1

find all the files in some directory which have not been modified in the last 7*24 hours
find <dir> -mtime +7

find all the files in the /usr folder that have been modified after the file /usr/FirstFile.
find /usr -newer /usr/FirstFile -print

find all the files in the /usr folder which have modification date less than or equal to the file "/FirstFile"
find /usr ! -newer /FirstFile -print

find all the files in the home folder that are modified day before yesterday
find $HOME -mtime -2 -mtime +1

find all the files in the home folder that have not been modified in the last one year
find $HOME -mtime +365

find all the files in the home folder that have been modified between 24 to 48 hours
find $HOME -mtime -2 -mtime +1

find all the files in the home folder that belong to a specific user
find /home -user <usernmae> -print

find all the files in the home folder which are less than 300Bytes
find ~ -size -300b

find all the files in the home folder which are less than 42 Bytes
find / -size 42

find all the files in the home folder which have not been modified in the last 1 year.
find $HOME -mtime +365

find all the files in the home folder which have been modified after a file
find $HOME -newer ~joeuser/lastbatch.txt

find all the files in the home folder which have been modified in 1 year or more ( which are not modified in the last 1 year ).
find $HOME -mtime +365

find all the files in the home folder which have been modified in the last 24 hours
find $HOME -mtime -1

find all the files in the home folder which have been modified in the last 7 days
find $HOME -mtime -7

find all the files in the home folder which end with ".tex"
find ~ -iname '*.tex'

find all the files in the current directory and change the permissions to 775.
find . -exec chmod 775 {} \;

find all the files in the current directory and display them
find . -exec echo {} ;

find all the files in the current directory and search for the word "pw0" in them.
find . -exec grep -i "pw0" {} \;

find all the files in the current directory and print them excluding those that have the name SCCS.
find . -print -o -name SCCS -prune

find all the files in the current directory and sub-directories, that were edited within the last 1 hour and execute the list command with long listing format
find -mmin -60 -exec ls -l {} \;

find all the files in the current directory and sub-directories whose status was changed after /etc/fstab was modified
find -cnewer /etc/fstab

find all the files in the current directory ending with ".i"
find . -name ".*\.i"

find all the files in the current directory that have the extension "bar" and donot search in the subdirecotries directories.
find . -name *.bar -maxdepth 2 -print

find all the files in the current directory that have the word "bash" in their name
find . -name "*bash*"

find all the files in the current directory that have the word "lib" in them
find . -wholename '/lib*'

find all the files in the current directory which are bigger than 1000MB
find . -size +1000M

find all the files in the current directory which have the inode number 31246 and remove them.
find . -inum 31246 -exec rm [] ';'

find all the files in the current directory which have the size 40 bytes in the current disk partition.
find . -size -40 -xdev -print

find all the files in the current directory which have been accessed in the last 1 day and move them to TMP folder.
find . -atime +1 -type f -exec mv {} TMP \;

find all the files in the current directory which have been modified after a file
find . -newer file

find all the files in the current directory which have been modified in the last 24 hours
find . -mtime 0

find all the files in the current directory which have been modified in the last 30 days and display the contents.
find . -atime +30 -exec ls \;

find all the files in the current directory which have been modified in the  last 6 days.
find . -atime +6

find all the files in the current directory which end with orig
find . -name '*.orig'  -exec echo {} \ ;

find all the files in the current directory which start with t and have been modified between one hour (60 minutes) and 12 hours (720 minutes) ago.
find . -mmin -720 -mmin +60 -type f -name "t*" -exec ls -l '{}' \;

find all the files in the current directory whose size is equal to exactly 126MB.
find . -size 126M

find all the files in the current directory with the name "wagoneer" which are in the current device.
find . -xdev -name "wagoneer*" -print

find all the files in the current folder (handles files which contain newlines or only spaces in their names)
find . -print0 | xargs -0 -l -i echo "{}";

find all the files in the current folder and create a backup of it in floppy
find . -depth -print | cpio -ov > /dev/fd0

find all the files in the current folder and display adding quotations to each file
find . -exec echo -n '"{}" ' \;

find all the files in the current folder and display them in the sorted order of their name
find . | sort

find all the files in the current folder and display those that are not present in the list "file.lst"
find . | grep -vf file.lst

find all the files in the current folder and search for the word "vps admin" in them.
find . -exec grep -i "vds admin" {} \;

find all the files in the current folder and save the output to the file dir-list
find -type d > dir-list

find all the files in the current folder ending with cpp or hpp or chpp and save the output to the file cscope.files.
find ./ -name "*.[ch]pp" -print > cscope.files

find all the files in the current folder that are modified after the modification date of a file
find . -newer document -print

find all the files in the current folder that have a single letter in their name which have been modified in the last 3 days but not today
find . -name \? -daystart -mtime +0 -mtime -3

find all the files in the current folder that have not been modified in the last 24*3 hours
find ./ -mtime +3

find all the files in the current folder that have been accessed in today
find -atime 0

find all the files in the current folder that have been accessed in today from the start of the day
find -daystart   -atime 0

find all the files in the current folder that have been modified exactly 24*3 hours ago
find ./ -mtime 3

find all the files in the current folder that have been modified in the last 24*3 hours
find ./ -mtime -3

find all the files in the current folder that have been modified in the last 7 days
find -mtime -7 -daystart

find all the files in the current folder that end with the word bar
find -name *bar

find all the files in the current folder which are bigger than 10MB and less than 50MB
find . -size +10M -size -50M -print

find all the files in the current folder which are bigger than 1MB
find . — size +1000k -print

find all the files in the current folder which are bigger than 9MB
find . -size +9M

find all the files in the current folder which are exactly 1234 bytes
find . -size 1234c

find all the files in the current folder which are readable
find . -readable

find all the files in the current folder which are modified after /bin/sh.
find . -newer /bin/sh

find all the files in the current folder which are smaller than 9MB
find . -size -9k

find all the files in the current folder which are writable
find . -writable

find all the files in the current folder which have a set uid set
find . -perm -4000 -print

find all the files in the current folder which have execute permission
find . -executable

find all the files in the current folder which have execute permission to all the users
find . -perm /u=x,g=x,o=x

find all the files in the current folder which have not been modified in the last 90 days and force delete them
find . -mtime +90 -type f -exec rm -f {} \;

find all the files in the current folder which have set guid bit on and list the top 10 files.
find . -perm /g+s | head

find all the files in the current folder which have the word cache in them and do not search in the sub directories of the folder.
find . -name 'cache*' -depth -exec rm {} \;

find all the files in the current folder which have been accessed in the last 24 hours
find . -type f -atime 1

find all the files in the current folder which have been changed in the last 60 minutes
find . -cmin -60

find all the files in the current folder which have been modified after a specific timestamp and save the output to a file
find -newer timestamp-file -type f > list-of-files

find all the files in the current folder which have been modified after the file disk.log
find . -newer disk.log -print

find all the files in the current folder which have been modified for the ffiles that are at least one week old (7 days) but less then 30 days old
find . -mtime +30 -a -mtime -7 -print0

find all the files in the current folder which have been modified in the 10 minutes ago
find -mmin +15 -mmin -25

find all the files in the current folder which have been modified in the last 60 minutes
find . -mmin -60

find all the files in the current folder which have been modified in the last 60 minutes, which are atleast 1 level deep and display a long listing of these files
find . -mindepth 1 -mmin -60 | xargs -r ls -ld

find all the files in the current folder which have been modified in the last one day
find . -daystart -mtime -1 -ls

find all the files in the current folder which have been modified in the last one minute
find . -type f -mmin 0

find all the files in the current folder which belong to the user root.
find . -user root -perm -4000 -print

find all the files in the current folder which end with "ext1" or "ext2" or "ext3"
find -E . -regex ".*ext1|.*ext2|.*ext3"

find all the files in the current folder which end with .o or with the name a.out and display them.
find . ( -name a.out -o -name *.o ) -print

find all the files in the current folder which do not have the read permission
find . -type f ! -perm -444

find all the files in the current folder which do not belong to any user
find . -nouser -ls

find all the files in the current folder which which have been modified yesterday and day before yesterday and whose name is of length 1
find . -name \? -daystart -mtime +0 -mtime -3

find all the files in the current folder whose name starts with 2 alphabets and ends with 2 digits.
find . — name "[a‑z][a‑z][0—9][0—9].txt" — print

find all the files in the directory which is pointed by $1 variable ending with the name held in the variable $2 or having the extension of value saved in the argument $2.
find $1 \( -name "*$2" -o -name ".*$2" \) -print

find all the files in the entire file system excluding the folder proc, which do not belong to any user or any group
find / -path /proc -prune -o -nouser -o -nogroup

find all the files in the entire file system starting with the word top
find / -name 'top?????*'

find all the files in the entire file system that have been accessed exactly  50 days ago
find / -atime 50

find all the files in the entire file system that have been accessed in the last 60 days ago
find / -amin -60

find all the files in the entire file system that have been changed exactly  60 days  and display ten files
find / -cmin -60 | head

find all the files in the entire file system that have been modified between 50 to 100 days and display ten files
find / -mtime +50 -mtime -100 | head

find all the files in the entire file system that have been modified exactly  50 days ago
find / -mtime 50

find all the files in the entire file system that have been modified exactly 7 days before which end with "conf"
find / -name "*conf" -mtime 7

find all the files in the entire file system that were modified in the last 10 minutes
find / -mmin -10

find all the files in the entire file system that start with top
find / -name 'top*'

find all the files in the entire file system that start with the word top and have 3 letters next to it.
find / -name 'top???'

find all the files in the entire file system which have been modified in the last 120 hours
find / -mtime -5 -print

find all the files in the entire file system which belong to the group "staff"
find / -group staff -print

find all the files in the entire file system which belong to the user "roger"
find / -user roger -print

find all the files  in the entire file system which belong to the user with the uid 1005 and discard all the errors
find / -uid 1005 2>/dev/null

find all the files in the entire file system whose size is exactly 15MB
find / -size 15M

find all the files in the entire file system whose size is greater than 20MB
find / -type f -size +20000k

find all the files in the entire filesystem which belong to the group root and display the ten files.
find / -group root | head

find all the files in the entire filesystem which belong to the user root and display the ten files.
find / -user root | head

find all the files in the file system which are bigger than 3 bytes
find / -size +3 -print

find all the files in the file system which have read permission to the user and display the ten files
find / -perm /u=r | head

find all the files in the file system which have sticky bit enabled to the user
find / -perm -u+s

find all the files in the file system which have been accessed in the last 1 day
find / -atime -1

find all the files in the file system which have been changed 1 minute ago.
find / -newerct '1	minute ago' -print

find all the files in the file system which have been changed in the last 24 hours.
find / -ctime -1

find all the files in the file system whcih have been modified in the last 1 day
find / -mtime -1

find all the files in the file system which have been modified in the last 10 minutes
find / -mmin -10

find all the files in the file system which have been modified in the last 30*24 hours
find / -mtime -30 -print

find all the files in the file system which belong to the groep "users" and with the name "dateiname"
find / -group users -iname "Dateiname"

find all the files in the file system which belong to the user "pat" and with the name "dateiname"
find / -user pat -iname "Dateiname"

find all the files in the file system which hae set uid enabled and save them to /root/suid.txt and those which have size greater than 100MB save them to /root/big.txt
find /    \( -perm -4000 -fprintf /root/suid.txt '%#m %u %p\n' \) , ( -size +100M -fprintf /root/big.txt '%-10s %p\n' \)

find all the files in the folder "/mp3-collection" which are bigger than 10MB excluding those that start with the word Metallica
find /mp3-collection -size +10000k ! -name "Metallica*"

find all the files in the folder "/u/bill" which have been accessed in the last 2-6 minutes
find /u/bill -amin +2 -amin -6

find all the files in the folder "myfiles" which have not been accessed in the last 30 days
find /myfiles -atime +30

find all the files in the folder "myfiles" which have been modified exactly 48 hours back.
find /myfiles -mtime 2

find all the files in the folder ./machbook and change the owner of them to the user with id "184"
find ./machbook -exec chown 184 {} \;

find all the files in the folder .home/calvin which have been modified in th last 45 minutes
find /home/calvin/ -mmin -45

find all the files in the folder /home which are bigger than 10MB and smaller than 50 MB
find /home -size +10M -size -50M

find all the files in the folder /opt which have been accessed exactly 20 days ago
find /opt -atime 20

find all the files  in the folder /opt which have been changed in the last 120 minutes
find /opt -cmin -120

find all the files in the folder /opt which have been modified between 20 to 50 days ago
find /opt -mtime +30 -mtime -50

find all the files in the folder /opt which have been modified exactly 20 days ago
find /opt -mtime 20

find all the files in the folder /path/to/dir which have been modified after a specific date (Feb 07)
find /path/to/dir -newermt “Feb 07”

find all the files in the folder /work which belong to the user "olivier"
find /work -user olivier -print

find all the files in the folder Musica and display them in a single line null separated
find Música/* | egrep -Z \/\\. | xargs -0 echo

find all the files in the present directory which have the group staff and check if is a symbolic link and display it.
find `pwd` -group staff -exec find {} -type l -print ;

find all the files in the root folder which have been modified in the last 24 hours and print them
find / -mtime -1 -print

find all the files under '/usr/local' directory tree which have been modified exactly 24 hours ago
find /usr/local -mtime 1

find all txt files under the current folder except ./directory folder
find -name "*.js" -not -path "./directory/*"

find all the files starting with "config" in the folder Symfony
find Symfony -name '*config*';

find all the files starting with "config" in the folder Symfony ( case insensitive search)
find Symfony -iname '*config*';

find all the files that are modified exactly one day ago
find -daystart -mtime 1

find all the files that are modified in the last 1 day
find  -mtime -1

find all the files that are modified in the last 1 day
find -mtime +0 -mtime -1

find all the files that are modified in the last 7 days
find -daystart -mtime -7

find all the files that have not been modified in the last 24 hours
find /tmp/test/* -mtime +1

find all the file that have not been modified in the last 3 days ( considers day starting not 24 hours )
find ./ -daystart -mtime +3

find all the files that have not been modified in the last (24*7) hours.
find . -mtime +7

find all the files that have the word "fstab" in their name in a folder
find /etc -name *fstab*

find all the files that have been changed exactly 24 hours ago
find . -ctime 1 -type f

find all the files that have been changed today
find . -ctime 0 -type f

find all the files that have been modified exactly 1 day ago
find -mtime 1

find all the files that have been modified exactly 2 days ago
find -mtime 2

find all the files that have been modified exactly 24 hours ago
find . -type f -mtime 1

find all the file that have been modified exactly 3 days ago ( considers day starting not 24 hours )
find ./ -daystart -mtime -3

find all the files that have been modified exactly yesterday (from 00:00 to 23:59 yesterday)
find . -type f -daystart -mtime 1

find all the files that have been modified in the last 1 day
find . -type f -daystart -mtime -1

find all the files that have been modified in the last 1 day ago
find -mtime -1

find all the files that have been modified in the last 12 hours
find ./ -mtime -0.5

find all the files that have been modified in the last 2 days
find . -type f -daystart -mtime -2

find all the files that have been modified in the last 2 day
find -daystart -mitime -1

find all the files that have been modified in the last 24 hours
find . -type f -mtime -1

find all the file that have been modified in the last 3 days ( considers day starting not 24 hours )
find ./ -daystart -mtime -3

find all the files that have been modified in the last 4 days ( daystart is used to check files according to date i.e, all files modified from currentDay-4 00:00:00 to current day) and copy them to folder.
find . -mtime 4 -daystart -exec cp -a {} /home/devnet/fileshare\$ on\ X.X.X.X/RECOVER/ \;

find all the files that have been modified in the last 60 minutes
find -mmin -60

find all the files that have been modified in the last 7 days,
find . -mtime -7 -print

find all the files that have been modified on a specific day and copy them to another directory
find . -type f -daystart -mtime $date_dif -exec copy_it.sh $verbose -s {} -t $to_dir \;

find all the files that have been modified since the last time we checked
find /etc -newer /var/log/backup.timestamp -print

find all the files that have been modified today
find . -type f -mtime 0

find all the files that have been modified today
find /tmp/test/* -mtime +0

find all the files that have been modified today(from the strart of the day)
find . -type f -daystart -mtime 0

find all the files (under root file system /) that were changed within the last 24 hours
find / -ctime -1

find all the files that were modified two days ago
find . -daystart -ctime 1 -type f

find all the files that were modified yesterday in the current directory.
find . -daystart -ctime 0 -type f

find all the files (under root file system /) that were updated in the last 24 hours
find / -mtime -1

find all the files which have size 0 bytes in temp folder
find /tmp -type f -empty

find all the files which have the write permission to the group and remove the write permission.
find . -perm -20 -exec chmod g-w {} ;

find all the files which have been accessed after modifying the file /etc/hosts
find -anewer /etc/hosts

find all the files which have been changed after the modification of a file.
find -cnewer /etc/fstab

find all the files which have been modified in the last 15 minutes excluding hidden files.
find . -mmin -15 \( ! -regex ".*/\..*" \)

find all the files which end with ".deb" and display their base name (strip the extension)
find . -name '*.deb' -exec basename {} \;

find all the files which end with ".deb" and display their base name (strip the extension)
find . -name '*.deb' | xargs -n1 basename

find all the files which start with the name "Metallica" in the folder "/mp3-collection" and which are bigger than 10MB
find /mp3-collection -name 'Metallica*' -and -size +10000k

find all the files with the name "datainame" in the file system which are bigger than 50MB
find / -size +50M -iname "Dateiname"

find all the files with the name test in the current folder ( case insensitive )
find . -iname test

find all the files with the name september ( case insensitive )
find -iname september

Find all the files/directories in the current directory tree which have been modified between 2014-08-25 and 2014-08-26
find ./ -newermt 2014-08-25 ! -newermt 2014-08-26 -print

Find all the files/directories in the entire filesystem that do not belong to user 'wnj' and are not newer than the file/directory 'ttt' by modification time
find / \! \( -newer ttt -user wnj \) -print

Find all the files/directories under '/usr/local' directory tree which have been modified within the last day
find /usr/local -mtime -1

Find all the files/directories under '/var/adm' directory tree that have not been modified in the last 3 days
find /var/adm -mtime +3 -print

Find all the files/directories under user's home directory that do not belong to the user $USER
find ~ ! -user ${USER}

Find all the files/directories with '.conf' extension under '/etc' directory non-recursively and display the last ten files
find /etc -maxdepth 1 -name "*.conf" | tail

Find all the files called FindCommandExamples.txt of owner root
find / -user root -name FindCommandExamples.txt

Find all the files in entire file system  which are accessed 50 days back
find / -atime 50

Find all the files in entire file system which are greater than 50MB and less than 100MB.
find / -size +50M -size -100M

Find all the files in entire file system  which are modified 50 days back.
find / -mtime 50

Find all the files in entire file system  which are modified more than 50 days back and less than 100 days and show a few lines of output from the beginning
find / -mtime +50 -mtime -100 | head

Find all the files in entire file system with the extensions txt or doc, as well as any file larger than 5MB in size
find / \( -name '*.txt' -o -name '*.doc' -o -size +5M \)

Find all the files in file system which are accessed 50 days back
find / -atime 50

Find all the files in file system which are changed in last 1 hour
find / -cmin -60

Find all the files in file system which are modified 50 days back
find / -mtime 50

Find all the files in file system which are modified in last 1 hour
find / -mmin -60

Find all the files in file system which are modified more than 50 days back and less than 100 days
find / -mtime +50 –mtime -100

Find all the files in the current directory
find * -type f -print -o -type d -prune

Find all the files in the current directory recursively whose permissions are 644 and show the first 10 of them
find . -perm 0644 | head

Find all the files in the current directory recursively whose permissions are 777
find . -type f -perm 0777 -print

Find all the files in the current directory recursively whose permissions are not 777
find . -type f ! -perm 777 | head

Find all the files in the current directory with “linkin park” in their names
find . -maxdepth 1 -iname "*linkin park*"

Find all the files under /etc directory which are larger than 100k
find /etc -size +100k

Find all the files under /home directory with name tecmint.txt
find /home -name tecmint.txt

Find all the files under /tmp directory and show a few lines of output from the beginning
find /tmp  | head

Find all the files named 'vimrc' anywhere on the system
find / -name vimrc

Find all the files on the system that have been accessed within the last hour
find / -amin -60

Find all the files on the system that have been changed within the last hour
find / -cmin -60

Find all the files on the system that have been modified within the last hour
find / -mmin -60

Find all the files recursively in directories or files taken from the glob pattern /tmp/test/* that have been modified today
find /tmp/test/* -mtime -0

Find all the files that are not named "MyCProgram.c" in the current directory only and without regards to case.
find -maxdepth 1 -not -iname "MyCProgram.c"

Find all the files that were modified exactly one day ago
find . -mtime 1

Find all the files that were modified more than one day ago
find . -mtime +1

Find all the files that were modified within the last day
find . -mtime -1

Find all the files whose name is FindCommandExamples.txt and contains both capital and small letters in / directory
find  / -iname findcommandexamples.txt

Find all the files whose name is FindCommandExamples.txt in the current working directory
find /root -name FindCommandExamples.txt

Find all the files whose name is tecmint.txt
find . -name tecmint.txt

Find all the files whose name is tecmint.txt and contains both capital and small letters in /home directory
find /home -iname tecmint.txt

Find all the files whose name is tecmint.txt in the current directory
find . -name tecmint.txt

Find all the files whose permissions are 777
find . -type f -perm 0777 -print

Find all the files whose permissions are 777 in the current directory
find . -type f -perm 0777 -print

Find all the files whose permissions are 777 under current directory
find . -type f -perm 0777 -print

Find all the files which are accessed 50 days back
find / -atime 50

Find all the files which are accessed in last 1 hour
find / -amin -60

Find all the files which are changed in last 1 hour
find / -cmin -60

Find all the files which are greater than 50MB but less than 100MB in size
find / -size +50M -size -100M

Find all the files which are modified 50 days back
find / -mtime 50

Find all the files which are modified in last 1 hour
find / -mmin -60

Find all the files which are modified in last 1 hour in entire file system
find / -mmin -60

Find all the files which are modified more than 50 days back and less than 100 days
find / -mtime +50 –mtime -100

Find all the files which were accessed 50 days ago
find / -atime 50

Find all the files without permission 777
find / -type f ! -perm 777

Find all the files without permission 777 in the file system
find / -type f ! -perm 777

Find all the files without permission 777 under current directory and show a few lines of output from the beginning
find . -type f ! -perm 777 | head

find all the findme.txt files in the file system
find / -name findme.txt -type f -print

find all the non compressed files in the current directory and compress them.
find . \! -name "*.Z" -exec compress -f {} \;

find all the jar files in the current folder and display all the ".class" files or files ending with jar
find . -name “*.jar” -print -exec jar tvf {} \; |grep -E “jar$|.class”

find all the normal files in the home directory which have been accesed in the last 30 days with the size greater than or equal to 100k.
find $HOME -type f -atime +30 -size 100k

find all the header files in /usr/include which have been modified in the last 399 days and display the number of lines, number of files, number of characters of all these files
find usr/include -name '*.h' -mtime -399 | wc

find all the header files in /usr/include which have been modified in the last 400 days
find /usr/include -type f -mtime -400 -name "*.h"

finda all the hidden files excluding those having the extension htaccess
find . -type f \( -iname ".*" ! -iname ".htaccess" \)

find all the hidden files in the temp folder
find /tmp -type f -name ".*"

find all the html files in current folder and replace old string with new string
find . -name '*.html' -print0 | xargs -0 perl -pi -e 's/oldstring/newstring/g'

find all the html files in current folder and replace old string with new string
perl -p -i -e 's/oldstring/newstring/g' `find ./ -name *.html`

find all the html files in current folder and replace some pattern in all these files
find -type f -name '*.htm' -printf '%P\0%f\0' | xargs -0 -n2 sh -c 'fil="${2/\.htm/}"; sed -i -e "s;<title>.*</title>;<title>$fil</title>;" $1' replace

find all the html files in the current folder and rename them to .var files
find -name '*.html' -print0 | xargs -0 rename 's/\.html$/.var/'

find all the html files in the current folder which have been modified excatly 7 days before
find . -mtime 7 -name "*.html" -print

find all the html files which are modified in the last 7 days
find . -mtime -7 -name "*.html"

find all the html, javascript and text files in the current folder
find . -type f -name "*.htm*" -o -name "*.js*" -o -name "*.txt"

find all the undo files in the current folder and display the toal lines, words, characters
find ./ -name *.undo | xargs wc

find all the instances of the file "foo.txt" in the current folder and move them to another folder
find . -name foo.txt 1> tmpfile && mv `cat tmpfile` path/to/some/dir && rm tmpfile

find all the javascript files in current folder using regular expressions
find . -regex '.+\.js'

find all the jpg files in a directory.
find /home -name '*.jpg

find all the jpg files in current folder and sort them
find . -type f|grep -i "\.jpg$" |sort

find all the jpg files in the current folder and resize them to 50% of their original size
find . -name "*.JPG" -exec convert {} -resize 50% {} \;

find all the jpg files in the directory /ftp/dir which are bigger than 500KB
find /ftp/dir/ -size +500k -iname "*.jpg"

find all the jpg files in the entire file system and discard all the errors.
find / -name *.jpg 2>/dev/null

find all the jpg images in the folder /path/to/files and convert them into pdf.
find /path/to/files -iname '*.jpg' -exec mogrify -format pdf {} +

find all the links in somedirectory and print them in a single line (to avoid the problem of files having newline in their names)
find "somedir" -type l -print0

find all the links in the current folder and following it to the pointed path
find -L /target -type l

find all the links in the current folder which are broken
find /target -type l -xtype l

find all the links in the directory students and print them. Do not display any errors.
find /students -type l -print 2> /dev/null

find all the links in the root folder which point to nothing ( links with their original file deleted ) and display them.
find / -type l -print | perl -nle '-e || print';

Finds all the log* files recursively in /myDir that are more than 7 days older and compresses them.
find /myDir -name "log*" -ctime +7 -exec bzip2 -zv {} \;

find all the zip files in the current folder
find . -type f -name '*.zip'

find all the zip files in the current folder and create a tar ball of these zip files
find . -type f -name '*.zip' -print0 | xargs -0 tar -xzf

find all the mp3 files in the current folder and move them to another folder
find . -name "*.mp3" -exec mv {} "/Users/sir/Music//iTunes/iTunes Media/Automatically Add to iTunes.localized/" \;

find all the mp3 files in the entire file system whose size is bigger than 10MB
find / -type f -name *.mp3 -size +10M -exec rm {} \;

find all the mp3 files in the file system
find / -iname "*.mp3" -print

find all the mp4 video files in the current folder and save the output to the file /tmp/$$
find . -name ‘*.mp4’ >> /tmp/$$

find all the ogg files in the current directory which have the word "monfichier" in their name
find -name *monfichier*.ogg

find all the pdf files in a folder which start with a specific name and display them in the sorted order of their time stamps
find "/path/to/pdfs/" -type f -name "$1*.pdf" -exec stat -f "%10Dm %SN" {}\;  | sort -k1,1n -k2,2

find all the pdf files in current folder and create a tar ball of all these files
find . -iname "*.pdf" -exec tar --append --file=somefile.tar {} \;

find all the php files in current folder and search for multiple patterns in these files
find -name '*.php' -exec grep -li "fincken" {} + | xargs grep -l "TODO"

find all the php files in current folder and search for multiple patterns in these files and display the file names
find -name '*.php' -exec grep -in "fincken" {} + | grep TODO | cut -d: -f1 | uniq

find all the php files in current folder using regular expressions
find . -regex '.+\.php'

find all the php files in the current folder
find . -name \*.php

find all the php files in the current folder
find . -name “*.[php|PHP]” -print

find all the php files in the current folder (discards any directory which has an extension of ".php")
find . -name \*.php -type f

find all the png files in the current folder which are present in the pattern list search .txt
find . -name '*.png' | grep -f search.txt

find all the png files in the current folder which begin with the word image
find . -name "image*.png"

find all the png files in the current folder which begin with the word image and do not search in the sub directories
find . -maxdepth 1 -type f -name 'image*png' `

find all the php/javascript files in current folder using regular expressions
find . -regex '.+\.\(php|js\)'

find all the fles that have .ssh in the end and redirect the output to ssh-stuff
find / -name .ssh* -print | tee -a ssh-stuff

find all the python files in the current folder and save the list to the file output.txt
find . -name "*.py" -type f > output.txt

find all the reguar/normal php files in current directory.
find . -type f -name "*.php"

find all the regular/normal files ending with ".mod" in a folder and pass them as input to remodup command
find $DIR -name "*.mod" -type f -exec bash -c 'remodup "$1"' - {} \;

find all the regular/normal files ending with ".mod" in a folder and send them as input to the remodup command
find $DIR -name "*.mod" -type f -exec remodup {} \;

find all the normal/regular files in /etc/sysconfig which have been accesses in the last 30 minutes
find /etc/sysconfig -amin -30 -type f

find all the regular/normal files in a folder and assign the output to a variable
files2 = "`find "'"$dirs"'" -type f`"

find all the regular files in a folder which do not start with the word find and assign the output to a variable
files = "`find "'"$dirs"'" -type f |& grep -v '^find: '`"

find all the regular/normal files in all the directories in the /some/dir and delete them
find /some/dir -type d -exec find {} -type f -delete \;

find all the normal/regular files in current directory and display file names with new line as delimiter
find . -type f -exec printf '%.0sbla\n' {} +

find all the normal/regular files in current folder and delete all the files which are not present in /some/dir
find . -type f -print0 | grep -Fxvz -f <(cd "/some/dir" && find . -type f) | xargs -0 echo rm

find all the normal/regular files in current folder and search for a pattern
find . -type f -print0 | xargs -0 grep pattern

find all the normal/regular files in current folder excluding sub directories and hidden folders and display the count
find . -type f -maxdepth 1 ! -name '.*' -exec printf '%.0s.\n' {} + | wc -l

find all the regular/normal files in the /path folder and delete them
find /path -type f -delete

find all the regular/normal files in the /path folder and delete them
find /path -type f -exec rm '{}' \;

find all the regular/normal files in the /path folder and delete them
find /path -type f -print0 | xargs -0 rm

find all the normal/regular files in the current directory
find -type f

find all the normal/regular files in the current directory and search for the word mail and display the file names
find . -type f -exec grep -il mail

find all the regular/normal files in the current directory and print them skip searching all the directories in the current folders.
find * -type f -print -o -type d -prune

find all the regular/normal files in the current direcoty which have not been accessed in the last 30 days.
find . -type f -atime +30 -print

find all the normal/regular files in the current directory which have been modified in the last 24 hours
find . -mtime -1 -type f -print

find all the regular files in the current directory which do not have a read permission
find -type f ! -perm -444

find all the regular/normal files in the current directory which do not have the extension comment and and redirect the output to /tmp/list
find . -type f \! -name "*.Z" \! -name ".comment" -print | tee -a /tmp/list

find all the regular/normal files in the current folder and do not search in the sub directories
find . -maxdepth 1 -type f

find all the regular/normal files in the current folder and rename them to html files
find main-directory -type f -exec mv -v '{}' '{}'.html \;

find all the normal/regular files in the current folder which are present in the pattern file "file_list.txt"
find . type f -print | fgrep -f file_list.txt

find all the normal/regualar files in the current folder which have a size of 10KB and display a long listing details of them.
find . -type f -size +10000 -exec ls -al {} \;

find all the regular files in the current folder which have specific word in their name and force delete all these files and save the log to the file log_del.txt
find ./ -type f -name '*.c*' -print0 | xargs -0 rm -rf &>> log_del.txt

find all the regular files in the current folder which have specific word in their name and force delete all these files and save the log to the file log_del.txt
find ./ -type f -name '*.r*' -print0 | xargs -0 rm -rf &> log_del.txt

find all the regular/normal files in the current folder which have been accessed in the last 1440*24 hours and not modified in 1441*24 hours excluding those which are in the custom sub directory tree
ionice -c 3 find  . -type f -amin -1440 -mmin +1441 -not -path custom/ -print0

find all the normal/regular files in the current folder which have been modified in the last 24 hours and display a long listing of them
find . -type f -mtime -1 -exec ls -l {} \;

find all the normal/regular files in the current folder which have been modified in the last day and display a long listing of them
find . -type f -mtime -1 -daystart -exec ls -l {} \;

find all the normal/regular files in the current folder which have been modified two days ago and display a long listing of them
find . -type f -mtime 2 -mtime -3 -daystart -exec ls -l {} \;

find all the regular/normal files in the current folder which belong to the group "flossblog"
find . -group flossblog -type f

find all the regular/normal files in the current folder which belong to the user "sedlav"
find . -user sedlav -type f

find all the regular/normal files in the current folder which belong to the users with the user id's between 500 and 1000
find . -uid +500 -uid -1000 -type f

find all the regular/normal files in the folder "myfiles" which have the permission 647.
find /myfiles -type f -perm -647

find all the normal/regular files in the folder "pathfolder" excluding all hidden files and display the count
find pathfolder -maxdepth 1 -type f -not -path '*/\.*' | wc -l

find all the normal/regular files in the folder "pathfolder" which are 2 levels deep, excluding all hidden files and display the count
find pathfolder -mindepth 2 -maxdepth 2 -type f -not -path '*/\.*' | wc -l

find all the regular/normal files in the folder /travelphotos which are bigger than 200KB and which do not have the word "2015" in their name
find /travelphotos -type f -size +200k -not -iname "*2015*"

find all the normal/regular files in the folder main-directory
find main-directory -type f

find all the reglar files which ahve been changed in the last 5 minutes and do not search in the sub directories.
find /home/pankaj -maxdepth 1 -cmin -5 -type f

Find all the regular files in $DIR directory tree which have not been modified in the last 15 days and delete them
find "$DIR" -type f -mtime +15 -exec rm {} \;

Find all the regular files in $DIR directory tree which have not been modified in the last 450 days and delete them
find $DIR -type f -mtime +450 -exec rm {} \;

Find all the regular files under $DIR directory tree which have been modified before the file $a excluding the file $a and delete them
find "$DIR" -type f \! -newer "$a" \! -samefile "$a" -delete

Find all the regular files under $DIR directory tree which have been modified before the file $a excluding the file $a and delete them
find "$DIR" -type f \! -newer "$a" \! -samefile "$a" -exec rm {} +

Find all the regular files under '/your/dir' directory tree which are bigger than 5 MB and display them in decreasing order of their sizes
find /your/dir -type f -size +5M -exec du -h '{}' + | sort -hr

Find all the regular files under directory 'dir1' that are at least N levels deep
find dir1 -mindepth N -type f

find all the xml files in a directory and pass it as an argument to a jar
find /dump -type f -name '*.xml' -exec java -jar ProcessFile.jar {} \;

find all the xml files in a directory and pass it as an argument to a jar (parallel is used to achieve parallel processing)
find /dump -type f -name '*.xml' | parallel -j8 java -jar ProcessFile.jar {}

find all the xml files in the current folder which are present in the pattern text file
find . -name "*.xml" -exec grep -HFf <(find . -name "*.txt" -printf "%f\n") {} \;

Find all the SGID bit files whose permissions set to 644
find / -perm 2644

Find all the SGID bit files whose permissions set to 644 in the file system
find / -perm 2644

find all the perl files in /var/www
find /var/www/ -type f -name "*.pl" -print

find all the perl files in /var/www ( case insensitive search )
find /var/www/ -type f -iname "*.pl" -print

find all the perl files in the current folder
find . -type f -name "*.pl"

find all the perl files in the current folder and search for a pattern
find . -name '*.pl' | xargs grep -L '^use strict'

find all the perl files in the current folder, print0 is used to handle files with new lines in their names or only spaces
find . -type f -name "*.pl" -print0

find all the shell scripts or perl files in the current directory
find . -type f \( -name "*.sh" -o -name "*.pl" \)

find all the swap files (files ending with ~) in the current folder and delete them
find . -name "*~" -delete

find all the swap files (files ending with ~) in the current folder and delete them
find . -name "*~" -exec rm {} \;

Find all the Sticky Bit files whose permission are 551
find / -perm 0551

Find all the Sticky Bit set files in entire file system whose permission are 551
find / -perm 0551

Find all the Sticky Bit set files whose permission are 551 in the file system
find / -perm 1551

find all the symbolic links in the current folder
find /etc -type l -print

find all the symbolic links in the current folder and follow to the original file
find -L . -type l

find all the symbolic links in the current folder and follow to the pointing file
find -L

find all the video files in the home folder
find ~ -type f -exec file -i {} + | grep video

find all the video files in the folder /home/<user>
find /home/<user> -type f -exec file {} + | grep -E "MPEG v4|EBML|Microsoft ASF|Macromedia Flash Video|WebM|Apple QuickTime movie|AVI"

find all the word press configuration php files in the folder /var/www
find /var/www/ -name wp-config.php

find all the word press configuration php files in the folder /var/www and do not search beyond two levels
find /var/www/ -name wp-config.php -maxdepth 2

Find all thumb.png files in the temps/ directory tree
find temps/ -name "thumb.png"

find all  tools generated files  a.out , *.o and core dump files which not required to us these all junk files & delete from  current  directory .
find . \( -name a.out -o -name '*.' -o -name  'core' \) -exec rm {} \;

Find all top-level files in the current folder but ones with name like '*Music*' to the 'dest/' folder.
find . -maxdepth 1 -name '*Music*' -prune -o -print0 | xargs -0 -i cp {} dest/

Find all TXT files on the system and copy them to /tmp/txt
find / -iname '*.txt' | xargs --replace=@ cp @ /tmp/txt

Find all TXT files that belong to user root
find / -user root -iname "*.txt"

Find all user files larger than 5MB
find / -size  +5000000c 2> /dev/null

Finds all users logged in via ssh.
w | grep ssh

find all raw images in the current folder and pass them one at a time to the xargs command and enable parallel processing of the files
find . -type f -iname '*.CR2' -print0 | xargs -0 -n 1 -P 8 -I {}

Find all xx* files/directories excluding 'xxx' files/directories under your home directory
find ~ -name 'xx*' -and -not -name 'xxx'

find al the files that are modified exactly 2 days ago
find -daystart -mtime 2

find al the files which have been accesed in the last 6 days and display their details
find . -atime +6 -exec ll | more

find al the tmp directories in the current directory and create a dump of it
find . -type d -name tmp -prune -o -print | cpio -dump /backup

Send an audible ping to "10.100.3.104"
ping -a 10.100.3.104

Find apparent size of a target directory
du -hs /path/to/directory

Send at most 3 ping requests to "8.8.8.8" with a timeout of 3 seconds on interface "eth9"
ping 8.8.8.8 -I eth9 -c 3 -w 3

Finds binaries names in a list of running processes and prints containing folder of each binary.
ps aux | awk '{print $11}' | grep -x -e "/.*" | xargs -I file dirname "file"

Finds binaries names in a list of running processes and prints containing folder of each binary.
ps aux | awk '{print $11}' | grep -x -e "/.*" | xargs dirname

Finds binaries names in a list of running processes and prints containing folder of first 10 binaries.
ps aux | awk '{print $11}' | grep -x -e "/.*" | xargs dirname | head

Find blabla* files under current directory
find . -depth -name "blabla*" -type f | xargs rm -f

Find things changed today
find /path/to/search -daystart -ctime -1

Finds strings having text "searched-string" in all files recursively in a current folder.
find . | xargs grep "searched-string"

Finds strings like "texthere" recursively in all files of a current folder regarding all symlinks.
grep -R "texthere" *

Find strings with 'Features' in /var/run/dmesg.boot' file
cat /var/run/dmesg.boot | grep Features

Finds strings with 'TEXT' from *.log files and prints all but first field from any space-delimited string.
grep -e TEXT *.log | cut -d' ' --complement -s -f1

Finds strings with dot-separated sequence of numbers, and prints part of that sequence before the first dot.
echo "$f" | grep -Eo '[0-9]+[.]+[0-9]+[.]?[0-9]?' | cut -d. -f1

Finds strings with text "searched-string" recursively in all files of current folder.
grep -r "searched-string" .

Finds strings with text "searched-string" recursively in all files of current folder and prints names of files with matched strings.
grep -r -l "foo" .

Finds strings with text "text" in all files named "string to be searched" recursively in a current folder.
find . -name "string to be searched" -exec grep "text" "{}" \;

Find broken links
find / -type l -print0 | xargs -0 file | grep broken

Find broken symlinks in current directory
find -L -type l

Find broken symlinks in current directory
find . -type l -xtype l

Find broken symlinks in the current directory tree
find -type l | while read f; do if [ ! -e "$f" ]; then ls -l "$f"; fi; done

find C, C++ source and header files in current folder and create etags for them
find . -type f ( -iname '.cpp' -o -iname '.hpp' -o -iname '.c' -o -iname '.h' -o -iname '.cc' -o -iname '.hh' ) -print | xargs etags -a

find case-insentive example.com file, and whole dose not contain beta
find -iname example.com | grep -v beta

find case-insentive example.com file, omit ./beta path
find ./ -path ./beta/* -prune -o -iname example.com -print

This find command ignore the case when searching for file name , to ignore the case  in this example all .py & .PY file will search
find . -type f -iname "*.py"

this find command Substitute space with underscore in the file name replaces space in all the *.mp3 files with _
find . -type f -iname '*.mp3' -exec rename '/ /_/'  {} \;

Send command to named screen session with special characters
screen -x $PROCESS -p 0 -X stuff `printf "stop\r"`

Find command will display top 5 small files from curent directory . most probably you will get ZERO  bytes files .
find . -type f -exec ls -s {} \; sort -n |head -5

Find command will list of all files & directories from current directory , before listing echo command will display ' List of files & Directory '
find . -exec echo ' List of files & Direcoty'   {} \;

Send contents of "input.txt.gz" to "command" on stdin
zcat input.txt.gz | command -

Send content to screen session windows with a certain title
screen -S SessionName -X at ".#" stuff "date "

Find movies over a gigabyte in size
find ~/Movies/ -size +1024M

find CSS files, omitting results containing "CVS"
find . \! -path "*CVS*" -type f -name "*.css"

Find CSS files omitting results containing "CVS"
find . \! -path "*CVS*" -type f -name "*.css"

find from / a file called "expect", suppressing any error messages
find / -name expect 2>/dev/null

find from / a file called 'toBeSearched.file', redirecting error messages to the output and filtering any lines containing the text "Permission denied"
find /. -name 'toBeSearched.file' 2>&1 | grep -v 'Permission denied'

find from / a file called 'toBeSearched.file', suppressing any error messages
find /. -name 'toBeSearched.file' 2>/dev/null

Find disk usage of all files inside the directory
du -a

Find disk used space of only the target directory
du --max-depth=0 ./directory

Find directory "/some/dir" if it is empty
find /some/dir/ -maxdepth 0 -empty

Find directory "your/dir" if it is empty
find your/dir -prune -empty

Find directory "your/dir" if it is empty
find your/dir -prune -empty -type d

Find directories and regular files containing `blah' in their names modified less than 2 days ago, case insensitive
find . -iname '*blah*' \( -type d -o -type f \) -mtime -2

find dirctory files which modification time is  7 days ago
find . -mtime -7 -type d

Find directories in /home/vmail that match pathname "*/*/Maildir/.LearnAsHam/new", and move them to folder .Inbox/new
find /home/vmail/ -type d -path "*/*/Maildir/.LearnAsHam/new" -exec sh -c '(cd {} && mv ./* ../../.Inbox/new)' ';'

Find directories in /home/vmail that match pathname "*/*/Maildir/.LearnAsSpam/cur", and move them to folder .Junk/cur
find /home/vmail/ -type d -path "*/*/Maildir/.LearnAsSpam/cur" -exec sh -c '(cd {} && mv ./* ../../.Junk/cur)' ';'

Find directories in /home/vmail that match pathname "*/*/Maildir/.LearnAsSpam/new", and move them to folder .Junk/new
find /home/vmail/ -type d -path "*/*/Maildir/.LearnAsSpam/new" -exec sh -c '(cd {} && mv ./* ../../.Junk/new)' ';'

Find directories in the current directory (no sub-directories) and print them appended with a string literal 'Directory: '
find . -maxdepth 1 -type d -print | xargs  -I "^" echo Directory: "^"

Find directories in the current directory recursively that are not "executable" by all
find -type d ! -perm -111

Find directories in the current directory tree that were modified within the last 24 hours and move them to /path/to/target-dir
find . -depth -type d -mtime 0 -exec mv -t /path/to/target-dir {} +

Find directories in the current directory tree that were modified within the last 24 hours and move them to /path/to/target-dir
find . -type d -mtime -0 -exec mv -t /path/to/target-dir {} +

Find directories in the current directory tree that were modified within the last 24 hours and move them to /path/to/target-dir
find . -type d -mtime -0 -print0 | xargs -0 mv -t /path/to/target-dir

Find directories in the current directory tree that were modified within the last 24 hours and move them to /path/to/target-dir
find . -type d -mtime 0 -exec mv {} /path/to/target-dir \;

Find directories in the current directory tree whose names are 33 characters in length
find . -type d -name "?????????????????????????????????"

find directories in the folder /usr/spool/uucp
find /usr/spool/uucp -type d -print

Find directories under maximum 1 level down the directory $dir with 100 permission that are owned by the user $username
find $dir -maxdepth 1 -type d -user $username -perm -100

find directories under the $LOGDIR directory where there has been no modifications within the last 24 hours and compresses the files.
find $LOGDIR -type d -mtime +0 -exec compress -r {} \;

Find directories modified in last 7 days
find . -mtime -7 -type d

Find directories modified within the last 7 days
find . -mtime -7 -type d

Find directories named `build'
find . -type d -name build

Find directories named `doc' in /usr and below
find /usr -name doc -type d

Find directories named `doc' in /usr and below
find /usr \( -name doc -and -type d \)

Find directories named 'work' under '/usr/ports/' directory tree and remove them
find /usr/ports/ -name work -type d -print -exec rm -rf {} \;

Find directories owned by user news with permissions 775
find / -user news -type d -perm 775 -print

Find directories that are directly under $workspace_ts directory (no-subdirectories) and were modified less than 30 days ago
find $workspace_ts -mindepth 1 -maxdepth 1 -type d -mtime -30

Find directories that are directly under $workspace_ts directory (no-subdirectories) and were modified more than 30 days ago
find $workspace_ts -mindepth 1 -maxdepth 1 -type d -mtime +30 -print

Find directories that are directly under /home/user/workspace directory (no-subdirectories) and were modified more than 30 days ago and print a message saying that the directory wasn't modified during last 30 days
find /home/user/workspace -mindepth 1 -maxdepth 1 -type d -mtime +30 -execdir echo "It seems that {} wasn't modified during last 30 days" ';'

Find directories that are directly under /home/user/workspace directory (no-subdirectories) and were modified more than 30 days ago and print a message saying that the directory wasn't modified during last 30 days
find /home/user/workspace -mindepth 1 -maxdepth 1 -type d -mtime +30 -printf "\t- It seems that %p wasn't modified during last 30 day\n"

find directories  that have been modified in the last seven days
find . -mtime -7 -type d

Find directories that have "755" permissions and modify them to have "700" permissions
find . -type d -perm 755 -exec chmod 700 {} \;

find directory which case-insensitive name is foo in current directory.
find . -iname foo -type d

find  directory which case-insensitive name is too in currect directory
find . -iname foo -type d

find directory which name is Cookbook under /users/al
find /users/al -name Cookbook -type d

Find directories with permissions 777 and change them to 755 recursively
find /home -type d -perm 777 -print -exec chmod 755 {} \;

(GNU specific: top) Send e-mail to "your_email@domain.com" with subject "any subject" containing process statistics output by the GNU version of 'top'.
top -b -n 1 | mail -s "any subject" your_email@domain.com

Send email in "mail.tmp" from "noreply@hostname" with subject "Config done!"
cat mail.tmp | mail -r "noreply@$(hostname)" -s "Config done!" "${MAIL}"

Find empty files and directories
find . -empty

Find empty files/directories under test directory
find test -empty

Find empty files in the test directory
find test -empty

Find empty files under test directory
find test -empty

Find empty regular files in /dir and its subdirectories
find /dir -type f -size 0 -print

Send every 130 characters of "file" as input to "..."
fold -w130 file | ...

Finds every folder with file 'header.php' within, and copies file 'topscripts.php' to every one of them.
find -type f -name 'header.php' | xargs -n 1 dirname | xargs -n 1 cp -f topscripts.php

Find every JavaScript file in the wordpress directory
find wordpress -maxdepth 1 -name '*js'

Find every JavaScript file in the wordpress directory tree
find wordpress -name '*js'

Find every vim undo file under current directory
find -type f -iname '*.un~'

Find every file under the directory /home owned by the user joe.
find /home -user joe

Find every file under the directory /usr ending in ".stat".
find /usr -name *stat

Find every file under the directory /var/spool that was modified more than 60 days ago.
find /var/spool -mtime +60

Find every file/directory under /var/spool that was modified more than 60 days ago.
find /var/spool -mtime +60

Find executable files
find . -perm -100 -print

Find executable regular files in the current directory tree
find . -type f -exec test -x {} \; -print

Send text "spawn daemon" and a newline character to the screen session
screen -r user -X stuff "spawn daemon$(printf \\r)"

Find text files modified less than 5 days ago
find . –name "*.txt" –mtime 5

Find file1 in the level 1 directories and above
find -maxdepth 2 -name file1

find files changed in the last 1 day
find . -mtime -1 -type f

find files ending with .jpg
find . -name '*.jpg' -print ./bar/foo.jpg

find files in $HOME ending in "txt" or "html" and case insensitive search for the word "vpn"
find $HOME \( -name \*txt -o -name \*html \) -print0 | xargs -0 grep -li vpn

find files in /dir/path/look/up directory that names are dir-name-here
find /dir/path/look/up -name "dir-name-here"

find files in /dir/path/look/up directory that names are dir-name-here
find /dir/path/look/up -name "dir-name-here" -print

find files in /tmp directory that named are core and deletes them, single or double quotes, spaces or newlines are correctly handled
find /tmp -name core -type f -print0 | xargs -0 /bin/rm -f

find files in /u/bill directory which are access an 2 to 6 minutes ago
find /u/bill -amin +2 -amin -6

find files in /usr directory which are modified after February 1 of the current year
find /usr -newermt "Feb 1"

find files in a directory and exit the command if the syntax is correct or display invalid command if the syntax is wrong.
find … -exec sh -c 'trap "echo \$?" EXIT; invalid_command "$0"' {} \;

find files in home directory that accessed more than 100 days ago
find ~ -atime 100

find files in home directory which are modified yesterday
find ~/ -daystart -type f -mtime 1

find files in current directory that names are game
find . -name game

find files in current folder ending with ".c" or ".h" or ".ch" and search for a word in these files and enable color highlighting of the matched text
find . -name "*.[ch]" -exec grep --color -aHn "e" {} \;

find files in root directory that names are game
find / -name game

find files in the /usr/src directory with pattern` *.c  that larger than 100 Kilobytes
find /usr/src -name '*.c' -size +100k -print

find files in the home folder which have been modified in the last day. ( -daystart measures times from the beginning of today rather than from 24 hours ago.)
find ~/ -daystart -type f -mtime 1

find files in the current directory and sub-directories, that changed within last hour
find . -cmin -60

find files in the current directory and sub-directories, that were accessed within last hour
find -amin -60

find files in the current directory having name "filename"
find -iname "filename"

find files in the current directory with pattern` '*.[ch]' which are contain ‘thing’ string and print file names
find . -name '*.[ch]' | xargs grep -l thing

find files in the current directory with pattern` '*.[ch]' which are contain ‘thing’ string and print file names which can contain spaces
find . -name '*.[ch]' -print0 | xargs -r -0 grep -l thing

find files in the users home directory and for each one, ask the user to confirm to delete the file.
find $HOME/. -name *.txt -ok rm {} \;

find files under the current directory called "foo" or "bar"
find . \( -name "foo" -o -name "bar" \)

find files under the current directory ending in "txt" and list them, or ending in  "html" but do nothing.
find . -name '*.txt' -print -o -name '*.html'

find file named foo.txt under current directory.
find . -name foo.txt

find file named foo.txt under root / directory.
find / -name foo.txt

find files (under root file system /) that were accessed within the last 24 hours
find / -atime -1

find files which have all permissions to all the users in the current directory
find . -type f -perm 0777 -print

find file which case-insensitive name is foo in current directory.
find . -iname foo

find  file which case-insensitive name is too in currect directory
find . -iname foo

find files which full path name is /tmp/foo/bar under /tmp/foo directory and print
find /tmp/foo -path /tmp/foo/bar -print

find  files which  full path name is /tmp/foo/bar under foo directory and print
find foo -path /tmp/foo/bar -print

find files which full path name is /tmp/foo/bar under foo directory and print
find /tmp/foo -path /tmp/foo/bar -print

find  files which full path name is /tmpfoo/bar under /tmp/foo directory and print
find /tmp/foo -path /tmp/foo/bar -print /tmp/foo/bar

find  files which full path name is /tmpfoo/bar under foo directory and print
find foo -path /tmp/foo/bar -print

find  files which full path name is foo/bar under foo directory and print
find foo -path /tmp/foo/bar -print

find  files which full path name is foo/bar under foo directory and print
find foo -path foo/bar -print

find files which full path name like '*/*config' at current directory and print
find .  -path '*/*config'

find files which modification time is  7 days ago
find . -mtime -7

find files which modification time is  one day ago
find . -mtime 1

find file which name like 'foo.*' in current directory.
find . -name "foo.*"

find files with pattern` '*.h' and print comparison between file and /tmp/master directory
find . -name '*.h' -execdir diff -u '{}' /tmp/master ';'

find files with the extension .conf in the /etc directory
find /etc -name '*.conf'

Find files accessed at 23:59
find . -atime -1 -print

Find files and directories newer than CompareFile under current directory
find . -newer CompareFile -print

Find files/directories containing 'test' in their names and display the directory contents before the directories themselves
find -name "*test*" -depth

Find files/directories greater than 10MB in your home directory
find ~ -size +10M

Find files/directories in entire file system newer than myfile
find / -newer myfile

Find files/directories in entire file system that have been modified in the last minute
find / -mmin -1

Find files/directories in entire file system that were accessed in less than a day ago
find / -atime -1

Find files/directories in entire file system that were modified a day ago
find / -mtime 1

Find files/directories in entire file system with at least 644 permission
find / -perm -644

Find files and directories in the /tmp/ tree that contain spaces in their names and replace those spaces with underscores
find /tmp/ -depth -name "* *" -execdir rename 's/ /_/g' "{}" \;

Find files/directories under '/dir' directory tree that are newer than 'yesterday.ref' file and older than 'today.ref' file by modification time
find /dir -newer yesterday.ref -a \! -newer today.ref -print

Find files/directories under '/usr' directory tree that are newer than /tmp/stamp$$ by modification time
find /usr -newer /tmp/stamp$$

Find files/directories under /users/tom that matches both the pattern "*.pl" and  "*.pm"
find /users/tom -name "*.pl" -name "*.pm"

Find files/directories under current directory and force xargs to print them one by one
find . | xargs -n 1 echo

Find files/directories under current directory and print them
find . -print0 | xargs    -0 echo

Find files/directories under current directory and print them as null terminated strings.
find -print0

Find files/directories under current directory and write them to a file as null terminated strings.
find -fprint0

Find files/directories under current directory excluding the path ./src/emacs
find . -path ./src/emacs -prune -o -print

Find files/directories under current directory matching the posix-egrep type regex ".+\.(c|cpp|h)$" in their names
find . -regextype posix-egrep -regex ".+\.(c|cpp|h)$"

Find files/directories under current directory that are modified exactly one hour ago
find . -mtime 1

Find files/directories under current directory that matches './projects/insanewebproject' in their paths
find -ipath './projects/insanewebproject'

Find files/directories under current directory that matches './projects/insanewebproject' in their paths and show the first one
find -ipath './projects/insanewebproject'| head -n1

Find files/directories under current directory that matches 'projects/insanewebproject' in their paths
find -ipath 'projects/insanewebproject'

Find files/directories under current directory that matches the regex '/path/to/something'  in their paths
find . -exec sh -c 'echo {} | grep -qi /path/to/something' \; -print

Find files/directories under current directory that matches the regex /path/to/something[^/]*$  in their paths
find . -exec sh -c 'echo {} | grep -qi /path/to/something[^/]*$' \; -print

Find files/directories under current directory that matches the regex /path/to/something[^/]*$  in their paths
find . | grep -qi /path/to/something[^/]*$

Find files/directories under current directory that matches the regex /projects/insanewebproject[^/]*$  in their paths
find . -exec sh -c 'echo {} | grep -qi /projects/insanewebproject[^/]*$' \; -print

Find files/directories under current directory without descending into it
find -maxdepth 0

Find files/directories under current directory without descending into it
find -prune

Find files and directories modified in last 7 days
find . -mtime -7

Find files and directories modified within the last 7 days
find . -mtime -7

Find files/directories modified within the last day under /etc
find /etc -type f -ctime -1

Find files/directories modified within the last hour under current directory
find . -mtime -1

Find files/directories named 'articles.jpg' under current directory tree and change their permission to 644
find . -name "articles.jpg" -exec chmod 644 {} \;

Find files/directories named 'document' in 'ext2' partitions in entire filesystem
find / -fstype ext2 -name document -print

Find files/directories named 'document' in the entire filesystem and in the directory tree '/usr' even if it's in a different partition without traversing to other devices/partitions
find / /usr -xdev -name document -print

Find files/directories named 'file.txt' in the path '/usr/lib/important/'
find / -path /usr/lib/important/*/file.txt

Find files/directories named 'file.txt' that belong to user 'tutonics' in the entire filesystem
find / -user tutonics -name "file.txt"

Find files/directories named 'filename' in the entire filesystem
find / -name filename -print

Find files/directories named 'foo' in the current partition of the root filesystem
find -x / -name foo

Find files/directories named 'foo.bar' in the root filesystem partition
find / -name foo.bar -print -xdev

Find files/directories named 'photo.jpg' in the entire filesystem
find / -name photo.jpg

Find files/directories named 'sar' under '/usr', '/bin', '/sbin' and '/opt' directory tree
find /usr /bin /sbin /opt -name sar

Find files/directories named 'sar' under directory trees whose path starts with '/u' or '/b' or '/s' or '/o'
find `ls -d /[ubso]*` -name sar

Find files/directories named 'somename.txt' under current directory tree
find ./ -name "somename.txt"

Find files/directories named blah (case insensitive) under current directory
find ./ -iname blah

Find files/directories named blah under current directory
find ./ -name blah

Find files/directories not changed in two weeks under /dev/shm
find /dev/shm /tmp -type f -ctime +14

Find files/directories that are newer than 'foo.txt' under current directory tree
find -newer foo.txt

Find files and directories that are at least seven levels of nesting in the directory /usr/src
find /usr/src -name CVS -prune -o -mindepth 7 -print

Find files and directories that are at least seven levels of nesting in the directory /usr/src excluding CVS directory
find /usr/src -name CVS -prune -o -depth +6 -print

Find files/directories that are bigger than 10000 KB in size uder '/usr/local' directory tree
find /usr/local -size +10000k

Find files/directories that belong to user 'ian' under '/tmp' directory tree
find /tmp -user ian

Find files/directories that does not have write permssion for group
find /path ! -perm /020

Find files/directories that does not have write permssion for group
find /path ! -perm /g+w

Find files/directories that does not have write permssion for group and others
find /path ! -perm /022

Find files/directories that does not have write permssion for group or others
find /path ! -perm -022

Find files/directories that is under group 'root' or have no group and set their group to 'apache'
find /var/www -group root -o -nogroup -print0 | xargs -0 chown :apache

Find files/directories that have no owner or group under /path
find /path -nouser -or -nogroup

Find files/directories that have not been modified in the last one day in directories or files taken from the glob pattern '/tmp/test/*'
find /tmp/test/* -daystart -mtime +1

Find files/directories that isn't owned by the user 'apache' under /var/www
find /var/www ! -user apache -print0 | xargs -0

Find files and directories whose owner is daniel
find . -user daniel

Find files/directories with exactly read,write and execute permission for all (owner, group and others) under /path
find /path -perm 777

Find files/directories with exactly read,write and execute permission for all (owner, group and others) under /path
find /path -perm ugo+rwx

Find files and directories with group id 1003
find . -gid 1003

Find files/directories with inode number '212042' under '/var' directory tree without traversing other devices/partitions
find -x /var -inum 212042

Find files and directories with the name RAID but don't traverse a particular directory
find . -name RAID -prune -o -print

Find files/directories writable by group and others under the /path directory
find /path -perm -022

Find files/directories writable by group and others under the /path directory
find /path -perm -g+w,o+w

Find files/directories writable by group and others under the /path directory
find /path -perm -go+w

Find files/directories writable by group or others under the /path directory
find /path -perm /g+w,o+w

Find files newer than main.css in ~/src
find ~/src -newer main.css

Find files associated with an inode
find . -inum 968746 -exec ls -l {} \;

Find files associated with an inode
find . -inum 968746 -print

Find files belonging to the given owner
find /path/to/search -user owner

Find files bigger than 20 megabytes in the home directory tree
find ~ -size +20M

Find files by type
find -type type_descriptor

Find files changed in the last 1 day
find . -mtime -1 -type f

Find files containing `blah' in their names modified less than 2 days ago, case insensitive
find . -iname '*blah*' -mtime -2

Find files containing string "#!/bin/ksh" and append their names and matching strings to /tmp/allfiles
find . -type f -execdir /usr/bin/grep -iH '#!/bin/ksh' {} \; | tee /tmp/allfiles

Find files containing string "#!/bin/ksh" and append their names and matching strings to /tmp/allfiles
find . -type f -print | xargs /usr/bin/grep -il 'bin/ksh' | tee /tmp/allfiles

Find files created in the last minute; works on Mac OS X
find / -newerct '1 minute ago' -print

Find files ending in "*macs"
find -name '*macs'

Find files ending in "config"
find .  -path '*/*config'

Find files ending in "f"
find .  -path '*f'

Finds files in 'directory' folder with the same name and location but different content than files in 'directory.original' folder and saves location of such files to 'directories' variable.
directories=$(diff -qr directory directory.original | cut -d' ' -f2 | xargs dirname | uniq)

Find files in /var/tmp/stuff and below that have not been modified in over 90 days
find /var/tmp/stuff -mtime +90 -print

Find files in and below the current directory whose names begin with "not" and remove one of them
find . -name not\* | tail -1 | xargs rm

Find files in entire file system that are writable by group or other
find / -perm /g+w,o+w

Find files in entire file system that are writable by group or other
find / -perm /g=w,o=w

Find files in entire file system with at least 644 permissions
find / -perm -u+rw,g+r,o+r

Find files in the "dir" directory tree whose names are 33 characters in length
find dir -name '?????????????????????????????????'

Find files in the /home/user directory tree changed exactly 10 minutes ago
find /home/user/ -cmin 10 -print

Find files in the /travelphotos that are greater than 200k in size but do not have "2015" anywhere in the file name
find /travelphotos -type f -size +200k -not -iname "*2015*"

Find files in the /var/log folder which were modified an hour or more ago
find /var/log/ -mmin +60

Find files in the /var/log folder which were modified between 60 minutes and 10 minutes ago
find /var/log/ -mmin -60 -mmin +10

Find files in the current directory and its sub-directories that begin with 'f'.
find . -name f* -print

Find files in the current directory excluding CVS, SVN, GIT repository files and all binary files.
find . -not \( -name .svn -prune -o -name .git -prune -o -name CVS -prune \) -type f -print0 | xargs -0 file -n | grep -v binary | cut -d ":" -f1

Find files in the current directory recursively that are not readable by all
find -type f ! -perm -444

Find files in the current directory tree of size between 700k and 1000k
find . \( -size +700k -and -size -1000k \)

Find files in the current directory tree that are named "some_pattern" and move them to directory "target_location"
find . -name some_pattern -print0 | xargs -0 -i mv {} target_location

Find files in the current directory tree that match "pattern" and run "git diff" on them
find . -name "pattern" | xargs git diff --

Find files in the current directory tree that match pattern "*sub*"
find ./ -name "*sub*"

Find files in the current directory tree whose content was changed within the last 60 minutes
find . -mmin -60

Find files in the current directory tree whose names are of the form "cxx_data.txt" where xx is a number from 40 to 70
find . -regextype posix-egrep -regex "./c(([4-6][0-9])|70)_data.txt"

Find files in the current directory tree whose names begin with "file" and whose size is 0, and remove them
find -name 'file*' -size 0 -delete

Find files in the current directory tree whose names begin with "file" and whose size is 0, and remove them
find . -name 'file*' -size 0 -print0 | xargs -0 rm

Find files in the current directory tree whose pathnames contain "sub"
find ./ | grep "sub"

Find files in the current directory tree whose size is 24000 bytes
find . -size 24000c

Find files in the current directory tree whose size is greater than 24000 bytes
find . -size +24000c

Find files in the current directory tree whose size is less than 24000 bytes
find . -size -24000c

Find files in the current directory tree whose status was changed within the last 60 minutes
find . -cmin -60

Find files in the current directory tree which are larger than 5 MB in size
find . -size +5000k -type f

Find files in the current directory tree which have permissions rwx for user and rw for group and others
find . -perm 766

Find files in two different directories (esofthub and esoft) having the "test" string and list them
find esofthub esoft -name "*test*" -type f -ls

Find files under '/travelphotos' directory tree which are bigger than 200KB and do not have 2015 in their names
find /travelphotos -type f -size +200k -not -iname "*2015*"

Find files under /etc/apache-perl that are modified more recently than /etc/apache-perl/httpd.conf
find /etc/apache-perl -newer /etc/apache-perl/httpd.conf

Find files under /tmp that are larger than 10KB and smaller than 20KB
find /tmp -size +10k -size -20k

Find files under /usr that are newer than the first file `FirstFile'
find /usr -newer /usr/FirstFile -print

Find files under /usr that are the same age or older than file `FirstFile'
find /usr ! -newer /FirstFile -print

Find files under [directory] that match 'pattern_to_INCLUDE' in their names without descending into directories that match 'pattern_to_exclude' and 'another_pattern_to_exclude', then search for 'pattern' in those files
find [directory] -name "pattern_to_exclude" -prune -o -name "another_pattern_to_exclude" -prune -o -name "pattern_to_INCLUDE" -print0 | xargs -0 -I FILENAME grep -IR "pattern" FILENAME

Find files under current directory that are newer than $date_time in regards of modification time
find . -type f -newermt "$date_time"

Find files under current directory that are not newer than $date_time in regards of modification time
find . -type f -not -newermt "$date_time"

Find files under current directory with name (or glob pattern) expanded by $1 and save the list to /tmp/safe_del.lst
find . -name "$1" > /tmp/safe_del.lst

Find files under current directory without descending into other file systems and append a null character at the end of each paths
find -x . -type f -print0

Find files larger than 100MB in /var/www and exclude files with /download/ in their path from the output
find /var/www/ -type f -name "*" -size +100M -exec du -h '{}' \;|grep -v /download/

Find files readable only by the group
find . -perm g=r -type f -exec ls -l {} \;

Find files patching "pattern"
find . -name "pattern" -print

Find files matching `.ssh*' and append their anmes to file `ssh-stuff'
find / -name .ssh* -print | tee -a ssh-stuff

Find files matching an exact set of permissions
find / -perm 644

Find files matching pattern $2 in the $1 directory recursively and search them for text $3, where $1, $2, $3 are the command line arguments to the Bash script
find $1 -name "$2" -exec grep -Hn "$3" {} \;

Find files matching pattern $2 in the $1 directory recursively and search them for text $3, where $1, $2, $3 are the command line arguments to the Bash script
find $1 -name "$2" | grep -v '/proc' | xargs grep -Hn "$3" {} \;

Find files matching pattern $2 in the $1 directory recursively and search them for text $3, where $1, $2, $3 are the command line arguments to the Bash script
find $1 -path /proc -prune -o -name "$2" -print -exec grep -Hn "$3" {} \;

Find files matching regular expression regexp
find . | xargs grep regexp

Find files matching the pattern "./sr*sc" in their paths under current directory
find . -path "./sr*sc"

Find files modified at least 5 days in the future
find . -newermt "5 days"

Find files modified between 6 and 9 minutes ago
find . -mmin +5 -mmin -10

Find files modified in the last 5 minutes starting from the current directory
find . -mmin -5

Find files modified within the past 24 hours
find . -mtime 0

Find files named "AssemblyInfo.cs" in the current directory and below, and run "git diff --name-status" on them
find . -name AssemblyInfo.cs | xargs git diff --name-status --

Find files named "AssemblyInfo.cs" in the current directory and below, and run "git diff" on them
find . -name "AssemblyInfo.cs" -print0 | xargs -0 git diff --

Find files named "AssemblyInfo.cs" in the current directory and below, and run "git diff" on them
find . -name AssemblyInfo.cs | xargs git diff --

Find files named "blabla" in the current directory tree and print the number of lines in each of them
find ./ -name "blabla" -exec wc -l {} ;

Find files named "needle" ignoring the case
find . -iname "needle"

Find files named "ppp.conf" in the /etc directory tree
find /etc -name ppp.conf

Find files named 'core' in or below the directory /tmp and delete them
find /tmp -depth -name core -type f -delete

Find files named 'core' in or below the directory /tmp and delete them
find /tmp -name core -type f -print0 | xargs -0 /bin/rm -f

Find files named core in or below the directory /tmp and delete them, processing filenames in such a way that file or directory names containing single or double quotes, spaces or newlines are correctly handled.
find /tmp -name core -type f -print0 | xargs -0 /bin/rm -f

Find files on the system accessed during the last 24 hours but not within the last hour
find / -atime -1 -amin +60

Find files on the system created during the last 50 days
find / -ctime -50

Find files on the system modified more than 90 minutes ago
find / -mmin +90

Find files on the system that are bigger than 20 megabytes
find / -type f -size +20M -exec ls -lh {} \; 2> /dev/null | awk '{ print $NF ": " $5 }'

Find files on the system whose names begin with either x or X
find / -name "[Xx]*"

Find files owned by no group
find / -nogroup

Find files owned by nonexistent groups
find / -nogroup -print

Find files owned by nonexistent users
find / -nouser -print

Find files owned by the "shadow" group
find / -group shadow

Find files not matching shell pattern '*/vendor/*'
find . -not -wholename '*/vendor/*

Find files not matching the patterns 'Image*-70x70*' and 'Image*-100x100*' in their names under Folder1 and copy them to Folder2
find Folder1 \( ! -name 'Image*-70x70*' -a ! -name 'Image*-100x100*' \) | xargs -i% cp -p % Folder2

Find files not matching the posix extended regex '.+\-[0-9]{2,4}x[0-9]{2,4}\.jpg' in their paths under Folder1 and copy them to Folder2
find Folder1 -type f -regextype posix-extended \( ! -regex '.+\-[0-9]{2,4}x[0-9]{2,4}\.jpg' \) -print0 |  xargs -0 cp -p --target-directory=Folder2

Find files smaller than 40 blocks skipping directories on other file systems
find . -size -40 -xdev -print

Find files starting with the word "file" in the current directory tree, ignoring the case
find . -iname "file*"

Find files that are 0 bytes in size in the current directory and remove them
find . -maxdepth 1 -size 0c -exec rm {} \;

Find files that are 0 bytes in size in the current directory tree and remove them
find . -size 0 -exec rm {} \;

Find files that are empty
find -empty -type -f

Find files that are orphaned
find -nouser

Find files that are writable by both the “other” and the group under the plsql directory
find plsql -type f  -perm -220 -exec ls -l {} \; 2>/dev/null

Find files that are writable by both the “other” and the group under the plsql directory
find plsql -type f  -perm -ug=rw -exec ls -l {} \; 2>/dev/null

Find files that are writable by the user, the group, or both
find . -perm +220  -exec ls -l {} \; 2> /dev/null

Find files that are writable by the user, the group, or both
find plsql -type f  -perm /220 -exec ls -l {} \; 2>/dev/null

Find files that are writable by the user, the group, or both
find plsql -type f  -perm /ug=rw -exec ls -l {} \; 2>/dev/null

Find files that are writable by the user, the group, or both under the current directory
find . -perm +220  -exec ls -l {} \; 2> /dev/null

Find files that are writable by the user, the group, or both under the plsql directory
find plsql -type f  -perm /220 -exec ls -l {} \; 2>/dev/null

Find files that are writable by the user, the group, or both under the plsql directory
find plsql -type f  -perm /ug=rw -exec ls -l {} \; 2>/dev/null

Find files that match the executable bit for owner or group
find -type f -perm /110

Find files that do not have a listing in the /etc/passwd or /etc/group in the file system
find / -nouser -o  -nogroup

Find files that have been modified within the last month and copy them somewhere
find /etc/ -mtime -30 | xargs -0 cp /a/path

Find files that were accessed in less than a day ago
find / -atime -1

Find files that were modified 7 days ago and archive them
find . -type f -mtime 7 | xargs tar -cvf `date '+%d%m%Y'_archive.tar`

Find files that were modified in less than 1 minute ago
find / -mmin -1

Find files that were modified less than 7 days ago and archive them
find . -type f -mtime -7 | xargs tar -cvf `date '+%d%m%Y'_archive.tar`

Find files that were modified more than 7 days ago and archive them
find . -type f -mtime +7 | xargs tar -cvf `date '+%d%m%Y'_archive.tar`

Find files that were modified more than 7 days ago but less than 14 days ago and archive them
find . -type f -mtime +7 -mtime -14 | xargs tar -cvf `date '+%d%m%Y'_archive.tar`

Find files that were modified second last week and archive them
find . -type f -mtime +7 -mtime -14 | xargs tar -cvf `date ‘+%d%m%Y’_archive.tar`

Find files using file-name
find -iname "MyCProgram.c"

Find files whose content was modified at least 1 minute ago
find ./ -mmin +1

Find files whose data was modified within the given days of the month
find ./ -daystart -mtime -10 -and -mtime +1

Find files whose name starts with "MyFile", ignoring the case
find . -iname 'MyFile*'

Find files whose pathnames end in "config"
find .  -path '*/*config'

Find files whose pathnames end in "f"
find .  -path '*f'

Find files with 002 permission in entire file system
find / -type f -perm -002

Find files with 002 permission in entire file system and print them with the string 'has world write permissions' appended after every path
find / -type f -perm -002 -printf '%p has world write permissions\n'

Find files with 002 permission in entire file system and print them with the string 'has world write permissions' printed at last
echo $(find / -type f -perm -002) has world write permissions

Find files with 777 permissions and change them to 755
find / -type f -perm 0777 -print -exec chmod 755 {} \;

Find files with a question mark in their names
find . -name \*\\?\*

Find files with a question mark in their names and save the output as a file
find . -name \*\\?\* > output.txt

Find files which are more than 2 days old under  ${userdir}/${i}/incoming directory
find ${userdir}/${i}/incoming -mtime +2 -type f -ls

Find files which are more than 2 days old under  ${userdir}/${i}/incoming directory and remove them
find ${userdir}/${i}/incoming -mtime +2 -type f -exec rm {} \;

Find files with extension .conf in the /etc directory tree
find /etc -name "*.conf"

Find files with inode number 199053
find / -inum 199053

Find files with pattern "*[!0-9][1-9].txt"  and execute chmod and ls command with AND condition then sort the output
sudo find -name "*[!0-9][1-9].txt" -exec chmod 744 '*' {} \; -a -exec ls -l {} \; | sort | parallel ls -l

Find files with size more than 200557600B and which are more than 2 days old under  ${userdir}/${i}/incoming directory
find ${userdir}/${i}/incoming -mtime +2 -type f -size +200557600c -ls

Find files with size more than 200557600B and which are more than 2 days old under  ${userdir}/${i}/incoming directory and remove them
find ${userdir}/${i}/incoming -mtime +2 -type f -size +200557600c -exec rm {} \;

Find files with SGID (2000) and SUID(4000) permssions set in the file system
find /  \( -perm -2000 -o -perm -4000 \) -ls

Find files with the extension .conf in the /etc directory
find /etc -name '*.conf'

Find files which were changed in the past 1 hour
find . -cmin -60

Find find symlinks pointing to /mnt/oldname* in the entire file system
find / -type l -lname '/mnt/oldname*'

Find Flash videos stored by browsers on a Mac
find /private/ 2>/dev/null | grep /Flash

find for a filename with multiple patterns in the current folder
find . -name "photo*.jpg"

find for a word in all the regular files in the current directory
find . -type f -exec grep -li '/bin/ksh' {} \;

find for a word in all the regular files in the current directory
find . -type f -print | xargs grep -li 'bin/ksh'

Find for all *.txt files/directories in vfat file systems
find / -name  "*.txt" -fstype vfat 2> /dev/null

find not case sensitive all directories that names are 'apt'
find  / -type d -iname "apt"

find not case sensitive all directories that names are 'apt' and display details
find  / -type d -iname "apt" -ls

find not case sensitive all directories that names are 'project.images'
find  / -type d -iname "project.images" -ls

find foo, Foo, FOo, FOO, etc.
find . -iname foo

find foo, Foo, FOo, FOO, etc., but only files
find . -iname foo -type f

find for lighttpd in /var
find /var -name lighttpd

find for xml files in current folder using regular expressions
find ./ -regex "cmn-.*[\x4e00-\x9fa5]*\.xml"

find for the word "dba_2pc_pending" in all the files of current fodler having the word "sql" in their name
find . -print|grep sql|xargs grep -i dba_2pc_pending

(Linux specific) Find all loadable modules for current kernel, whose name includes "perf"
find /lib/modules/`uname -r` -regex .*perf.*

Find out all *.sh owned by user vivek
find / -user vivek -name "*.sh"

Find out all hard links in the /home directory to file1
find /home -xdev -samefile file1

Find out if there are any files on the system owned by user `account'
find / -path /proc -prune -o -user account -ls

Finds out what groups a current user has.
groups

Finds out what groups a given user has.
groups user

find out what group a given user has
groups user

Find grub.conf files in entire file system
find / -name grub.conf

Find grub.conf files in entire file system discarding errors
find / -name grub.conf 2>/dev/null

Find grub.conf files in entire file system discarding errors in csh or tcsh shell
find / -name grub.conf >& /dev/null

find httpd.conf file in /etc directory
find /etc -name "httpd.conf"

Finds if 'subversion' package is installed in system.
yum list | grep subversion

Finds if environment variable like 'DUALCASE' exists in environment.
env | grep DUALCASE

Find image files and move them to the pictures directory
find ~/Desktop -name “*.jpg” -o -name “*.gif” -o -name “*.png” -print0 | xargs -0 mv –target-directory ~/Pictures

find in $HOME files ending in "txt" and do nothing with them, or files ending in "html" and list them null separated.
find $HOME -name \*txt -o -name \*html -print0

Find in the current direcoty whose suffix is .tmp , find will not serach recursively limit of find is 2 subdirectory .
find .  -maxdepth 2 -name '*.tmp'

find in the entire file system for the file mysql
sudo find / -name mysql -print

find in the entire file system for the files which have sticky bit.
find / -perm 0551

find in the file system for the directories with the name "httpdocs"
find / -type d -name 'httpdocs'

find in the file system for the directories with the name "httpdocs" discard all the errors
find / -type d -name httpdocs 2> /dev/null

Finds IP address of default network interface.
netstat -rn | gawk '/UG/ {print $NF}' | xargs ifconfig | gawk 'match($0,/inet addr:(.*) B/,a) {print a[1]}'

find  js file which name is not  'glob-for-excluded-dir'  under current directory.
find . -name '*.js' -\! -name 'glob-for-excluded-dir' -prune

bind key "\x61" to insert itself
bind $'"\x61"':self-insert

Find largest file in linux with find command
find . -type f -printf "%s\t%p\n" | sort -n | tail -1

Find List directory  with sub-folder count .
find -maxdepth 1 -type d | sort | while read -r dir; do n=$(find "$dir" -type d | wc -l); let n--; printf "%4d : %s\n" $n "$dir"; done

Find List empty directories
find -maxdepth 1 -type d | sort | while read -r dir; do n=$(find "$dir" | wc -l); let n--; if [ $n -eq 0 ]; then printf "%4d : %s\n" $n "$dir"; fi; done

find list of all files with file permission , link , owner , group , reation time , size , file name
find . -exec ls -ld {} \;

Find List of directory  with non-zero file count
find -maxdepth 1 -type d | sort | while read -r dir; do n=$(find "$dir" -type f | wc -l); if [ $n -gt 0 ]; then printf "%4d : %s\n" $n "$dir"; fi; done

Find List of directories  with non-zero sub-folder count:
find -maxdepth 1 -type d | sort | while read -r dir; do n=$(find "$dir" -type d | wc -l); let n--; if [ $n -gt 0 ]; then printf "%4d : %s\n" $n "$dir"; fi; done

Find links that point to nothing
find / -type l -print | perl -nle '-e || print';

Find links that point to nothing To find links that point to nothing, use the perl interpreter with find, like this:
find / -type l -print | perl -nle '-e || print';

Find links to any file that happens to be named `foo.txt'
find . -lname \*foo.txt

Find links to any file that happens to be named `foo.txt'
find / -lname foo.txt

finda ll the files in the current folder that are modified today.
find ~ -type f -mtime 0 -ls

Find root's Ruby files accessed in the last two minutes
find /apps/ -user root -type f -amin -2 -name *.rb

Finds matched text in defined path recursively, but not follows symlinks.
grep -r "string to be searched"  /path/to/dir

find md5sum of 'string to be hashed'
echo 'string to be hashed' | md5

find md5sum of 'string to be hashed'
md5 -s 'string to be hashed'

find md5sum of 401
yosemite$ echo -n 401 | md5

find md5sum of a string "password"
printf 'password' | md5

find md5sum of a string stored in $pass
printf '%s' "$pass" | md5

find md5sum of an empty string
echo -n '' | md5

find md5sum of content from "www.google.com"
curl -s www.google.com | md5

find md5sums of files named "file*.txt"
md5sum file*.txt

find md5sum of string 'hi'
echo -n hi | md5

Find deb packages in the current directory recursively
find . -type f -and -iname "*.deb"

Find deb packages in the current directory recursively and list them with `dpkg'
find . -type f -and -iname "*.deb" | xargs -n 1 dpkg -I

Bind mount "/dev/random" on "/tmp/fakerandom"
mount --bind /tmp/fakerandom /dev/random

Bind mount "/original/path" on "/new/path"
mount --bind /original/path /new/path

Bind mount "/something" on "/new_something"
mount --bind /something /new_something

Finds file 'Subscription.java' and changes to containing folder.
cd $(find . -name Subscription.java | xargs dirname)

Finds file 'Subscription.java' and changes to containing folder.
cd `find . -name Subscription.java | xargs dirname`

Find file `filename.txt' in the current directory tree and edit it with `vi'
find . -type f -name filename.txt -exec vi {} +

Find file `foo.bar' and delete it
find /home -name foo.bar -type f -exec rm -f "{}" ';'

Find file names *blast* in specfied directory
find /usr/local -name "*blast*"

Find file names *blast* in specfied directory, case insensitive
find /usr/local -iname "*blast*"

Find file size in blocks
du -s <file>

Find file size in bytes
du -b FILE

Find mysong.ogg anywhere under the home directory
find $HOME -name 'mysong.ogg'

Find SQL files with text `expression'
find . -name "*.sql" -print0 -type f | xargs -0 grep "expression"

Finds name of a current month and saves it in a 'month' variable.
month=$(cal | head -1 | grep -oP "[A-Za-z]+")

Find not-executable files under /home/www
find /home/www/ ! -executable

Find number of different rows between File1 and File2.
diff --suppress-common-lines --speed-large-files -y File1 File2 | wc -l

find any files in the current directory that begin with a number
find . -regex './[0-9].*' -print

find any files or directories called ".svn" under the current directory and run a long list on each one, displaying a line count of the resultant output.
find . -iname .svn -exec bash -c 'ls -l "{}" | wc -l' \;

Find any files in the current directory and its sub-directories that were last accessed more than 7 days and are larger than 20480 blocks in size.
find . -atime +7 -size +20480 -print

Find any files in the current directory and its sub-directories that were last accessed more than 7 days or are larger than 10 * 1024 * 2 blocks in size, that is larger than 20480 blocks.
find . -atime +7 -o -size +`expr 10 \* 1024 \* 2` -print

Find only files under /etc with the size of 100k-150k
find /etc -size +100k -size -150k

Find any hidden regular files in the current directory and its sub-directories that were modified after .cshrc was last modified.
find . -type f -name ".*" -newer .cshrc -print

Find any file that has "disc" somewhere in its name in the current directory and all of its sub-directories.
find . -name *disc*

Finds only parts of echoed string that match with regex 'run-parts (-{1,2}\S+ )*\S+', and saves them in $match variable, each matched part on a separate line.
match=$(echo "${line}" | egrep -o 'run-parts (-{1,2}\S+ )*\S+')

Send one ping request to local machine.
ping -c 1 127.0.0.1 #ping your adress once

Send one ping request to host whose name or IP address is specified by variable "ip", using network interface eth9.
ping ${ip} -I eth9 -c 1

Send one ping request to host with local address in the 10.0.0.x range, with last number specified by variable "i", waiting 1 second for a reply, and output only lines containing "from" to standard output.
ping -W 1 -c 1 10.0.0.$i | grep 'from' &

(GNU specific) Find the process currently taking the most CPU time.
top -b -n1 -c  | grep -A 2 '^$'

Send Output From Find The Find Command To A File
find / -name *.mp3 -fprint nameoffiletoprintto

Finds pattern text ignoring letter case in all .js files, prints matched strings and name of file with that strings.
find . -name '*.js' -exec grep -i 'string to search for' {} \; -print

Find PHP files containing 2 or more classes
find . -type f -name "*.php" -exec grep --with-filename -c "^class " {} \; | grep ":[2-99]" | sort -t ":" -k 2 -n -r

Find PHP files with abstract classes
find . -type f -name "*.php" -exec grep --with-filename -c "^abstract class " {} \; | grep ":[^0]"

Finds PIDs of all running processes, gets executable binary of each process, and prints containing folder of each binary.
ps -A -o pid | xargs -I pid readlink "/proc/pid/exe" | xargs -I file dirname "file"

Finds PIDs of ssh sessions of all logged in users.
pgrep -u w | grep ssh| awk '{print $1}' ssh

Send ping requests to hostname specified by variable "c" for 1 second.
ping -w 1 $c

Find process "terminal" displaying the searching process
ps aux | grep '[t]erminal'

Finds real time report in a 'sleep 1' command execution statistic.
{ time sleep 1; } 2>&1 | grep real

Find recursively all empty directories in the current directory
find -type d -empty

Find recursively all empty directories in the current directory
find . -type d -empty

Find recursively all files changed within the last 5 minutes starting from directory b
find b -cmin -5

Finds recursively all files having extension .c, .h in '/path/' that contain 'pattern', and prints matched strings with string number and file name.
grep --include=\*.{c,h} -rnw '/path/to/somewhere/' -e "pattern"

Finds recursively all files in '/path/' excluding folders dir1, dir2 and all like *.dst, that contain 'pattern', and prints matched strings with string number and file name.
grep --exclude-dir={dir1,dir2,*.dst} -rnw '/path/to/somewhere/' -e "pattern"

Finds recursively all files in '/path/' that contain 'pattern', and prints matched strings with string number and file name.
grep -rnw '/path/' -e 'pattern'

Find recursively all files in /path that end in "txt" and copy them to /tmp/
find /path -type f -name "*txt" -printf "cp '%p' '/tmp/test_%f'\n" | bash

Find recursively all files in the "." directory tree whose names end with ".class" and delete them
find . -type f -name "*.class" -exec rm -vf {} \;

Find recursively all files under current directory tree that contain a colon in the filename
find . -name \*\:\*

Find recursively all files matching pattern 'file??' in the xargstest/ directory and print a sorted list of them
find xargstest/ -name 'file??' | sort

Finds recursively all files not having extension .o in '/path/' that contain 'pattern', and prints matched strings with string number and file name.
grep --exclude=*.o -rnw '/path/to/somewhere/' -e "pattern"

Find recursively all files that match "pattern" starting from the directory "dir"
find dir -name "pattern" 2>/dev/null

Find recursively all files whose names begin with "foo"
find . -name "foo*"

Finds recursively all folders in current folder which path not contains "NameToExclude" string and removes only ones without files and another folders within.
find . -type 'd' | grep -v "NameToExclude" | xargs rmdir

Finds recursively all folders named 'a' within current folder and removes only ones without files and another folders within.
find -type d -name a -exec rmdir {} \;

Finds recursively all folders named 'a' within current folder and removes only ones without files and another folders within.
find . -name "a" -type d | xargs rmdir

Finds recursively and following symlinks from root folder all files that contain "text-to-find-here" and prints files names.
grep -Ril "text-to-find-here" /

Find recursively all Python files in the current directory tree and count the number of lines in them
find . -name '*.py' | xargs wc -l

Find recursively all regular .txt files in the current directory tree except README.txt
find . -type f -name "*.txt" ! -name README.txt -print

Find recursively all regular files in directory tree b that were changed within the last 5 minutes and copy them to directory c
find b -type f -cmin -5 -exec cp '{}' c \;

Find recursively all regular files in the current directory skipping hidden files and directories matching pattern '.?*'
find -name '.?*' -prune -o \( -type f -print0 \)

Find recursively all regular files in the current directory tree not ending in .dll or .exe
find . -type f | grep -vP "\.dll$|\.exe$"

Find recursively all regular files in the current directory whose names contain "."
find . -type f -a -name '*.*'

Find recursively regular files in the directory given as the script's command line argument #1, skipping hidden files and directories
find "$1" -path "*/.*" -prune -o \( -type f -print0 \)

Find recursively the files named "file" in the current directory ignoring all .git directories
find . -name .git  -prune -o -name file  -print

Find recursively the files named "file" in the current directory ignoring the .git subdirectory
find . -path ./.git  -prune -o -name file  -print

Find recursively the latest modified .zip file in the current directory
find . -name "*zip" -type f | xargs ls -ltr | tail -1

Find recursively the latest modified file in the current directory
find . -type f -print0 | xargs -0 ls -ltr | tail -n 1

Find recursively the latest modified file in the current directory
find . -type f -print0 | xargs -0 stat -f "%m %N" | sort -n | tail -1 | cut -f2- -d" "

Find recursively the latest modified file in the current directory
find . -type f -print0 | xargs -0 stat -f "%m %N" | sort -rn | head -1 | cut -f2- -d" "

Find recursively the latest modified file in the current directory
find . -type f -print0|xargs -0 ls -drt|tail -n 1

Find recursively the latest modified file in the current directory
find . -type f -printf '%T@ %p\n' | sort -n | tail -1 | cut -f2- -d" "

Find recursively the latest modified file in the current directory
find . -type f -printf '%TY-%Tm-%Td %TH:%TM: %Tz %p\n'| sort -n | tail -n1

Find recursively the latest modified file in the current directory
find . -type f | xargs ls -ltr | tail -n 1

Finds recursion-related options of a 'grep' utility.
grep --help |grep recursive

find regular files and directories that have been modified in the last seven days
find . -mtime -7 -type f

find regular files in the current directory, without descending into sub-directories and display as a null separated list.
find -maxdepth 1 -type f -printf '%f\000'

find regular/normal files in the current folder
find -type f

find regular files under the current directory and execute an md5sum command on each one
find -type f -exec md5sum {} +

find regular files under the current directory, whose name ends in .mbox, piping the output to a while loop that renames each file, to the same name without .mbox at the end
find . -type f -wholename \*.mbox -print0 | \     while read I ; do         mv $I $(echo $I | sed 's/\.mbox//') ;     done ;

find regular files under the current directory, whose name ends in .mbox, piping the output to the GNU Parallel command that will rename each file to not have a file extension.
find . -type f -wholename \*.mbox -print0 | parallel -0 mv {} {.}

find regular files under the current directory, whose name ends in .mbox, piping the output to the GNU Parallel command that will rename each file to not have a file extension.
find . -type f -wholename \*.mbox | parallel mv {} {.}

find regular  file named foo.txt under root / directory.
find / -name foo.txt -type f

find regular file named foo.txt under root / directory.
find / -name foo.txt -type f -print

find regular files which modification time is  7 days ago
find . -mtime -7 -type f

find regular files whose filename is "your_pattern" and display the total size of the files in human readable format.
find . -type f  -name "your_pattern" -exec du -ch {} + 2>/dev/null | grep total$.

find regular files whose filename is "your_pattern", suppressing all error messages.
find / -type f -name "your_pattern" 2>/dev/null

Find regular files in the current directory tree that are called FindCommandExamples.txt and remove them
find . -type f -name "FindCommandExamples.txt" -exec rm -f {} \;

Find regular files in the current directory tree that have all executable bits set
find -L . -type f -perm -a=x

Find regular files in the current directory tree that have executable bits set for the user and group but not for the other
find -L . -type f -perm -u=x,g=x  \! -perm -o=x

Find regular files in the current directory tree that have any executable bits set
find -L . -type f \( -perm -u=x -o -perm -g=x -o -perm -o=x \)

Find regular files under '/somefolder' directory tree satisfying the options/conditions/operations provided in ${ARGS[@]} array with find command
find /somefolder -type f '(' "${ARGS[@]}" ')'

Find regular files under / that contain "string" and clear out their contents, including newlines
find / -maxdepth 1 -xdev -type f|xargs grep -l 'string'| xargs perl -pi -e 's/.*\n//g'

Find regular files under / that contain "stringtofind"
find / -maxdepth 1 -xdev -type f  -exec grep -li stringtofind '{}' \;

Find regular files under / that contain "stringtofind" and clear out their contents
find / -maxdepth 1 -xdev -type f -exec grep -Zli "stringtofind" {} + |  while IFS= read -r -d $'\0' file; do sed '/./d' "$file"; done

Find regular files under / that contain "stringtofind" and clear out their contents
find / -maxdepth 1 -xdev -type f -exec grep -Zli "stringtofind" {} + | parallel -0 sed "'/./d'" '{}'

Find regular files under / that contain "stringtofind" and clear out their contents
find / -maxdepth 1 -xdev -type f -exec grep -i "stringtofind" -q "{}" \; -print0 | xargs -0 sed '/./d

Find regular files under / that contain "stringtofind" and clear out their contents
find / -maxdepth 1 -xdev -type f -exec grep -li "stringtofind" {} + | parallel sed "'/./d'" '{}'

Find regular files under and below /path that match pattern "???-???_[a-zA-Z]*_[0-9]*_*.???"
find /path -type f -name "???-???_[a-zA-Z]*_[0-9]*_*.???"

Find regular files larger than 500MB in the current directory tree
find . -type f -size +500M

Find regular files readable by the world
find . -perm -g=r -type f -exec ls -l {} \;

Find regular files matching pattern "*oraenv*" and excecute the "file" utility for each of them
find . -name "*oraenv*" -type f -exec file {} \;

Find regular files modified less than 14 days ago stripping ./ from each file name
find . -type f -mtime -14 | cut -b 3- > deploy.txt

Find regular files modified within the last 7 days
find . -mtime -7 -type f

Find regular files named "expression -and expression" under and below /dir/to/search/
find /dir/to/search/ -type f -name 'expression -and expression' -print

Find regular files named "expression -or expression" under and below /dir/to/search/
find /dir/to/search/ -type f -name 'expression -or expression' -print

Find regular files named "regex" under and below /dir/to/search/
find /dir/to/search/ -type f -name 'regex' -print

Find regular files named 'findme.txt' under '/usr' and '/home' directory tree
find /usr /home -name findme.txt -type f -print

Find regular files named core under /tmp and delete them
find /tmp -name core -type f -print | xargs /bin/rm -f

Find regular files that are bigger than 500 MB in size under current directoryt tree
find . -type f -size +500M

Find regular files that have SUID or SGID set
find / -perm +6000 -type f

Find regular files whose names end in .JPG
find . -type f -name "*.JPG"

Find regular files with permissions less than 111
find -perm -111 -type f

Find regular files which have 644 permission
find . -perm 644 -type f -exec ls -l {} \;

Find regular non-hidden files containing 'some text' in their names
find . -not -path '*/\.*' -type f -name '*some text*'

Find regular non-hidden files containing `some text' in their names with hidden directories optimization
find . -type d -path '*/\.*' -prune -o -not -name '.*' -type f -name '*some text*' -print

find regular which case-insensitive name is foo in current directory
find . -iname foo -type f

Send reverse requests to get domain name for each address in 'my_ips' list
cat my_ips | xargs -i dig -x {} +short

find setuid files and directories writing the details to /root/suid.txt , and find large files writing the details to /root/big.txt, traversing the filesystem just once
find / \( -perm -4000 -fprintf /root/suid.txt '%#m %u %p\n' \) , \  \( -size +100M -fprintf /root/big.txt '%-10s %p\n' \)

Find how many directories are in a path (counts current directory)
find . -type d -exec basename {} \; | wc -l

Find how many files are in a path
find . -type f -exec basename {} \; | wc -l

Send SIGHUP signal to all SSH server processes, causing them to re-read the SSH server configuration.
kill -HUP $(lsof -t -c sshd)

Send SIGHUP (hangup) signal to nginx master process, causing it to re-read its configuration and restart child processes if necessary.
kill -HUP $( cat /var/run/nginx.pid )

Send SIGKILL signal to all processes using TCP port 8080, terminating them instantly.
kill -9 $(lsof -t -i:8080)

Send SIGKILL (signal 9) signal to all processes whose command matches "csp_build"
kill -9 `pgrep -f cps_build`

Send SIGKILL signal to process ID 16085, killing it instantly.
kill -9 16085

Send SIGKILL signal to processes ID 18581, 18582, and 18583, killing them instantly.
kill -9 18581 18582 18583

Send SIGKILL to all processes owned by user 'daniel', terminating them instantly.
kill -9 $(lsof -t -u daniel)

Send SIGTERM signal to all 'firefox' processes, requesting them to terminate.
kill `pidof firefox`

Send SIGTERM signal to all processes using TCP port 8080, requesting them to terminate.
kill $(lsof -t -i:8080)

Send SIGTERM signal to all python processes running script "csp_build.py"
kill $(pgrep 'python csp_build.py')

Send SIGTERM signal to entire session of processes containing process whose ID is 21709.
kill $(ps -o pid= -s $(ps -o sess --no-heading --pid 21709))

Send SIGTERM signal to last process sent to background by the current shell.
kill $!

Send SIGTERM signal to any process which 'ps' lists as "python csp_build.py"
kill $(ps aux | grep '[p]ython csp_build.py' | awk '{print $2}')

Send SIGTERM signal to any process which 'ps' lists as "python csp_build.py"
kill `ps ax | grep 'python csp_build.py' | awk '{print $1}'`

Send SIGTERM signal to any process which 'ps' lists as "python csp_build.py"
ps aux | awk '$11" "$12 == "python csp_build.py" { system("kill " $2) }'

Send SIGTERM signal to the first process whose command matches "csp_build"
ps aux | grep 'python csp_build.py' | head -1 | cut -d " " -f 2 | xargs kill

Send SIGTERM (signal 15) to all processes using TCP port 6000 on the system using root account.
sudo kill -15 $( sudo lsof -i:6000 -t )

Send SIGWINCH process to current shell, causing it to update the LINES and COLUMNS variables which describe the size of the screen/window in characters.
kill -s WINCH $$

Find SGID files
find / -perm +2000

Find SGID files
find / -perm +g=s

Find SUID files
find / -perm +4000

Find SUID files
find / -perm +u=s

Find smallest file in the current directory with find commad
find . -type f -printf "%s\t%p\n" | sort -n |head -1

Finds shell options with 'login' in name.
shopt | grep login

Find sqlite3 databases in the current directory tree and execute query 'SELECT * FROM table WHERE column1="value"' on all of them
find . -name 'sqlite.db' -exec sqlite3 "{}" 'SELECT * FROM table WHERE column1="value"' \;

Find sqlite3 databases in the current directory tree, execute query 'SELECT * FROM table WHERE column1="value"' on all of them, and search the result for "value"
find . -name "*.db" -type f | while read file ; do sqlite3 $file "SELECT * FROM table WHERE column1='value'" | grep value ; if [ $? -eq 0 ] ; then echo $file ; fi done

Finds string with text "string to be searched" in any cased files like "*.cs" recursively in a current folder.
find ./ -type f -iname "*.cs" -print0 | xargs -0 grep "content pattern"

find StringBuffer in all *.java files
find . -type f -name "*.java" -exec grep -l StringBuffer {} \;

find StringBuffer in all *.java files, ignoring case
find . -type f -name "*.java" -exec grep -il string {} \;

Find StringBuffer in all *.java files
find . -type f -name "*.java" -exec grep -l StringBuffer {} \;

find suffix tcl files under all directories started with 'n'
find ./n* -name "*.tcl"

Find suspicious PHP files
find . -type f -name "*.php" -exec grep --with-filename "eval(\|exec(\|base64_decode(" {} \;

Find symbolic links in /usr/lib and /usr/lib64 to files whose pathnames contain "libstdc++"
find  /usr/lib/ /usr/lib64/ -lname "*libstdc++*"

Find symbolic links in /usr/sbin and /usr/bin to files whose pathnames end in "*/systemctl"
find /usr/sbin /usr/bin -lname "*/systemctl"

Find symbolic links in directory /etc and below
find /etc -type l

Find symbolic links in lpi104-6 and research/lpi104-6 to files whose pathnames end in "file1"
find lpi104-6 research/lpi104-6 -lname "*file1"

Find symbolic links under /etc/
find /etc -type l

find symbolic links with pattern` '*sysdep.c'
find . -lname '*sysdep.c'

Find symlinks in the current directory tree
find . -type l | xargs ls -ld

Find target.out files starting from /starting/path and pass them as arguments to /path/to/simpleGrepScript.sh
find /starting/path -name target.out | xargs /path/to/simpleGrepScript.sh

Find target.txt files in the /base/path/of/proj/d‌​ata directory tree and pass them as arguments to simpleGrepScript.sh, saving the output as overallenergy.out
find /base/path/of/proj/d‌​ata -name target.txt | xargs simpleGrepScript.sh > overallenergy.out

find Texinfo source files in /usr/local/doc
find /usr/local/doc -name '*.texi'

find Texinfo source files in /usr/local/doc
find foo -path foo/bar -print

Find the "*.foo" files in the current directory tree that are not under ".snapshot" directories
find . -name .snapshot -prune -o -name '*.foo' -print

find the "MyCProgram.c" file (case insensitive find) under the current directory
find -iname "MyCProgram.c"

Find the "param1" string in regular files under and below /var
find /var  -type f -exec grep "param1" {} \; -print

Find the "param1" string in regular files under and below /var
find /var -type f  | xargs grep "param1"

Find the .groovy files outside the "./target" directory path
find .  -name "*.groovy" -not -path "./target/*" -print

Find the 5 largest regular files in the current directory and below.
find -type f -exec du -Sh {} + | sort -rh | head -n 5

Send the contents of "file" as input to "clipboard"
cat file | clipboard

find the count of all the charcters of the list of regular files present in the current folder
find . -type f | xargs | wc -c

find the count of all the regular files in a directory
find /usr -type f | wc -l

Find the core files and  remove them
find . -name “core” -exec rm -f {} \;

Find the current directory and all its subdirectories.
find . -type d

find the depth of all the files in current folder and display the depth and file name
find folder1/ -depth -type f -printf "%d\t%p\n"

Find the directories whose names contain "New Parts" at level 3 of the current directory tree and create symlinks to them in /cygdrive/c/Views
find -mindepth 3 -maxdepth 3 -type d -name "*New Parts*" -exec ln -s -t /cygdrive/c/Views {} \;

Find the directories whose pathnames contain "New Parts" at level 3 of the current directory tree and create symlinks to them in /cygdrive/c/Views
find -mindepth 3 -maxdepth 3 -type d | grep "New Parts" | tr '\012' '\000' | xargs -0 ln -s -t /cygdrive/c/Views

Find the directory with least access time under current directory and assign it to $filename
{ read -r -d' ' time && IFS= read -r -d '' filename; } < <(find . -type d -printf '%A@ %p\0' | sort -z -r -n)

Find the directory with least modification time under current directory
find -type d -printf '%T+ %p\n' | sort | head -1

find the file "MyCProgram.c" in the current folder
find -iname "MyCProgram.c"

find the file "filename.txt" in the entire file system
find / -name filename.txt -print

find the file "filename.txt" in the usr folder
find /usr -name filename.txt -print

find the file "foo.txt" in the current folder and assign the output to a variable
OUTPUT=`find . -name foo.txt`

find the file "myfile.txt" in the folder /home/user/myusername/
find /home/user/myusername/ -name myfile.txt -print

find the file arrow.jpg in the entire file system
find / -name arrow.jpg

find the file with inode $inum under the current directory and delete it
find . -inum $inum -exec rm {} \;

find the file with the name "esxcfg-firewall" in the current folder
find -print | grep esxcfg-firewall

Find the files in the current directory that match pattern '*.ISOLATE.quantifier.txt' and move them to folder ISOLATE/
find -name '*.ISOLATE.quantifier.txt' -maxdepth 1 -exec mv {} ISOLATE/ +

Find the files in the current directory that match pattern '*.JUKEBOX.*.txt' and move them to folder ./JUKEBOX
find . -name '*.JUKEBOX.*.txt' -maxdepth 1 -print0 | xargs -0 -IFILE mv FILE ./JUKEBOX

Find the files that have "644" permissions and modify them to have "664" permissions
find . -type f -perm 644 -exec chmod 664 {} \;

Find the first file/directory in ... directory and quit
find ... -print -quit

Find the first file/directory under $DIR which matches the $TMP_DIR in its path
/usr/bin/find $DIR -maxdepth 1 -ipath $TMP_DIR -print -quit

Find the first file/directory under current directory and quit
find . ... -exec sh -c 'printf "%s\n" "$1"; kill "$PPID"' sh {} \;

Find the first file/directory under current directory and quit
find . ... -print -quit

Find the first file/directory under current directory named 'modules' and exit with empty result
find . -name modules -exec sh -c 'exit 0' \;

Find the first file/directory named 'something' under current directory and quit
find . -name something -print -quit

Finds the folder where temporary files would be written to, and save path to it in a 'TMPDIR' variable.
TMPDIR=`dirname $(mktemp -u -t tmp.XXXXXXXXXX)`

find the biggest files only (but not directories)
find . -type f -exec du -Sh {} + | sort -rh | head -n 15

Find the largest 10 directories under current directory
find . -type d -print0 | xargs -0 du | sort -n | tail -10 | cut -f2 | xargs -I{} du -sh {}

Find the largest files in a particular location
find /home/tecmint/Downloads/ -type f -exec du -Sh {} + | sort -rh | head -n 5

Find the largest files in a particular location
find /home/tecmint/Downloads/ -type f -printf "%s %p\n" | sort -rn | head -n 5

find the md5 sum of all the regular files in multiple folders and display them in sorted order
find teste1 teste2 -type f -exec md5 -r {} \; | sort

find the most recently changed files under current directory
find . -type f -printf '%TY-%Tm-%Td %TT   %p\n' | sort

Find the most recently changed files in a subtree
find . -type f -printf '%TY-%Tm-%Td %TT   %p\n' | sort

Find the most recently modified files in /path/to/dir and print the modification time followed by a tab and the filename for each file
find /path/to/dir -type f | perl -ne 'chomp(@files = <>); my $p = 9; foreach my $f (sort { (stat($a))[$p] <=> (stat($b))[$p] } @files) { print scalar localtime((stat($f))[$p]), "\t", $f, "\n" }' | tail

Find the file in the current directory tree with inode number $inum and delete it
find . -inum $inum -exec rm {} \;

Find the file whose inode number is 1316256
find . -inum 1316256

Find the oldest *.sql file under current directory
find . -name \*.sql | xargs \ls -1rc | tail -7 | head -1

find the oldest normal file in the current directory and display its contents
find -type f -printf "%T+ %p\0" | sort -z | grep -zom 1 ".*" | cat

Find the passwd file in the current directory and one level down
find -maxdepth 2 -name passwd

Find the passwd file under root and one level down.
find -maxdepth 2 -name passwd

Find the passwd file under root and two levels down
find / -maxdepth 3 -name passwd

Find the passwd file under the root directory and two levels down
find / -maxdepth 3 -name passwd

find the path of a specfic video file in the current directory
find ./ -name "foo.mp4" -printf "%h\n"

find the top 25 files in the current directory and its subdirectories
find . -type f -exec ls -al {} \; | sort -nr -k5 | head -n 25

Find the top 25 files according to their size in the current directory and its subdirectories
find . -type f -exec ls -al {} \; | sort -nr -k5 | head -n 25

Find the top 5 biggest files
find . -type f -exec ls -s {} \; | sort -n -r | head -5

Find the top 5 big files
find . -type f -exec ls -s {} \; | sort -n -r | head -5

Find the top 5 small files
find . -type f -exec ls -s {} \; | sort -n  | head -5

Find the top level directories that contain a 'bin' directory in it or in one of it's sub-directories and print a sorted list to file b
find . -type d -name bin | cut -d/ -f1,2 | sort > b

find the regular js files which path does not contains '*/test/*'  and name does not contains '*-min-*' or '*console*'
find . ! -path "*/test/*" -type f -name "*.js" ! -name "*-min-*" ! -name "*console*"

Send the SIGTERM signal to all processes whose command matches "bad_process" and which have used more than 100 seconds of total CPU time.
ps -o pid,bsdtime --no-header -p $(pgrep renoise) | awk 'function mmss2s(s) {if (s !~ /^[0-9][0-9][0-9]:[0-9][0-9]$/) return -1; return ((60*substr(s,1,2))+substr(s,4,2))} { if (mmss2s($2) > 100) { print $1; }}'

Find the sizes of only directories under current directory sorted by size and redirect the output to dir-sizes.txt
find . -type d -print0 | xargs -0 -n1 du -sk | sort -rn > dir-sizes.txt&

Find the sorted and unique parent directory paths appended with : of all the files that are executable by owner under ~/code directory without descending into hidden directories and redirect the output to the file ~/.codepath
find ~/code -name '.*' -prune -o -type f -a -perm /u+x -printf ':%h\n' |sort |uniq |tr -d '\n' > ~/.codepath

Find the string 'joomla' case insensitively in all the php and html files under current directory tree and display the matched lines along with the file names and line numbers
find . \( -name "*.php" -o -name "*.html" \) -print0 | xargs -0 grep -Hin "joomla"

Find the total size of *.jpg files within the directory tree ./photos/john_doe
find ./photos/john_doe -type f -name '*.jpg' -exec du -ch {} + | grep total$

Find the total size of all the ".avi" files in all the sub-folders below "/mnt/iso"
find /mnt/iso -name *.avi -printf "%s\n" | paste -sd+ - | bc

find the ten biggest files
find /home -type f -exec du -s {} \; | sort -r -k1,1n | head

find the type & description of all the regular/normal files in the home folder
find /home -type f -print0 | xargs -0 file

find the type of all the regular/normal files in the current folder
find . -type f -exec file {} \;

find the type of all the regular/normal files in the current folder
find . -type f | xargs file

find the type of all the regular/normal files in the current folder (plus takes bulk of files as input to the file command)
find . -type f -exec file {} \+;

Finds total lines count of all *.php files in a current folder and subfolders.
( find ./ -name '*.php' -print0 | xargs -0 cat ) | wc -l

Finds total lines count of few types of files (*.h and *.cpp) in a current folder and subfolders.
( find . \( -name '*.h' -o -name '*.cpp' \) -print0 | xargs -0 cat ) | wc -l

Send TERM signal to process with id listed in '/var/run/DataBaseSynchronizerClient.pid' file
kill `cat /var/run/DataBaseSynchronizerClient.pid`

Send uncompressed contents of "input.gz" to "./myscript.pl"
zcat input.gz | ./myscript.pl

Send uncompressed contents of "large_file.gz" to "largesplitter"
zcat large_file.gz | largesplitter

Find user daniel's files of type jpeg without `autumn' in the name
find . -user daniel -type f -name *.jpg ! -name autumn*

Find users whose names begin with "ab" and ends with "1"
who | cut -d ' ' -f 1 | grep -e '^ab' -e '1$'

Find users whose names begin with "ab" or whose terminal from which they are logged in ends with "1"
who | grep -e '^ab' -e '1$'

Find UTF-8 files with BOM
find -type f -print0 | xargs -0 grep -l `printf '^\xef\xbb\xbf'` | sed 's/^/found BOM in: /'

Find which ruby files under current directory contain the string 'jump'
find . -name '*.rb' -exec grep -H jump {} \;

bind word "foobar" to key code "\e[24~"
bind '"\e[24~":"foobar"'

bind word "pwd\n" to key code "\e[24~"
bind '"\e[24~":"pwd\n"'

Find writable files in the current directory tree
find . -writable

Find writable regular files in the current directory
find -type f -maxdepth 1 -writable

Find writable regular files in the current directory
find .  -maxdepth 1 -type f -writable

Find writable regular files omitting those that contain sites/default/files in their names
find . -type f -writable | grep -v sites/default/files

Find x* files/directories under /tmp directory whose status was changed less than 1 day ago and move them to ~/play
find /tmp/ -ctime -1 -name "x*" -exec mv '{}' ~/play/

Find x* files/directories under /tmp directory whose status was changed less than 1 day ago and move them to ~/play
find /tmp/ -ctime -1 -name "x*" | xargs -I '{}' mv '{}' ~/play/

Find x* files/directories under /tmp directory whose status was changed less than 1 day ago and move them to ~/play
find /tmp/ -ctime -1 -name 'x*' -exec sh -c '   exec mv "$@" ~/play/' sh {} +

Find x* files/directories under /tmp directory whose status was changed less than 1 day ago and move them to ~/play
find /tmp/ -ctime -1 -name 'x*' -print0 | xargs -r0 mv -t ~/play/

Locating large files (> 100 MB) in /home/ for 'cleaning'
find /home -type f -size +100M -delete

Filter out current date in current time zone from the GMT+30 and GMT+20 representations of current date and show the last one
echo -e "$(TZ=GMT+30 date +%Y-%m-%d)\n$(TZ=GMT+20 date +%Y-%m-%d)" | grep -v $(date +%Y-%m-%d) | tail -1

Follow symbolic links for the full path of "lshw"
readlink -f $(which lshw)

Follows symbolic link $BASH_SOURCE, and prints path to its target.
$(dirname $(readlink -f $BASH_SOURCE))

Sorts content of the $tmp file and filters out all strings with ':0'.
sort $tmp | grep -v ':0'  #... handle as required

Sort "$file" and output the result to "$file"
sort -o $file $file

Sort "," delimited lines in "file" by the first field preserving only unique lines
sort -u -t, -k1,1 file

Sort "file" using a buffer with a size 50% of main memory
sort -S 50% file

Sort "file1.txt" and output the result to "file1.txt"
sort -o file1.txt file1.txt

Sort "some_data" by the first and second ";" delimited entries and stabilizing the sort
sort -k1,1 -k2,2 -t';' --stable some_data

Sort "some_data" by the first and second ";" delimited entries, outputing unique lines and stabilizing the sort
sort -k1,1 -k2,2 -t';' --stable --unique some_data

Sort a file 'file' preserving only unique lines and change the file in-place
sort -u -o file !#$

Sort and compare files "$def.out" and "$def-new.out"
diff <(sort $def.out) <(sort $def-new.out)

Sort all directory names matching folder_* and go to the last one.
cd $(find . -maxdepth 1 -type d -name "folder_*" | sort -t_ -k2 -n -r | head -1)

sort and display top 11 files along with the last access date for all the files in the file system ( sort based on the timestamp )
find / -type f -printf "\n%AD %AT %p" | head -n 11 | sort -k1.8n -k1.1nr -k1

Sort and display the file name and creation month of top 11 files in the entire file system (Sort in the order of month )
find / -type f -printf "\n%Ab %p" | head -n 11 | sort -k1M

sort and display the unique lines display the contents of all the files that have been modified in the last 91 days and not in the last 2 days
find .  -name "*.txt" -type f -daystart -mtime -91 -mtime +2 | xargs cat | sort | uniq

Sort all files/directories under current directory according to modification time and print only the recent 7 of them
find -mindepth 1 -printf "%T@ %P\n" | sort -n -r | cut -d' ' -f 2- | tail -n +7

tar all files in the current folder and ask for user confirmation before creating the tar ball
find . -ok tar rvf backup {} \;

Sort and remove duplicate lines in the output of "finger"
finger | sort -u

Sort and show top 10 processes by memory usage
ps aux | awk '{print $2, $4, $11}' | sort -k2rn | head -n 10

tar all the regular java files to myfile.tar
find . -type f -name "*.java" | xargs tar cvf myfile.tar

sort all the regular files in the "$DiskName" directory which have been modified in the last 3*24 hours and which are bigger than 5Kb based on their size and save the output to the "$TMPFILE"(discard all the errors during search)
find $DiskName -type f -mtime -3 -size +5000 -exec ls -ld {} \; 2>/dev/null | sort -n -k 5.1,5 >> $TMPFILE

Sort tab separated file "file" using a version sort for field 6 and a numeric sort for field 7
sort -t$'\t' -k6V -k7n file

Sort strings of 'test.txt' file by second from the end field
rev   test.txt | sort  -k2 | rev

Sort content of files 'file1' and 'file2' by second of dot-separated fields.
cat file1 file2 |sort -t. -k 2.1

Force create a hard link in "/usr/local/bin" to "findpdftext"
sudo ln -f "findpdftext" /usr/local/bin

Force create a hard link named "non_secret_file.txt" to "secret_file.txt"
ln -f secret_file.txt non_secret_file.txt

Force create a hard link named '/home/user/Musik/youtube converted/aesthesys~ I Am Free, That Is Why I'"'"'m Lost..mp3' with target '/home/user/Musik/mix-2012-13/aesthesys~ I Am Free, That Is Why I'"'"'m Lost..mp3'
ln -f '/home/user/Musik/mix-2012-13/aesthesys~ I Am Free, That Is Why I'"'"'m Lost..mp3' '/home/user/Musik/youtube converted/aesthesys~ I Am Free, That Is Why I'"'"'m Lost..mp3'

Force create a symbolic link in "/usr/bin/" for each file matching "$javaUsrLib/jdk1*/bin/*"
sudo ln -f -s $javaUsrLib/jdk1*/bin/* /usr/bin/

Force create a symbolic link named "$*" to the canonical absolute path of "$1"
ln -sf "$(readlink -f "$1")" "$*"

Force create a symbolic link named "$lines" to "$c" without dereferencing "$lines"
ln -sfn "$c" "$lines"

Force create a symbolic link named "$pdir" to "$pluginpath" with verbose output
sudo ln --symbolic --verbose --force "$pluginpath" "$pdir"

Force create a symbolc link named "/usr/local/bin/fpdf" to "/usr/local/bin/findpdftext"
sudo ln -s -f "/usr/local/bin/findpdftext" "/usr/local/bin/fpdf"

Force create a symbolc link named "/usr/local/bin/fpt" to "/usr/local/bin/findpdftext"
sudo ln -s -f "/usr/local/bin/findpdftext" "/usr/local/bin/fpt"

Force create a symbolic link named "currentDir" to "newDir" without dereferencing "currentDir"
ln -sfn newDir currentDir

Force create a symbolic link named "id_rsa" to "$keyname"
ln -sf $keyname     id_rsa

Force create a symbolic link named "mylink" with target "/apps/myapps/new/link/target"
ln -f -s /apps/myapps/new/link/target mylink

Force create a symbolc link named "new_dir" to "/other/dir" without dereferencing "new_dir"
ln -sfn /other/dir new_dir

Force create a symbolc link named "softlink_name" to "source_file_or_directory_name" without dereferencing "softlink_name"
ln -sfn source_file_or_directory_name softlink_name

Force create a symbolic link to "$f" in "~/my-existing-links/" with name the basename of "$f"
ln -sf "$f" "~/my-existing-links/$(basename $f)"

Force create a symbolic link without dereferencing named "$SYMLINK_PATH" to "$lastModified"
ln -nsf $lastModified $SYMLINK_PATH

Force create a symbolic link without dereferencing named "alpha" to "alpha_2"
ln -nsf alpha_2 alpha

Force create a symbolic link without dereferencing named "mylink" to "dir2"
ln -nsf dir2 mylink

force create hard link between $GIT_DIR/../apresentacao/apresentacao.pdf and $GIT_DIR/../capa/apresentacao.pdf
ln -f $GIT_DIR/../apresentacao/apresentacao.pdf $GIT_DIR/../capa/apresentacao.pdf

Force decompress all files into '/etc'
gzip -d --force * /etc

Force delete all files in the current folder
find . | xargs -i rm -f "{}"

Force delete all files in the temp folder which have not been accesses in the last 240 hours
find /tmp/* -atime +10 -exec rm -f {} \;

Force delete all jpg files in current directory which are less than 50KB and do not search in the sub directories
find . -maxdepth 1 -name "*.jpg" -size -50k -exec rm {} \;

Force delete all jpg files in current directory which are less than 50KB and do not search in the sub directories
find . -maxdepth 1 -name "*.jpg" -size -50k | xargs rm -f

force delete all the directories the folder "test folder"
find 'Test Folder' -type d -print0 | xargs -0 rm -rf

force delete all the files in the current folder expect xml files
find . | grep -v xml | xargs rm -rf {}

force delete all the files that have been modified in the last 3 days
find . -mtime -3 -exec rm -rf {} \;

force delete all the files which have not been accessed in the last 240 hours in the temp folder
find /tmp/* -atime +10 -exec rm -f {} \;

force delete all the regular/normal files in the current folder
find . -type f -exec rm -fv {} \;

force delete all the temp files which are of size 0 bytes and which have not been accessed in the last 10 days
find /tmp -size 0 -atime +10 -exec rm -f {} \;

Force tty allocation and execute "./script.py" on host "foo"
ssh -tt foo ./script.py

sort each file in the bills directory, leaving the output in that file name with .sorted appended
find bills -type f -execdir sort -o '{}.sorted' '{}' ';'

sort each file in the bills directory, leaving the output in that file name with .sorted appended
find bills -type f | xargs -I XX sort -o XX.sorted XX

For each item in array "alpha", display the basename, that is the part following the last slash, or the whole item if no slash is present.
basename -a "${alpha[@]}"

For each line in file2 whose first field appears as a first field in file1, print an output line constructed following the specified -o format.
join -11 -21 -o1.1,1.2,1.3,2.3 file1 file2

For each line of colon-separated information in files 'empsal' and 'empname' whose first field matches in both files, output: first field of empname, second field of empname, fourth field of empname, and third field of empsal.
join -j 1 -t : -o 2.1,2.2,2.4,1.3 <(sort empsal) <(sort empname)

For each line of the sorted output of both file1 and file2, print lines whose first field of file2 does not appear as first field of file1.
join -v1 <(sort file1) <(sort file2)

For each line whose first field is the same in file1 and file2, output the common first field followed by all other fields in file1 and file2.
join -j1 file2 file1

For each line whose second field is the same in both files, output: first field of second file, second field of first file, and first field of second file.
$ join -j 2 -o 1.1 1.2 2.1 <(sort 1) <(sort -k2 2)

For each line whose second field is the same in both files, output: first field of second file, second field of first file, and first field of second file.
join -j 2  -o 1.1 1.2 2.1 <(sort -k2 1) <(sort -k2 2)

For each line which has a common first field in file1.csv and file2.txt, output the first 4 fields of file1.csv
join -o 1.1,1.2,1.3,1.4 -t, <(sort file1.csv) <(sort file2.txt)

For each line which has a common first field in file1.csv and file2.txt, output the first 4 fields of file1.csv - both files must be sorted first.
join -o 1.1,1.2,1.3,1.4 -t, file1.csv file2.txt

Sort file.txt ignoring the last 10 characters of each line.
sort file.txt | rev | uniq -f 10 | rev

Sort file "a.csv" by the first comma separated value of each line and print only unique entries
tac a.csv | sort -u -t, -r -k1,1 |tac

Sort file pointed by variable $filename, removing duplicate entries but ignoring the last N characters of each line.
rev $filename | sort | uniq -f=N | rev

Sort lines in "FILE" to standard output preserving only unique lines
sort -u FILE

Sort lines in "set1" and "set2" to standard output preserving only unique lines
sort -u set1 set2

Sort numerically and compare files "ruby.test" and "sort.test"
diff <(sort -n ruby.test) <(sort -n sort.test)

sort based on size and display top ten small normal/regular files in the current folder
find . -type f -exec ls -s {} \; | sort -n | head -10

Force pseudo tty allocation on connection to "somehost" and execute "~/bashplay/f"
ssh -t somehost ~/bashplay/f

Force pseudo-terminal allocation to run "sudo <cmd>" on "remotehost"
ssh -t remotehost "sudo <cmd>"

Force remove all files and folders in the physical current working directory
rm -rf "$(pwd -P)"/*

force remove all the c files in the current folder, print0 is used to handle all files with new lines in their names or files with only spaces in their name
find . -name "*.c" -print0 | xargs -0 rm -rf

force remove all the directories with the name logs in the folder /var/www
find /var/www -type d -mtime 0 -name logs -exec sudo rm -fr {} \;

force remove all the text files that have not been modified in the last 89 days
find .  -name "*.txt" -type f -daystart -mtime +89 | xargs rm -f

force remove all the regular/normal files which begin with sess in the temp folder
find /tmp -type f -name sess* -exec rm -f {} \;

Sort standard input in alphabetical order
sort

Sort the contents of file "ips.txt", eliminate duplicate entries, and prefix each entry with number of occurrences.
sort ips.txt | uniq -c

Force the group stickiness for directories under /var/www
find /var/www -type d -print0 | xargs -0 chmod g+s

Sort the lines of the file 'temp.txt' and change it in-place
sort temp.txt -o temp.txt

Sort the lines of the file 'temp.txt' and change it in-place
sort temp.txt -otemp.txt

Forcefully delete all files in the current directory
find . -name '*' | xargs rm

Forcefully delete all files in the current directory that begin with spam-
find . -name 'spam-*' | xargs rm

Forcefully remove files *~important-file
rm -rf *~important-file

forcibly and verbosely create a symbolic link named "target" to file "source"
ln -sfvn source target

forcibly and verbosely create symbolic links in directory "~/Library/LaunchAgents" to all files located in /usr/local/opt/mongodb/ and that have filename extension ".plist"
ln -sfv /usr/local/opt/mongodb/*.plist ~/Library/LaunchAgents

forcibly change owner to all files and directories in current directory to user www-data
sudo chown -Rf www-data *

forcibly create a symbolic link named "linkname" to file "new_destination"
ln -sf new_destination linkname

Forcibly create symlink named as '/cygdrive/c/Users/Mic/mypics' to the directory '/cygdrive/c/Users/Mic/Desktop/PENDING - Pics/'
ln -sf '/cygdrive/c/Users/Mic/Desktop/PENDING - Pics/' '/cygdrive/c/Users/Mic/mypics'

Forcibly removes files  '/tmp/stored_exception', '/tmp/stored_exception_line', '/tmp/stored_exception_source'
rm -f /tmp/stored_exception /tmp/stored_exception_line /tmp/stored_exception_source

Format "file.txt" as space separated columns 28 characters in width
cat file.txt | column -c 28 -s "\ "

Format and print the time string @133986838 according to the default time format
date --date @120024000

Format tab delimited file "list-of-entries.txt" as a table
column -t -s $'\t' list-of-entries.txt

Format tab separated fields in "FILE" as a table
column -t -s $'\t' FILE

Format contents of "file" as a table
paste -d" " - - < file | column -t

Reformat date "Sat Aug 09 13:37:14 2014 +1100" according to format string "%a %b %d %H:%M:%S %Y %z"
date -j -f "%a %b %d %H:%M:%S %Y %z" "Sat Aug 09 13:37:14 2014 +1100"

Format email message in file specified by "$2" to fit in 80 characters split at spaces and send to "$EMAIL" and a BCC to "abc@abc.com" from "$MAILBCC" with subject "$SUBJECT"
fold -s "$2" | mailx -s "$SUBJECT" -b "abc@abc.com" "$EMAIL" -r "$MAILBCC"

Format file "list-of-entries.txt" with no column delimiter
column -t -s '' list-of-entries.txt

Format output of "mount" as a table
mount | column -t

Format output of 'file' content to columns with wide not less than 80 pixels
cat file | column -c 80

Format space separated fields in "filename" as a table
column -t -s' ' filename

Format the 5th, 3rd, and 4th fields of "..." as a table
...| awk '{print $5"\t\t" $3"\t"$4}'|column -t

Format the contents of "[file]" in a neat table
cat file | column -t

Format the contents of "[file]" in a neat table
column -t [file]

Format the filename and modification time of files starting with t as a table
stat -c 'File: %n Modified: %y' t* | column -t

Format the filename and modification time of files starting with t as a table on OSX
stat -f 'File: %N Modified: %t%Sm' t* |column -t

Format the output of "..." as a tab separated table
... | column -s$'\t' -t

Format the output of "printf ..." to fit in 80 characters per line
printf ... | fold -w 80

Format the output of "rub-script.rb" as a tab separated table
ruby-script.rb | column -s $'\t' -t

Format the time string $timestamp according to the format string "%Y-%m-%d %H:%M:%S" and save the output to variable 'CDATE'
CDATE=$( date -d @"$timestamp" +"%Y-%m-%d %H:%M:%S" )

Format the time string @133986838 according to the default time format and save it to variable 'VARIABLENAME'
VARIABLENAME=$(date -d @133986838)

Format time string @1267619929 according to default time format
date -d @1267619929

Forward all connections to client localhost 3307 via the SSH tunnel to gateway and then connect to host 1.2.3.4 to port 3306
ssh -f user@gateway -L 3307:1.2.3.4:3306 -N

Forward all connections to client localhost 3309 via the SSH tunnel to "mysql_access_server" and then connect to host "sqlmaster.example.com" on port 3306
ssh -f mysql_access_server -L 3309:sqlmaster.example.com:3306 -N

Forward port 16186 on hello.com to 8888 on localhost using private key "privatekeystuffdis88s8dsf8h8hsd8fh8d" for login
ssh -N -i <(echo "privatekeystuffdis88s8dsf8h8hsd8fh8d") -R 16186:localhost:8888 hello.com

Forward port 3307 on localhost to port 3306 on 1.2.3.4 via 'user@gateway' on port 24222
ssh -f user@gateway -p 24222 -L 3307:1.2.3.4:3306 -N

Forward port 8000 bound on localhost to port 22 in 'clusternode' via 'user@bridge'
ssh -L localhost:8000:clusternode:22 user@bridge

Kill a running screen session
screen -X -S SCREENID kill

kill all active jobs
jobs -p | xargs kill -9

kill all background jobs
jobs -p | xargs kill

kill all background processes
kill -INT $(jobs -p)

Kill all instances of "dropbox" owned by the current user
killall -u "$(whoami)" dropbox

kill all jobs
kill $(jobs -p)

Kill all processes which were executed in background by the current shell.
jobs -p | xargs kill -9

kill group leader
kill `jobs -lp`

Rank the usage of libraries for a set of tools "/bin/* /usr/bin/* ..."
ldd /bin/* /usr/bin/* ... | sed -e '/^[^\t]/ d; s/^\t\(.* => \)\?\([^ ]*\) (.*/\2/g' | sort | uniq -c

generates a list of all files beneath the current directory whose filename DOES NOT end in .html, so it matches files like *.txt, *.jpg, and so on.
find . -type f -not -name "*.html"

Generate a random 32 ASCII character password from /dev/urandom and save it to variable 'pass'
pass=$(LC_CTYPE=C < /dev/urandom tr -cd [:graph:] | tr -d '\n' | fold -w 32 | head -n 1)

Generates a randomly sorted list of numbers from 1 to 10.
seq 1 10 | sort -R | tee /tmp/lst |cat <(cat /tmp/lst) <(echo '-------') \ <(tac)

Generates default-formatted file name of temporary file in a /dev/mapper folder, and saves path to it in a variable 'MAPPER'.
MAPPER=$(mktemp -up /dev/mapper)

Generate HTML <a> links to files under the /public/html/cosi directory tree whose name is "wiki.phtml"
find /public/html/cosi -name "wiki.phtml -exec echo "<a href=\"{}\">{}</a>" \;

Generates name for temporary file with 6-letter suffix, and saves path to that new file in 'fn' variable.
fn=$(mktemp -u -t 'XXXXXX')

Generates temporary file in a '/dev/shm' folder and saves path to it in a 'tFile' variable.
tFile=$(mktemp --tmpdir=/dev/shm)

Generates temporary file name with full path by template 'fifo.XXXXXX' and saves it to variable 'fifo_name'
fifo_name=$(mktemp -u -t fifo.XXXXXX)

Generate the Spanish alphabet and number each character
echo -e {{a..n},ñ,{o..z}}"\n" | nl

Generate UUIDs for the files from the current directory tree
find -printf "%P\0" -exec uuid -v 4 \; | sort | awk -F'\0' '{ print $2 " " $1}'

Generate UUIDs for the files from the current directory tree
find -printf "%P\n"| sort | xargs -I '{}' bash -c 'echo $(uuid) {}'

Generate UUIDs for the files from the current directory tree
find . -exec printf '%s\t' {} \; -exec uuidgen \; | awk -F '\t' '{ sub(/.+\//,"", $1); print $2, $1 }' | sort -k2

Generate UUIDs for the files from the current directory tree
find . -printf "%P\0" | sort -z | while IFS= read -d '' -r f; do echo "$(uuid) $f"; done

Generate UUIDs for the files from the current directory tree
find . -printf "%P\n" | sort | while IFS= read -r f; do echo "$(uuid) $f"; done

Set 444 permission to all regular files under current directory
find . -type f -print | xargs chmod 444

Set 644 permission to all regular files under /home/my/special/folder directory
chmod 644 `find /home/my/special/folder -type f`

set a crontab to create or update the timestamp of "washere2" in the current directory every 30 minutes.
echo "30 * * * * touch $(pwd)/washere2" | crontab

Gets a current job back to the foreground.
fg

Get a detailed list of all files on the system larger than 10MB
find / -size +10M -printf “%12s %t %h/%fn”

Get a detailed listing of all symbolic links in /usr/bin starting with "z"
find /usr/bin  -type l  -name "z*" -exec ls  -l {} \;

Gets a job with defined number back to the foreground.
fg 1

Get a list of all files in the /home directory tree and their coressponding inode numbers
find /home -type f -printf "%i@%p\n"

Get a list of directories owned by group ID 100
find / -type d -gid  100

Get a path name of a process id
ps -p 24297 -o comm --no-heading

get a PID of a process
jobs -x echo %1

Get A record for domain $domain
dig $domain

Get A record for domain $domain
dig -t A $domain

Get a recursive file list of directory $dir
find "$dir" -type f

Get a recursive file list of directory $dir
find $dir -type f

Set a screen session title when invoked
screen -X title "new title"

Set a title of a remote screen session
screen -S SessionName -p 0 -X title "remote_0"

Gets all man entries beginning with std and sends them to vi.
apropos -r '^std' | vi -

get all files in a current directory modified in the last 7 days
find . -mtime -7 -print0 | xargs -0 tar -cjf /foo/archive.tar.bz2

get all files in a current directory modified in the last 7 days
find . -mtime -7 -print0 | xargs -0 tar -rf /foo/archive.tar

get all files in a current directory modified in the last day
find . -mtime -1 | xargs tar --no-recursion -czf myfile.tgz

get all files in a current directory modified in the last day and a half
find . -mtime -1.5 | xargs tar --no-recursion -czf myfile.tgz

Gets all IP addresses from host network configuration and prints first one.
ifconfig | grep "inet addr:" | grep -v "127.0.0.1" | grep -Eo '[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}'  | head -1

get all the files that are exactly 30 days old
find . -mtime 30 -print

set alias ".." for command "cd .."
alias ..='cd ..'

set alisa "12np" for command 'ssh mydomain\\stephencheng@userxyz@host.com'
alias 12np='ssh mydomain\\stephencheng@userxyz@host.com'

set alias "X" for command "| cut -d' ' -f2"
alias -g X="| cut -d' ' -f2"

set alias "X2" for command "| cut -d' ' -f2"
alias -g X2="| cut -d' ' -f2"

set alias "c1" for command "awk '{print \$1}'"
alias c1="awk '{print \$1}'"

set alias "cats" for command 'konqueror http:'//icanhazcheezburger.com''
alias cats='konqueror http:'//icanhazcheezburger.com''

set alias "cd-" for command 'cd $(history -p !!:1)'
alias cd-='cd $(history -p !!:1)'

set alias "cd-" for command 'cd ${${(z)$(fc -l -1)}[3]}'
alias cd-='cd ${${(z)$(fc -l -1)}[3]}'

set alias "cdl" for command 'cd -- "$(ls -t | head -n 1)"'
alias cdl='cd -- "$(ls -t | head -n 1)"'

set alias "cleanup" for command "rm -Rf -- foo bar baz"
alias cleanup='rm -Rf -- foo bar baz'

set alias "cleanup" for command 'rm -Rf `pwd`/{foo,bar,baz}'
alias cleanup='rm -Rf `pwd`/{foo,bar,baz}'

set alias "current" for command 'cd $(cur -g)'
alias current='cd $(cur -g)'

set alias "devn" for command "cat > /dev/null"
alias devn='cat > /dev/null'

set alias "dosetit" for command 'eval `setit-sh`'
alias dosetit='eval `setit-sh`'

set alias "foo" for command "$'echo A \'*\' is born at $(date)'"
alias foo=$'echo A \'*\' is born at $(date)'

set alias "foo" for command "BAR=baz"
alias foo=BAR=baz

set alias "git-root" for command "if [ "`git rev-parse --show-cdup`" != "" ]; then cd `git rev-parse --show-cdup`; fi"
alias git-root='if [ "`git rev-parse --show-cdup`" != "" ]; then cd `git rev-parse --show-cdup`; fi'

set alias "git-root" for command 'cd $(git rev-parse --show-cdup)'
alias git-root='cd $(git rev-parse --show-cdup)'

set alias "go" for command 'GOPATH=$(infer-gopath.sh) go'
alias go='GOPATH=$(infer-gopath.sh) go'

set alias "go" for command 'ssh $(pbpaste) -l pete'
alias go='ssh $(pbpaste) -l pete'

set alias "h" for command "history"
alias h='history'

set alias "histgrep" for command "history | grep"
alias histgrep="history | grep"

set alias "iTMSTransporter" for command '`xcode-select --print-path`/../Applications/Application\ Loader.app/Contents/MacOS/itms/bin/iTMSTransporter'
alias iTMSTransporter='`xcode-select --print-path`/../Applications/Application\ Loader.app/Contents/MacOS/itms/bin/iTMSTransporter'

set alias "j7" for command 'JAVA_HOME=`/usr/libexec/java_home -v 1.7`'
alias j7='JAVA_HOME=`/usr/libexec/java_home -v 1.7`'

set alias "logspace" for command "find /apps/ /opt/ -type f -size +100M -exec ls -lh {} \; | awk '{print $5, $9 }'"
alias logspace="find /apps/ /opt/ -type f -size +100M -exec ls -lh {} \; | awk '{print $5, $9 }'"

set alias "logspace" for command 'find /apps/ /opt/ -type f -size +100M -exec ls -lh {} \; |  awk '\''{print $5, $9 }'\'''
alias logspace='find /apps/ /opt/ -type f -size +100M -exec ls -lh {} \; |  awk '\''{print $5, $9 }'\'''

set alias "ls" for command "ls -lrta"
alias ls='ls -lrta'

set alias "ls" for command 'ls -a -l'
alias la='ls -a -l'

set alias "lvim" for command "vim -c \"normal '0\""
alias lvim="vim -c \"normal '0\""

set alias "mkcd" for command '_(){ mkdir $1; cd $1; }; _'
alias mkcd='_(){ mkdir $1; cd $1; }; _'

set alias "mkdir" for command ¨mkdir -p¨
alias mkdir=¨mkdir -p¨

set alias "my_command" for command "$oldalias --fail-if-command-contains=$bad_string"
alias my_command="$oldalias --fail-if-command-contains=$bad_string"

set alias "my_command" for command "$oldalias -option 3"
alias my_command="$oldalias -option 3"

set alias "no" for command "ls -f"
alias no=ls -f

set alias "prettify_json" for command "php -E '$o = json_decode($argn); print json_encode($o, JSON_PRETTY_PRINT);'"
alias prettify_json=php -E '$o = json_decode($argn); print json_encode($o, JSON_PRETTY_PRINT);'

set alias "prettyjson" for command 'python -m json.tool'
alias prettyjson='python -m json.tool'

set alias "ps" for command 'screen -d -m okular'
alias -s ps='screen -d -m okular'

set alias "psgrep" for command "ps -ef | grep"
alias psgrep="ps -ef | grep"

set alias "pwd" for command "echo -n $(/bin/pwd) | pbcopy'"
alias pwd='echo -n $(/bin/pwd) | pbcopy'

set alias "pwd" for command "echo -n `pwd` | pbcopy"
alias pwd='echo -n `pwd` | pbcopy'

set alias "pwd" for command '/bin/pwd | pbcopy'
alias pwd='/bin/pwd | pbcopy'

set alisa "py" for command "$EDITOR"
alias -s py=$EDITOR

set alias "py" for command "python2.5 -O"
alias py='python2.5 -O'

set alias "s" for command 'it=$($(history | tail -2 | head -1 | cut -d" " -f4-))'
alias s='it=$($(history | tail -2 | head -1 | cut -d" " -f4-))'

set alias "te" for command 'tail -f /var/log/apache2/error_log | perl -ne '\''...'\'''
alias te='tail -f /var/log/apache2/error_log | perl -ne '\''...'\'''

set alias "unix" for command "date +%s"
alias unix="date +%s"

set alias "unix" for command 'echo $(date +%s)'
alias unix='echo $(date +%s)'

set alias "unsetvar" for command 'source /your/path/to/the/script/unsetvar'
alias unsetvar='source /your/path/to/the/script/unsetvar'

set alias "vimrc" for command "$EDITOR ~/.vimrc"
alias vimrc='$EDITOR ~/.vimrc'

set alias "vv" for command "$(date)"
alias -g vv="$(date)"

set alias "webshare" for command 'python -m SimpleHTTPServer'
alias webshare='python -m SimpleHTTPServer'

set alias "your_env" for command 'source ~/scripts/your_env.sh'
alias your_env='source ~/scripts/your_env.sh'

Set LANG variable to 'en_US' and prints calendar for a current month.
LANG=en_US cal

Gets MAC address of 'eth0' network interface.
ifconfig eth0 | grep -Eo ..\(\:..\){5}

Gets MAC address of 'eth0' network interface.
ifconfig eth0 | grep -o -E '([[:xdigit:]]{1,2}:){5}[[:xdigit:]]{1,2}'

Gets MAC address of 'eth0' network interface.
ifconfig eth0 | head -n1 | tr -s ' ' | cut -d' ' -f5

Gets MAC address of 'eth0' network interface.
x=$(ifconfig eth0) && x=${x#*HWaddr } && echo ${x%% *}

Gets MAC address of eth0 network interface.
ifconfig eth0 | grep -Eoi [:0-9A-F:]{2}\(\:[:0-9A-F:]{2}\){5}

Gets MAC address of eth0 network interface.
ifconfig eth0 | grep HWaddr | cut -d ' ' -f 9

Gets MAC address of eth0 network interface.
ifconfig | grep -i hwaddr | cut -d ' ' -f9

Gets MAC address of p2p0 network interface.
ifconfig p2p0 | grep -o -E '([[:xdigit:]]{1,2}:){5}[[:xdigit:]]{1,2}'

Get from file 'File1.txt' strings starting with 'Q', extract only part of them following after '=' sign, and print which ones are not found in 'File2.txt'
grep ^Q File1.txt | cut -d= -f2- | sort | comm -23 - <(sort File2.txt)

Get current directory name without full path, ie. the part after the last /
basename "$(pwd)"

Get current hosts's IPv4 address.
host $(uname -n) | grep "address" | grep -v "IPv6" | head -n 1 | awk '{print $4}'

Get current host's IPv6 address.
host $(uname -n) | grep "IPv6 address" | head -n 1 | awk '{print $5}'

Get directory listing of URL $1 and save them to variable 'header' by deleting '\r' characters
header="$(curl -sI "$1" | tr -d '\r')"

Get domain "$domain" IP address
dig +short "$domain"

Get domain name from dig reverse lookup.
$dig -x 8.8.8.8 | grep  PTR | grep -o google.*

Gets domain name from dig reverse lookup.
$dig -x 8.8.8.8 | grep  PTR | grep -o google.*

Gets domain name from dig reverse lookup.
dig -x 8.8.8.8 | grep PTR | cut -d ' ' -f 2 | grep google | cut -f 5

Get domain names from file '1.txt' and request TXT DNS record for each one
cat 1.txt | xargs dig TXT

Get domain name with 'google' from address $1
dig -x "$1" | grep PTR | cut -d ' ' -f 2 | grep google | cut -f 5

Gets back to the foreground a job with number 2.
fg 2

Get files that last had their meta information changed more than 3 days ago
find / -ctime +3

Set file permission to 664 and directory permission to 775 for all files and directories under htdocs
find htdocs -type f -exec chmod 664 {} + -o -type d -exec chmod 775 {} +

get info about "lbzip2\|plzip\|pigz" from tar command
tar --help | grep "lbzip2\|plzip\|pigz"

Gets IP address of 'en0' network interface.
ip addr show en0 | awk '$1 == "inet" {gsub(/\/.*$/, "", $2); print $2}'

Gets IP address of 'eth0' network interface.
ifconfig eth0 | grep -oP '(?<= inet addr:)[^ ]+'

Gets IP address of 'eth0' network interface.
ifconfig eth0 | grep inet | cut -d: -f2 | cut -d' ' -f1

Gets IP address of a primary network interface.
/sbin/ifconfig $(netstat -nr | tail -1 | awk '{print $NF}') | awk -F: '/inet /{print $2}' | cut -f1 -d ' '

Gets IP addresses of all active network interfaces.
ifconfig | grep -oP "(?<=inet addr:).*?(?=  Bcast)"

Gets IP addresses of all active network interfaces.
ifconfig | grep -oP "(?<=inet addr:).*?(?=Bcast)"

Gets IP address of first listed network interface in system.
ifconfig | grep 'inet addr:' | grep -v 127.0.0.1 | head -n1 | cut -f2 -d: | cut -f1 -d ' '

Gets IP address of only primary network interface.
ifconfig $(netstat -rn | grep -E "^default|^0.0.0.0" | head -1 | awk '{print $NF}') | grep 'inet ' | awk '{print $2}' | grep -Eo '([0-9]*\.){3}[0-9]*'

Gets IP address of only primary network interface.
ifconfig `ip route | grep default | head -1 | sed 's/\(.*dev \)\([a-z0-9]*\)\(.*\)/\2/g'` | grep -oE "\b([0-9]{1,3}\.){3}[0-9]{1,3}\b" | head -1

Gets list of folders containing files with changes.
git diff --name-only | xargs dirname | uniq

Gets list of IP addresses of all network interfaces.
/sbin/ifconfig  | sed -ne $'/127.0.0.1/ ! { s/^[ \t]*inet[ \t]\\{1,99\\}\\(addr:\\)\\{0,1\\}\\([0-9.]*\\)[ \t\/].*$/\\2/p; }'

Gets list of IP addresses of all network interfaces.
ifconfig | grep -Eo 'inet (addr:)?([0-9]*\.){3}[0-9]*' | grep -Eo '([0-9]*\.){3}[0-9]*' | grep -v '127.0.0.1'

Get only the latest version of file from the 'custlist*' files under current directory
find . -name custlist\* | perl -ne '$path = $_; s?.*/??; $name = $_; $map{$name} = $path; ++$c; END { print $map{(sort(keys(%map)))[$c-1]} }'

Get only the latest version of the file 'filename' under current directory
find . -name 'filename' | xargs -r ls -tc | head -n1

Set permissions for all direcotries under /var/www to 755
find /var/www -type d -print0 | xargs -0 chmod 755

Set permissions for all regular files under /var/www to 755
find /var/www -type f -print0 | xargs -0 chmod 644

Set permissions for directories in `foldername' and its subdirectories to 755
find foldername -type d -exec chmod 755 {} ";"

Set permissions for files in `foldername' and its subdirectories to 644
find foldername -type f -exec chmod 644 {} ";"

Set permissions for files in `foldername' to 777
find foldername -exec chmod a+rwx {} ";"

Set permission of "file" to read only for the owner
chmod 600 file

Set permissions of all directories under "/opt/lampp/htdocs" to 711
find /opt/lampp/htdocs -type d -exec chmod 711 {} \;

Set permissions of all directories under "/opt/lampp/htdocs" to 755
find /opt/lampp/htdocs -type d -exec chmod 755 {} \;

Set permissions of all directories under "/path/to/base/dir" to 755
chmod 755 $(find /path/to/base/dir -type d)

Set permission of all files in "img", "js", and "html" to 644
chmod 644 img/* js/* html/*

Set permissions of all files under "/opt/lampp/htdocs" to 644
find /opt/lampp/htdocs -type f -exec chmod 644 {} \;

Set permissions of command "node" to 755
sudo chmod 755 $(which node)

Set permissions to 2770 for all directories in the current directory tree
find . -type d -exec chmod 2770 {} +

Set permissions to 400 for regular files under the current directory
find . -type f -exec chmod 400 {} \;

Set permissions to 500 for directories under the current directory
find . -type d -exec chmod 500 {} \;

Set permissions to 644 for all regular files under the current directory tree that have permissions 755
find . -type f -perm 755 -exec chmod 644 {} \;

Set permissions to 700 for directories under var/
find var/ -type d -exec chmod 700 {} \;

Set permissions to 700 for every subdirectory of the current directory
find . -mindepth 1 -type d -print0 | xargs -0 chmod -R 700

Set permissions to 755 for every subdirectory of the current directory
find  . -type d -mindepth 1 -print -exec chmod 755 {}/* \;

Set permissions to ug=rw,o= for files under the $d directory tree
find $d -type f -exec chmod ug=rw,o= '{}' \;

Set permissions to ug=rw,o= for files inside the ./default/files tree
find ./default/files -type f -exec chmod ug=rw,o= '{}' \;

Set permissions to ug=rwx,o= for directories inside the ./default/files tree
find ./default/files -type d -exec chmod ug=rwx,o= '{}' \;

Set prompt to the system host name and history number
PS1="`hostname`:\!>"

Set read, write and execute permission for all (owner, group, other) for the files/directories in foldername directory tree
sudo find foldername -exec chmod a+rwx {} ";"

Get second line from text contained in variable $data.
echo "$data" | cut -f2 -d$'\n'

get second-to-last comma-separated field of each line in file.txt
cat file.txt | rev | cut -d ',' -f 2 | rev

Set shell option 'checkwinsize'.
shopt -s checkwinsize

Set shell option 'dotglob'.
shopt -s dotglob

Set shell option 'histverify'.
shopt -s histverify

Gets state of shell option 'dotglob' and saves it in 'rest_cmd' variable.
rest_cmd=$(shopt -p dotglob)

Gets string with MAC address of eth0 network interface.
ifconfig eth0 | grep HWaddr

Gets string with MAC addess of network interface eth0.
ifconfig eth0 | grep HWaddr

Gets string with IP4 address of en0 network interface.
ifconfig en0 | grep inet | grep -v inet6

Get the actual find exectuable path
which find

Get the command line args passed to a running process
ps -fp <pid>

get the count of all the files that have been accessed in the last 30 days
find . -atime +30 -exec ls \; | wc -l

Get the current shell's executable name from the output of 'ps'.
ps -p $$ | awk '$1 == PP {print $4}' PP=$$

Get the disk space used by all *.txt (case insensitive) files/directories under /path directory
find /path -iname '*.txt' | perl -lane '$sum += -s $_; END {print $sum}'

Get the directory with least access time under current directory
find . -type d -printf "%A@ %p\n" | sort -n | tail -n 1 | cut -d " " -f 2-

Set the environment variable "DISPLAY" to the system host name followed by ":0 skype"
DISPLAY=`hostname`:0 skype

Set the environment variable "DISPLAY" to the system host name followed by ":0 skype"
env DISPLAY=`hostname`:0 skype

Get the base filename from variable 'path', similar to using the basename command.
echo "$path" | rev | cut -d"/" -f1 | rev

Set the executable bit for all users on all .sh scripts from directory trees lib, etc, debian
find lib etc debian -name "*.sh" -type f | xargs chmod +x

See what files are executable by the file's owner and group
find -type f -perm -110

get the git user access
su git

Get the grandparent directory of each found 'pattern' file in $SEARCH_PATH
find "$SEARCH_PATH" -name 'pattern' | rev | cut -d'/' -f3- | rev

Set the group to "username" for all files with GID=1000 in the current directory tree
find -gid 1000 -exec chown -h :username {} \;

Gets the groups these users belong to.
groups a b c d

Set the history time format variable "HISTTIMEFORMAT" to "%s " and display up to event 2
HISTTIMEFORMAT="%s " history 2

get the jenkins user access
sudo su - jenkins

get the job number from the stored PID
jobs -l | fgrep $! | perl -ne 'print "$1\n" if /\[(\d+)\]/'

Get the list of files owned by <userid>
find . -user <userid>

Get the list of regular files in the current directory
find . -mindepth 1 -maxdepth 1 -type f -print0 | xargs -0 -I {} echo "{}"

Set the modification timestamp of file 'filename' to specified date/time.
touch -m --date="Wed Jun 12 14:00:00 IDT 2013" filename

Set the host name to "myServersHostname"
hostname myServersHostname

Set the host name to the contents of "/etc/hostname"
hostname $(cat /etc/hostname)

Get the number of "use" statements in all PHP files, ordered
find . -type f -name "*.php" -exec grep --with-filename -c "^use " {} \; | sort -t ":" -k 2 -n -r

Get the number of regular files in the directory given as the bash script argument $1
find $1 -type f | wc -l

Get the path of running Apache
ps -ef | grep apache

Set the permissions of all directories inside the current directory tree to u=rwx,g=rx,o=x
find . -type d -exec chmod u=rwx,g=rx,o=x {} \;

Set the permissions of all directories inside the current directory tree to ug=rwx,o=
find . -type d -name files -exec chmod ug=rwx,o= '{}' \;

Get the processor's addressing bus width from the output of "lshw", ie. "64 bits".
lshw -class cpu|grep "^       width"|uniq|awk '{print $2}'

Set the prompt to "title: (hostname)"
export PS1='\[\e]0;`hostname`\a\]${debian_chroot:+($debian_chroot)}\u@\h:\w\$ '

get the root user access
sudo su

Set the setgid bit on all directories in the repository "/git/our_repos"
find /git/our_repos -type d -exec chmod g+s {} +

Set the setup connection timeout to 10 seconds for connecting to "<hostName>" via ssh
ssh -o ConnectTimeout=10  <hostName>

Set the setup connection timeout to 3 seconds for connecting to "user@ip" via ssh
ssh -o ConnectTimeout=3 user@ip

Get the sizes (and total size) of all files under dir1 directory
find dir1 ! -type d |xargs wc -c

Set the shell prompt to "host:pwd>"
PS1=`hostname`':\W> '

Set the system date to Sat May 11 06:00:00 IDT 2013
sudo date --set="Sat May 11 06:00:00 IDT 2013"

Get the total size of all files under dir1 directory
find dir1 ! -type d |xargs wc -c |tail -1

Let the user page through 'filename.csv' with long lines chopped so they fit within the width of the screen/window.
csvtopretty filename.csv | less -S

Set the value of "to_sort" to "$1" in a subshell which no longer exists after the pipeline completes
echo "$1"| read -a to_sort

Set the variable "me" to the name of the running script.
me=`basename "$0"`

Set the variable "me" to the name of the running script, or shell, login shells have a hyphen appended to the beginning of the name, such as "-bash".
me=`basename -- "$0"`

Set timestamp of all PHP files in current directory to date specified.
touch -d '30 August 2013' *.php

Set timestamp of old_file.dat to specified timestamp.
touch -t 200510071138 old_file.dat

Set up a remote port forward from port 10022 on host "server" to port 22 on localhost
ssh -R 10022:localhost:22 device@server

Set up local port forwards in the background with no terminal or command execution from port 4431 to host "www1" port 443 and port 4432 to host "www2" port 443 via the host "colocatedserver"
ssh -fNT -L4431:www1:443 -L4432:www2:443 colocatedserver

Set up SSH connection forwarding in the background with no terminal or command execution from localhost port 8888 to "proxyhost" port 8888 and a reverse connection from "officefirewall" port 22222 to "localhost" port 22
ssh -fNT -L8888:proxyhost:8888 -R22222:localhost:22 officefirewall

Set trace prompt to print seconds, nnoseconds, script name, and line number
PS4='+$(date "+%s:%N") %N:%i> '

Set trace prompt to print seconds.nanoseconds
PS4='+ $(date "+%s.%N")\011 '

set value of the variable "cmdstr" to the value of the alias  "$aliascmd"
cmdstr=$(alias $aliascmd | cut -d"'" -f2 | xargs)

Set variable "architecture" to machine architecture, ie. x86_64
architecture="$(uname -m)"

Set variable "extract_dir" to list of top-level directories and files contained in tar archive specified by variable FILE.
extract_dir=$(tar -tf $FILE | cut -d/ -f1 | uniq)

Set variable "filename" to only the name of document specified by URL, in this case "pic.jpg"
filename="`basename "http://pics.sitename.com/images/191211/pic.jpg"`"

Set variable "fname" to the basename of path specified in variable "f", that is remove everything up to the last slash if present.
fname=`basename $f`

Set variable 'file' to the base name of first argument to script or function, that is the part following the last slash.
file=$( basename "$1" )

Set variable 'file' to the base name of first argument to script or function, that is the part following the last slash.
file=`basename "$1"`

Set variable 'path' to name of current directory (without the containing directories).
path=$(basename $(pwd))

Set variable 'path' to name of current directory (without the containing directories) converted to lowercase.
path=$(basename $(pwd) | tr 'A-Z' 'a-z' )

Set variable 'rav' to the contents of 'var' spelled backwards.
rav=$(echo $var | rev)

Set variable BZIP2_CMD to the full path of command "bzip2"
BZIP2_CMD=`which bzip2`

Set variable MYPROGRAMNAME_KERNEL_VERSION to current kernel release name, making this variable visible by subprocesses of current shell.
export MYPROGRAMNAME_KERNEL_VERSION=$(uname -r)

Set variable OS to the name of the operating system, ie. "Linux"
OS=$(uname -s)

Set variable OS to the name of the operating system, ie. "Linux"
OS=`uname -s`

Set variable PacketLoss to first digit of percentage of packet loss occurring when pinging host specified by TestIP
PacketLoss=$(ping "$TestIP" -c 2 | grep -Eo "[0-9]+% packet loss" | grep -Eo "^[0-9]")

Set variable PING to 1 if it's possible to ping host ADDRESS, to 0 otherwise.
PING=$(ping ADDRESS -c 1 | grep -E -o '[0-9]+ received' | cut -f1 -d' ')

set variable r to currently running kernel release, ie. 4.4.0-81-generic
r="$(uname -r)"

Set variable GZIP to the full path of command "gzip"
GZIP="$(which gzip)"

set MyVariable to the value of VARIABLE_NAME
myVariable=$(env  | grep VARIABLE_NAME | grep -oe '[^=]*$');

Get virtual private memory use of process
top -l 1 -s 0 -i 1 -stats vprvt -pid PID

Get virtual private memory use of process
top -l 1 -s 0 -stats mem -pid PID

Get virtual private memory use of process
top -l 1 -s 0 -stats vprvt -pid 8631

get year-month-day from date
date +%Y-%m-%d

get year-month-day hour:minute:second from date
date +%Y-%m-%d:%H:%M:%S

Grab the output of "basename" (in this case "stuff") and echo it to stdout, which basename would do by default anyway.
echo $(basename /foo/bar/stuff)

Grab the output of "basename" (the last slash-separated section of variable "filename") and echo it to stdout, which basename would do by default anyway.
echo `basename "$filename"`

Globally sets the maximum number of lines to held in window history as 10000.
tmux set -g history-limit 10000

Globally sets the maximum number of lines to held in window history as 10000.
tmux set-option -g history-limit 10000

Go into the directory whose name is selected in the X window system, ie. double-clicked in a terminal window.
cd "$(xsel)"

Go into the directory whose name is selected in the X window system, ie. double-clicked in a terminal window.
cd "`xsel`"

Go into the first directory whose name contains 1670
cd $(ls -d */ | grep 1670)

Go into the first directory whose name contains 1670
cd `find . -maxdepth 1 -type d | grep 1670`

Go into the first directory whose name contains 1670
cd `ls -d */ | grep 1670`

Go to /the/project/root//data, which in most filesystems/operating systems will be the same as cd /the/project/root/data
cd /the/project/root//data

Go to /tmp directory.
cd /tmp

Go to directory /cygdrive/c/Program Files (x86) using quotes to escape special characters
cd "/cygdrive/c/Program Files (x86)"

Go to directory /some/where/long
cd /some/where/long

Go to directory pointed by last element of array "dirs" in bash version 4.2
cd "${dirs[-1]}"

Go to first directory specified in PATH which contains the command 'oracle'
cd $(dirname $(which ls))

Go to first directory specified in PATH which contains the command 'oracle'
cd $(which oracle | xargs dirname)

Go to last directory with name starting with a number, useful for timestamped directory names.
cd "$(ls -rd [0-9]*/ | tail --lines 1)"

Go to previous working directory.
cd -

Unzip "$ip" as input to "pax -r"
gunzip -c -d $ip | pax -r

Unzip "archive.tgz" and extract all archives excluding ones matching "apri/fls/filename"
zcat archive.tgz | tar -x --wildcards apri/fls/filename

Unzip "bigfile.txt.gz" to standard output, search for patterns in "patterns.txt", and list the unique matches
gunzip -c bigfile.txt.gz | grep -f patterns.txt | sort | uniq -c

Unzip "daily_backup.sql.gz" and search for lines matching "'x'|/x/"
zcat daily_backup.sql.gz| grep -E "'x'|/x/"

Unzip "file.gz" and print each line with the 2nd | separated field greater than 5
zcat a.csv.gz | gawk '$2>5' FPAT='[^"|]+'

Unzip "file.gz", list the unique first comma separated field prefixed by the number of occurrences, sort from least frequent to most frequent
zcat file.gz | cut -f1 -d, | sort | uniq -c | sort -n

Unzip "file.gz" to standard output and execute in bash with arguments "-n wordpress"
gzip -d --stdout file.gz | bash -s -- "-n wordpress localhost"

Unzip "file.gz" to standard output and execute in bash with arguments "arguments"
gzip -d --stdout file.gz | bash /dev/stdin "arguments"

Unzip "large.csv.gz" and save every 1000 lines into a file with prefix "xxx"
gzcat large.csv.gz | split -l 1000 - xxx

Unzip "myDB.sql.gz" to standard output as input to "pg_restore ..."
gzip -cd myDB.sql.gz | pg_restore ...

Unzip "some.file.gz" to standard output
gunzip < some.file.gz

Unzip all ".gz" files in the current directory tree excluding files containing "dvportgroups", "nsanity", "vcsupport", "viclient", and "vsantraces"
find . -name '*.gz' ! -name '*dvportgroups*' ! -name '*nsanity*' ! -name '*vcsupport*' ! -name '*viclient*' ! -name 'vsantraces*' -exec gunzip -vf {} \;

Unzip all ".gz" files in the current directory tree to their respective directories
find . -name "*.gz" -execdir gunzip '{}' \;

Unzip all *.zip files below the current directory
find -name '*.zip' | xargs -n 1 unzip

Unzip all *.zip files under current directory
find . -name '*.zip' -exec unzip '{}' ';'

Unzip all *.zip files under current directory
find . -name '*.zip' | xargs -n1 unzip

unzip and search for a word in all the jar files in the current folder and display the matched file name
find . -iname '*.jar' -printf "unzip -c %p | grep -q '<stringWithOrWithoutSpacesToFind>' && echo %p\n" | sh

Unzip and expand tar archive "compressFileName"
zcat compressFileName | tar xvf -

Unzip all files matching "/homes/ndeklein/mzml/*.gz"
ls /homes/ndeklein/mzml/*.gz | xargs -I {} gunzip {}

Unzip all files matching "file_*" and pipe into "agrep -dEOE 'grep'"
find -name 'file_*' -follow -type f -exec zcat {} \; | agrep -dEOE 'grep'

Unzip all files matching "file_*" and pipe into "agrep -dEOE 'grep'"
find . -name "file_*" -follow -type f -print0 | xargs -0 zcat | agrep -dEOE 'grep'

Unzip all files matching "test1/*/*.gz"
gunzip test1/*/*.gz

Unzip all files that match "*.gz" in the current directory and subdirectories to stdout and search for "test"
find . -name "*.gz" -exec zcat "{}" + |grep "test"

Gunzip all files matching "file*.gz" and answer "n" to any prompts
yes n | gunzip file*.gz

unzip all zip files in current folder
find -name '*.zip' | xargs -n 1 unzip

Unzip and write "backup.img.gz" to "/dev/sdb"
cat backup.img.gz | gunzip | dd of=/dev/sdb

Unzip and untar "4.56_release.tar.gz" to standard output
gunzip -c 4.56_release.tar.gz | tar xvf -

Unzip and untar "file.tar.gz"
zcat file.tar.gz |tar x

Unzip and untar "myarchive.tar.gz" and check for corruption
gunzip -c myarchive.tar.gz | tar -tvf -

Unzip and untar "openssl-fips-2.0.1.tar.gz"
gunzip -c openssl-fips-2.0.1.tar.gz | tar xf ­-

Unzip and untar "tarball.tar.gz"
zcat tarball.tar.gz | tar x

Ungzip and untar all files matching "www-backup.tar.*"
cat www-backup.tar.*|gunzip -c |tar xvf -

Unzip every ".gz" file in the current directory
gunzip *.gz

Unzip every ".gz" file in the current directory tree
find . -name "*.gz" | xargs gunzip

Unzip every ".gz" file in the current directory tree
find . -name '*.gz' -exec gunzip '{}' \;

Unzip files "file1.gz" and "file2.gz" as arguments to "command -1 -2"
command -1 <(gzip -dc file1.gz) -2 <(gzip -dc file2.gz)

Unzip file "$empty_variable"
gunzip $empty_variable

Append " | COUNTRY" to every line in "file"
yes '| COUNTRY' | sed $(wc -l < file)q | paste -d ' ' file -

Append ".txt" to all filenames in the current directory tree
find -type f | xargs -I {} mv {} {}.txt

Append "deb blah ... blah" to "/etc/apt/sources.list" as root
echo 'deb blah ... blah' | sudo tee --append /etc/apt/sources.list > /dev/null

Append *.java files from the current directory tree to tar archive `myfile.tar'
find . -type f -name "*.java" | xargs tar rvf myfile.tar

Append all *.mp3 files modified within the last 180 days to tar archive `music.tar'
find . -name -type f '*.mp3' -mtime -180 -print0 | xargs -0 tar rvf music.tar

Append all PNG and JPG files to tar archive 'images.tar'
find . \( -iname "*.png" -o -iname "*.jpg" \) -print -exec tar -rf images.tar {} \;

Append history lines from this session to the history list
history -a

Append the contents of "file.txt" to the current in-memory history list
history -r file.txt

Append the current date in '%d%m%Y-%H-%M' format, '_' and the current username, then save it in 'name' variable
name="$(date +'%d%m%Y-%H-%M')_$(whoami)"

Append the current date to variable 'LBUFFER'
LBUFFER+="$(date)"

Append the current user to the server access control list for X
xhost +si:localuser:`whoami`

Append the last modification time of file $arg as the seconds since epoch with a preceding space to the variable 'KEY'
KEY+=`date -r "$arg" +\ %s`

Append the date and command ran to "/tmp/trace" after every command
PROMPT_COMMAND='echo "$(date +"%Y/%m/%d (%H:%M)") $(history 1 |cut -c 7-)" >> /tmp/trace'

keep only read access to all the files in a directory.
find /path/to/dir ! -perm 0644 -exec chmod 0644 {} \;

keep only read access to all the files in a directory.
find /path/to/dir/ -type f ! -perm 0644 -print0 | xargs -0 chmod 644

Keep only the last two hyphen-separated sections of "abc-def-ghi-jkl"
echo "abc-def-ghi-jkl" | rev | cut -d- -f-2 | rev

Keep the last 3 components (directories) of $path
echo $path | rev | cut -d'/' -f-3 | rev

Keep the last 4 ASCII characters (bytes) of a string.
echo "0a.00.1 usb controller some text device 4dc9" | rev | cut -b1-4 | rev

Highlights current day in a month calendar with color.
cal -h | sed "s/ $(date +%d) /"$'\033\[94m&\033\[0m/g; '"s/ $(date +%d)$/"$'\033\[94m&\033\[0m/g'

Highlights current day in a month calendar with color.
cal -h | sed "s/$(date +%d)/"$'\033\[94m&\033\[0m/g'

Highlights current day in a month calendar with color.
cal -h | sed "s/\<$(date +%d)\>/"$'\033\[94m&\033\[0m/g'

Identify CMS version/releases accross all your Drupal websites
find /home/*/public_html/ -type f -iwholename "*/modules/system/system.info" -exec grep -H "version = \"" {} \;

Identify CMS version/releases accross all your Drupal websites
find /var/www/vhosts/*/httpdocs/ -type f -iwholename "*/modules/system/system.info" -exec grep -H "version = \"" {} \;

Identify CMS version/releases accross all your PHPBB installations
find /home/*/public_html/ -type f -wholename *includes/constants.php -exec grep -H "PHPBB_VERSION" {} \;

Identify CMS version/releases accross all your PHPBB installations
find /var/www/vhosts/*/httpdocs/ -type f -wholename *includes/constants.php -exec grep -H "PHPBB_VERSION" {} \;

Identify CMS version/releases accross all your Wordpress websites
find /home/*/public_html/ -type f -iwholename "*/wp-includes/version.php" -exec grep -H "\$wp_version =" {} \;

Identify CMS version/releases accross all your Wordpress websites
find /var/www/vhosts/*/httpdocs/ -type f -iwholename "*/wp-includes/version.php" -exec grep -H "\$wp_version =" {} \;

If first command fails, exits from script with exit code of failed command.
echo $[4/0] || exit $?

If first command fails, exits from script with exit code of failed command.
make || exit $?

If variable "c" is a syntactically correct cron job, erase user's cron jobs and add "c" as the only cron job for user.
echo $c | crontab

Makes 'time' built-in to show only real execution time.
TIMEFORMAT=%R && time ls -l

Immediately display unique entries from access.log
tail -f access.log | stdbuf -oL cut -d ' ' -f1 | uniq

Immediately kill all child processes of parent process whose ID is specified by the variable PPID.
ps -o pid= --ppid $PPID | xargs kill -9

Immediately kill all processes listening on TCP port 3000.
lsof -n -i:3000 | grep LISTEN | awk '{ print $2 }' | uniq | xargs kill -9

Immediately kill all processes using TCP port 3000 on the system.
kill -9 $(lsof -i:3000 -t)

In a ssh session, set the variable 'user' to the last dot-separated number of the client's IP address.
export user=`env|grep -i SSH_CLIENT|cut -d' ' -f1|cut -d'.' -f4`

Infinitely print "no" to the screen
yes no

Infinitely write "1" with line numbers to the console and "/tmp/to"
yes 1 | nl | tee /tmp/to

insert "e" when it's pressed
bind '"e":self-insert'

Insert "|" every 30 characters in file "longline"
fold -w30 longline | pr -20ts'|'

Installs 'firefox' package.
yum install firefox

Installs 'firefox' package without using 'sublime2' repository.
yum --disablerepo=sublime2 install firefox

Install 'mono-devel' package, answering 'yes' for all questions.
yum -y install mono-devel

Installs  'packagename' package.
yum install packagename

Installs 'php-mbstring' package, enabling 'remi' repository.
yum --enablerepo=remi install php-mbstring

Installs 'php-mssql' package with enabling repository 'remi'.
yum --enablerepo=remi php-mssql

Installs all packages from a '/home/pkglist.txt' list, answering 'yes' on all questions.
cat /home/pkglist.txt | xargs yum -y install

Installs all packages from a current folder, excluding ones that match pattern '*glob*'.
yum install --exclude='*glob*' *.rpm

Installs git and bash-completion packages.
brew install git bash-completion

Installs locally located 'ffmpeg-2.6.4-1.fc22.x86_64.rpm' package.
yum install ffmpeg-2.6.4-1.fc22.x86_64.rpm

Installs locally located 'packagename.arch.rpm' package, ignoring GPG checking.
yum --nogpgcheck localinstall packagename.arch.rpm

Installs package "devtoolset-3" answering 'yes' on all questions.
yum install -y devtoolset-3

Installs packages 'mysql' and 'mysql-server'.
yum install mysql mysql-server

Installs package group "Development Tools" answering 'yes' on all questions.
yum -y groupinstall "Development Tools"

Installs package group "MYSQL Database Client", answering 'yes' on all questions.
yum -y groupinstall "MYSQL Database Client"

Interactively create a symbolic link in the current directory for "$SCRIPT_DIR/$FILE"
ln --symbolic --interactive $SCRIPT_DIR/$FILE

Interactively page through a list of all processes running on the system - the arrow keys pan around, and the Q key quits.
ps aux | less -S

Interactively page through the color-coded output of 'ls'.
ls --color | less -r

Interpret backslash sequences and delete whitespace characters in variable $FOO and save the result to variable 'FOO_NO_WHITESPACE'
FOO_NO_WHITESPACE="$(echo -e "${FOO}" | tr -d '[[:space:]]')"

Interpret conf-file in the current shell, making all environment variables in this file available to future sub-processes.
set -o allexport; source conf-file; set +o allexport

Invoke a trusted X11 forwarding SSH connection with the server $ssh_server as user $ssh_user
ssh -Y $ssh_user@$ssh_server

invoke make for all the xml files in the current folder by changing their extension from xml to log.
find /dump -type f -name '*.xml' | sed -e 's/\.xml$/.out/' | xargs make -j8

Open a local SSH port on 1080 for application-level port forwarding
ssh -D1080 root@localhost -g

Open a session-less connection to 'host' as user 'user' in master mode with a socket "/tmp/%r@%h:%p" to enable connection sharing
ssh user@host -M -S /tmp/%r@%h:%p -N

Open a ssh connection to "user@host" with a control socket "/tmp/%r@%h:%p"
ssh user@host -S /tmp/%r@%h:%p

Open a ssh connection to user@host with X11 forwarding to run GUI programs
ssh user@host -X

Open executable file for command "rails" in text editor "mate"
mate `which rails`

Open executable file of command "yum" in vi
vi `which yum`

open interactive list of jobs to select from
fg `jobs | iselect -a | grep -o [0-9]*`

Open gcc info manual and select "option index" menu entry.
info gcc "option index"

kills a running program 'python csp_build.py'
ps aux | grep 'python csp_build.py' | head -1 | cut -d " " -f 2 | xargs kill

this will recursively grep all the files, compressed or uncompressed.2 If you want to grep only the compressed files then find + zgrep would be a better option.
find /path/to/dir -name '*.gz' -exec zgrep -- 'pattern' {} +

Test if "file.tar.gz" is corrupt
gunzip -t file.tar.gz

Test if a file named 'file' in the current directory is more than 1 hour old
find file -chour +1 -exit 0 -o -exit 1

Test if a file named 'file' in the current directory is more than 1 hour old
find file -prune -cmin +60 -print | grep -q .

Test if files named 'something' were found in Dir/
[[ ! -z `find 'Dir/' -name 'something'` ]] && echo "found" || echo "not found"

Test if files named 'something' were found in YOUR_DIR
[[ ! -z `find 'YOUR_DIR/' -name 'something'` ]] && echo "found" || echo "not found"

Test if the tar file in "file.tar.gz" is corrupt
gunzip -c file.tar.gz | tar t > /dev/null

Getting a detailed list of files/dirs
find  / -name "apt" -ls

List ".java" files that have the same contents
md5sum *.java | sort | uniq -d -w32

list *.pdf, *.bmp and *.txt files under the /home/user/Desktop directory.
find /home/user/Desktop -name '*.pdf' -o -name '*.txt' -o -name '*.bmp'

list *.pdf files under the /home/user/Desktop directory.
find /home/user/Desktop -name '*.pdf'

List *.pl directories in the current directory tree
find . -name "*.pl" -exec ls -ld {} \;

List *.txt files residing in the current directory tree
find . -name *.txt -exec ls {} ;\

List .c files in the current directory
find . \( ! -name . -prune \) -name "*.c" -print

List .html files in the current directory tree that contain string "base\-maps" but do NOT contain string "base\-maps\-bot"
find . -name "*.html" -exec grep -lR 'base\-maps' {} \; | xargs grep -L 'base\-maps\-bot'

List .log files from the current directory tree
find . -name "*.log" -exec echo {} \;

List absolute path of files in the current directory
ls -1 | xargs readlink -f

List all ".txt" files with a unique md5 hash
md5sum *.txt | sort | perl -ne '($y,$f)=split; print "$f\n" unless $y eq $x; $x=$y'

List all *.c, *.h and *.cpp files under current directory
find . -type f \( -name '*.c' -or -name '*.h' -or -name '*.cpp' \) -exec ls {} \;

List all *.c files in entire file system
find / \! -name "*.c" -print

List all *.gif files found in the current directory tree
find . -name *.gif -exec ls {} \;

List all *.jar files/directories under /usr, /home and /tmp directory
find /usr /home  /tmp -name "*.jar"

List all *.jar files/directories under /usr, /home and /tmp directory without reporting errors
find /usr /home  /tmp -name "*.jar" 2>/dev/null

list all *.java files under the src directory
find src -name "*.java"

List all *.java files/directories under /home/bluher with their full paths
find /home/bluher -name \*.java

List all *.jpg files/directories in entire file system
find / -name "*.jpg" -print

List all *.ogg files under your home directory along with their size
find $HOME -name '*.ogg' -type f -exec du -h '{}' \;

list all *.txt files in the user's home directory.
find ~/ -name '*.txt'

List all *.txt files/directories under current directory
find . -name "*.txt" -exec $SHELL -c 'echo "$0"' {} \;

List all *.txt files/directories under current directory
find . -name "*.txt" -print

List all *.txt files/directories under current directory
find . -name '*.txt' -exec echo "{}" \;

List all *.txt files/directories under current directory
find . -name *.txt -exec ls {} \;

List all *.txt files/directories under current directory ensuring white space safety
find . -name '*.txt' -print0|xargs -0 -n 1 echo

List all *.txt files under current directory that contains the regex 'pattern'
find . -type f -name '*.txt' -exec egrep -l pattern {} \;

List all *fink* files/directories in entire file system
find / \( -type f -or -type d \) -name \*fink\* -ls

List all *fink* files/directories under current directory
find . -name "*fink*" |xargs ls -l

List all *jsp and *java regular files found in the current directory tree
find . \( -name '*jsp' -o -name '*java' \) -type f -ls

List all .c and .h files in the current directory tree that contain "thing"
find . -name '*.[ch]' -print0 | xargs -r -0 grep -l thing

List all .c and .h files in the current directory tree that contain "thing"
find . -name '*.[ch]' | xargs grep -l thing

list all .c or .sh regular files.
find . -type f \( -name "*.c" -o -name "*.sh" \)

List all .gif files in the current directory tree
find . -name *.gif -exec ls {} \;

List all .jpg files in the home directory tree in a fast way
find . -name "*.jpg" -exec ls {} +

List all VPN_CALLRECORD_20140409* files under current directory and print the 9th fields from the output to log.txt
find . -name 'VPN_CALLRECORD_20140409*' -type f| xargs ls -lhrt |awk '{print $9}' > log.txt

list all aliases
alias

list all aliases that name contents the string "xlogs"
alias | grep xlogs

List all aliencoders.[0-9]+ files/directories under /home/jassi/ directory
find /home/jassi/ -name "aliencoders.[0-9]+" 2>&1 | xargs ls -lrt | awk '{print $9}'

list all active jobs and its IDs
jobs -l

List all available commands in Mac OS
echo $PATH | tr ':' '\n' | xargs -I {} find {} -maxdepth 1 -type f -perm '++x'

List all broken symlinks under the current directory with info on whether the links exist or not
find -L . -type l |xargs symlinks

List all cron jobs for current user.
crontab -l

List all directories and subdirectories
find . -type d

List all directories found in the current directory and below.
find . -type d

List all directories under current directory
find . -type d -exec ls -dlrt {} \;

List all directories of the $topdir directory tree that contain a Makefile and at least one .py file
find "$topdir" -name '*.py' -printf '%h\0' | xargs -0 -I {} find {} -mindepth 1 -maxdepth 1 -name Makefile -printf '%h\n' | sort -u

List all directories starting from root that have sticky bit set
find / -type d  -perm -1000  -exec ls -ld {} \; 2> /dev/null

List all empty files in the current directory tree
find . -empty -exec ls {} \;

List all empty files in the current directory tree
find . -type f -empty

List all environment variables containing 'USER' in their name or value that would result in running a command with 'sudo env'.
sudo env |grep USER

List all environment variables (name and value) whose name either equals HOME or PATH, or starts with GO
env | grep '^\(GO\|HOME=\|PATH=\)'

List all environment variables (name and value) whose name either equals PATH or starts with GOBIN
env | grep '^\(GOBIN\|PATH=\)'

List all environment variables (name and value) whose name starts with GOROOT
env | grep '^GOROOT'

List all environment variables whose name starts with PATH, showing the name and value of each one.
env | grep ^PATH

list all files
find .

list all files in /home/bozo/projects directory tree that were modified exactly one day ago.
find /home/bozo/projects -mtime 1

list all files in /home/bozo/projects directory tree that were modified within the last day
find /home/bozo/projects -mtime -1

list all files in the current directory recursively
find .

list all files under $dir directory except path $dir/prune_me directory
find "$dir" -not -path "$dir/prune_me*" -exec bash -c 'echo "$0"' {} \;

list all files under $dir directory except path $dir/prune_me directory
find "$dir" -not \( -path "$dir/prune_me" -prune \) -exec bash -c 'echo "$0"' {} \;

list all files under $dir directory except path $dir/prune_me directory
find "$dir" -path "$dir/prune_me" -prune -o -exec bash -c 'echo "$0"'  {} \;

list all files under .performance_test directory except .performance_test/prune_me directory
find ".performance_test" -not -path ".performance_test/prune_me*" -exec bash -c 'echo "$0"' {} \;

list all files under .performance_test directory except .performance_test/prune_me directory
find ".performance_test" -not \( -path ".performance_test/prune_me" -prune \) -exec bash -c 'echo "$0"' {} \;

list all files under .performance_test directory except .performance_test/prune_me directory
find ".performance_test" -path ".performance_test/prune_me" -prune -o -exec bash -c 'echo "$0"' {} \;

list all files under the current directory called cookies.txt
find -name cookies.txt

list all files under the current directory, writing the output to the file files_and_folders, do not try to descend into directories that cannot be read.
find . -type d ! -perm -g+r,u+r,o+r -prune -o -print > files_and_folders

list all files under the current directory, writing the output to the file files_and_folders, suppressing all error messages
find . 2>/dev/null >files_and_folders

list all files under the current directory, writing the output to the file files_and_folders, suppressing all error messages.
find . 2>/dev/null > files_and_folders

list all files under the current directory, writing the output to the file some_file, suppressing all error messages
find . 2>/dev/null > some_file

List all files/folders in current directory by separating them with spaces
ls | tr  "\n" " "

List all file paths under the current directory with case insensitive name ".note" in reverse alphabetic order
find . -iname '.note' | sort -r

List and see contents of all abc.def files under the directories /ghi and /jkl
find /ghi /jkl -type f -name abc.def 2> /dev/null -exec ls {} \; -exec cat {} \;

List all hidden files under present working directory and redirect the list to all-hidden-files.txt
find `pwd` -iname ".*" -type f > all-hidden-files.txt

List all your files including everything in sub-directories
find ~

List all nfs mounts
mount -l -t nfs4

List all IPV4 addresses found in all files under /etc directory
find /etc -type f -exec cat '{}' \; | tr -c '.[:digit:]' '\n'  | grep '^[^.][^.]*\.[^.][^.]*\.[^.][^.]*\.[^.][^.]*$'

list all javascipts file expect files under proc folder
find . -type d -name proc -prune -o -name '*.js'

list all javascipts file which whole name does not contain "directory"
find . -name '*.js' -and -not -path directory

list all javascipts file which whole name does not contain excludeddir
find . -name '*.js' | grep -v excludeddir

list all javascipts file which whole name does not contain excludeddir or excludedir2  or excludedir3
find . -name '*.js' | grep -v excludeddir | grep -v excludedir2 | grep -v excludedir3

list all js files under currect directory exculde the directory which path contain "/path/to/search/exclude_me" or name isexclude_me_too_anywhere
find /path/to/search                    \   -type d                               \     \( -path /path/to/search/exclude_me \        -o                               \        -name exclude_me_too_anywhere    \      \)                                 \     -prune                              \   -o                                    \   -type f -name '*\.js' -print

List all level 1 subdirectories of the current directory printing line "cmd2" after each of them
find -maxdepth 1 -type d | while read dir; do echo $dir; echo cmd2; done

List all files 2 levels deep in the current directory tree
tree -L 2 -fi

List all files and directories from the current directory tree
find . -print | xargs ls

List all files and directories in "/data/" sorted by version number
tree -ivL 1 /data/ | perl -nlE 'say if /\Acommand-[0-9][0-9a-z.]*-setup\z/'

List all files and directories in long list format with a time style of "long-iso" and sort from oldest modifed to newest modified
ls -l --time-style=long-iso | sort -k6

List all files/directories in entire file system
find / -print

List all files and directories in the /home directory tree whose names are "Trash"
find /home -name Trash -exec ls -al {} \;

List all files and directories (including hidden) in the current working directory in a long list format sorted by the oldest modification time
ls -alrt `pwd`/*

List all files/directories under $dir_name with size $sizeFile and print them according to the format string  '%M %n %u %g %s %Tb %Td %Tk:%TM %p\n'
find $dir_name -size $sizeFile -printf '%M %n %u %g %s %Tb %Td %Tk:%TM %p\n'

List all files/directories under /data1/Marcel which are greater than 524288 bytes and were modified or accessed more than 1 year ago
find /data1/Marcel -size +1024 \( -mtime +365 -o -atime +365 \) -ls

List all files/directories under /data1/Marcel with their file information which are greater than 524288 bytes and were modified or accessed more than 1 year ago
find /data1/Marcel -size +1024  \( -mtime +365 -o -atime +365 \) -ls -exec file {} \;

List all files/directories under /myfiles directory
find /myfiles -exec ls -l {} ;

List all files/directories under current directory
find -ls

List all files/directories under current directory
find .

List all files/directories under current directory
find . -ls

List all files/directories under current directory
find . -print

List all files/directories under current directory
find | perl -lne 'print quotemeta' | xargs ls -d

List all files/directories under current directory and redirect it to /tmp/files.txt
find . -ls > /tmp/files.txt

List all files/directories under current directory by replacing all spaces with commas (,)
find . -ls | tr -s ' ' ,

List all files/directories under current directory ensuring white space safety
find -print0 | xargs --null

List all files/directories under current directory matching the posix-egrep type regex ".+\.(c|cpp|h)$" in their names
find . -regextype posix-egrep -regex ".+\.(c|cpp|h)$" -print0 | xargs -0 -n 1 ls

List all files/directories under current directory matching the posix-egrep type regex ".+\.(c|cpp|h)$" in their names
find . -regextype posix-egrep -regex ".+\.(c|cpp|h)$" | xargs -n 1 ls

List all files/directories under current directory matching the posix-egrep type regex ".+\.(c|cpp|h)$" in their names excluding the files that contain 'generated' or 'deploy' in their paths
find . -regextype posix-egrep -regex '.+\.(c|cpp|h)$' -print0 | grep -vzZ generated | grep -vzZ deploy | xargs -0 ls -1Ld

List all files/directories under current directory matching the posix-egrep type regex ".+\.(c|cpp|h)$" in their names excluding the paths */generated/* and */deploy/*
find . -regextype posix-egrep -regex '.+\.(c|cpp|h)$' -not -path '*/generated/*' -not -path '*/deploy/*' -print0 | xargs -0 ls -L1d

List all files/directories under current directory with 'FooBar' in their names ensuring white space safety
find . -name 'FooBar' -print0 | xargs -0

List all files/directories under current directory with 'FooBar' in their paths ensuring white space safety
find . -print0 | grep --null 'FooBar' | xargs -0

List all files and directories residing in the current directory and below
find -print0 | xargs -0 ls

List all files and directories residing in the current directory and below
find | xargs ls

List all files/directories with spaces in their names under ~/Library directory
find ~/Library -name '* *' -exec ls {} \;

List all files and folders in the current working directory
ls `pwd`/*

List all files and sub directories including hidden files in the current directory tree
tree -af

List all files bigger than 10000 blocks
find . -type f -size +10000 -exec ls -al {} \;

List all files from the current directory tree that were modified less than 60 minutes ago
find . -mmin -60 -ls

List all files from the current directory tree that were modified less than 60 minutes ago
find . -mmin -60 | xargs -r ls -l

List all files from the current directory tree that were modified less than 60 minutes ago
find . -mmin -60 | xargs -r ls -ld

List all files except for those in directory SCCS
find . -print -o -name SCCS -prune

List all files in /home/bozo/projects directory tree that were modified exactly one day ago
find /home/bozo/projects -mtime 1

List all files in /home/bozo/projects directory tree that were modified exactly one day ago.
find /home/bozo/projects -mtime 1

List all files in /home/bozo/projects directory tree that were modified within the last day
find /home/bozo/projects -mtime -1

List all files in /home/bozo/projects directory tree that were modified within the last day.
find /home/bozo/projects -mtime -1

List all files in /var/www and below that have changed in the last 10 minutes
find /var/www -cmin -10 -printf "%c %pn"

List all files in a current folder, separating names with comma
ls -1 | tr '\n' ','

List all files in a current folder, separating names with semicolon
ls -1b | tr '\n' ';'

List all files in a current folder, separating names with semicolon
ls -m | tr -d ' ' | tr ',' ';'

List all files in current directory whose name or file type description contains the word "ASCII".
file * | grep ASCII

List all files in entire file system owned by the user wnj and are newer than the file ttt
find / -newer ttt -user wnj -print

List all files in entire file system that are not newer than the ttt file and do not belong to the user wnj
find / \! \( -newer ttt -user wnj \) -print

List all files in maximum 2 levels down the current directory
find . -maxdepth 2  -type f -exec ls -l {} \;

List all files in maximum 2 levels down the current directory
find . -maxdepth 2  -type f -print0 | xargs -0 -n1 ls -l

List all files in the "test" directory tree except those with '/invalid_dir/' in the pathnames
find test -print | grep -v '/invalid_dir/'

List all files in the /hometest directory tree whose names are "Trash", and their sizes
find /hometest -name Trash -exec ls -s {} \;

List all files in the /var directory tree whose size is greater than 10 megabytes
find /var/ -size +10M -exec ls -lh {} \;

List all files in the /var directory tree whose size is greater than 10 megabytes
find /var/ -size +10M -ls

List all files in the current directory tree except for those in the ./src/emacs directory
find . -path './src/emacs' -prune -o -print

List all files in the current directory tree including those that may contain spaces in their names
find . -print0 | xargs -0 -l -i echo "{}";

List all files in the current directory tree larger than 1000 kb
find . -size +1000k

List all files in the current directory tree that were last modified between "mar 03, 2010 09:00" and "mar 11, 2010"
find -newermt "mar 03, 2010 09:00" -not -newermt "mar 11, 2010" -ls

List all files in the current directory tree that were last modified in March 2007
find ! -newermt "apr 01 2007" -newermt "mar 01 2007" -ls

List all files in the current directory tree that were last modified more than 60 minutes ago
find -mmin +60

List all files in the current directory tree that were last modified yesterday or later
find -newermt yesterday -ls

List all files in the current directory tree that were modified 60 minutes ago
find -mmin 60

List all files in the current directory tree that were modified 60 minutes ago
find . -mmin 60 -print0 | xargs -0r ls -l

List all files in the current directory tree that were modified 60 minutes ago
find . -mmin 60 | xargs '-rd\n' ls -l

List all files in the current directory tree that were modified less than 60 minutes ago
find . -mmin -60 |xargs ls -l

List all files under and below the directory given as variable $ARCH1
find $ARCH1 -ls

List all files under and below the directory given as variable $FULFILLMENT
find $FULFILLMENT -ls

List all files under current directory
find . -type f | xargs ls

List all files under current directory matching the regex '.*(c|h|cpp)$'
find -E . -type f -regex '.*(c|h|cpp)$' -exec ls {} \;

List all files under current directory matching the regex '.*\(c\|h\|cpp\)'
find . -type f -regex '.*\(c\|h\|cpp\)' -exec ls {} \;

List all files under current directory matching the regex '.*\.\(c\|h\|cpp\)'
find . -type f -regex '.*\.\(c\|h\|cpp\)' -exec ls {} \;

List all files under current directory with their sizes and paths
find . -type f -printf '%s %p\n'

List all files under the current working directory last modified less than a day ago
find `pwd` -mtime -1 -type f -print

List all files under the current working directory tree
find $(pwd)/ -type f

List all files under the current working directory with name ".htaccess"
find `pwd` -name .htaccess

List all files matching regular expression '*foo*' in a human-readable form
find . -name '*foo*' -exec ls -lah {} \;

List all files that are between 10000 and 32000 bytes in size
find . -size +10000c -size -32000c -print

List all files that have not been read in thirty days or more
find . -type f -atime +30 -print

List all files with their modification time in entire file system that are newer than the file $newerthan and older than the file $olderthan in regards of modification time and sort them according to file modification time
find / -type f -name "*" -newermt "$newerthan" ! -newermt "$olderthan" -printf "%T+\t%p\n" | sort

List all files with their paths that have identical content.
find * -type f | xargs md5sum | sort | uniq -Dw32

List all files without descending into subdirectories
find * -type f -print -o -type d -prune

list all names of the aliases
alias | awk '/^alias /{print substr($2,1,index($2,"=")-1)}'

List all non-empty files under under current directory
find . -type f ! -size 0

List all non-hidden files in ~/junk
find ~/junk   -name "*" -exec ls -l {} \;

List all of the subdirectories in the current directory with no trailing slash.
ls -d */ | cut -f1 -d'/'

List all mounted filesystems
mount

List all processes with detailed information
ps -ef

list all processes with its PIDs
jobs -l

list all regular files under the directory "$directory"
find $directory -type f -name '*'

list all regular files which path is not dir1 or dir2
find ! -path "dir1" ! -path "dir2" -type f

list all regular files which path is not dir1 or dir2
find dir -not \( -path "dir1" -o -path "dir2" -prune \) -type f

list all regular files which path is not dir1 or dir2
find dir -not \( -path "dir1" -prune \) -not \( -path "dir2" -prune \) -type f

List all regular files from the current directory tree that were modified less than 60 days ago
find -type f -mtime -60

List all regular files in /var/www and below that have changed in the last 10 minutes
find /var/www -cmin -10 -type f -printf "%c %pn"

List all regular files in and below the home directory that have been modified in the last 90 minutes
find ~ -type f -mmin -90 | xargs ls -l

List all regular files in and below the home directory that were modified more than 5 years ago
find ~ -type f -mtime +1825 |xargs -r ls -l

List all regular files in and below the home directory that were modified more than 5 years ago
find ~ -type f -mtime +1825 |xargs ls -l

List all regular files in entire file system
find / -type f -exec echo {} \;

List all regular files in the current directory tree
find . -type f -exec ls -l '{}' \;

List all regular files in the current directory tree
find . -type f -print0 | xargs -0 ls -l

List all regular files in the current directory tree
find . -type f | xargs ls -l

List all regular files in the current directory tree modified within the last 24 hours
find . -mtime 0 -type f -ls

List all regular files in the current directory tree that were modified less than 60 minutes ago
find . -mmin -60 -type f -exec ls -l {} +

List all regular files under current directory (not white space sage)
find . -type f -print | xargs -n 1

List all regular files under current directory ensuring white space safety
find . -type f -print0 | xargs -0 -n 1

List all regular files under the current directory and below it
find . -type f -print0 | xargs -0 ls -l

List all regular files under the current directory and below it
find . -type f | xargs ls -l

List all regular files matching the name pattern "$1*" (where $1 is a positional parameter) under '/usr', '/bin', '/sbin' and '/opt' directory tree
find /usr /bin /sbin /opt -name "$1*" -type f -ls

List all regular files modified more than 61 days
find -type f -mtime 61 -exec ls -ltr {} \;

List all regular files residing in the current directory tree and containing string "/bin/ksh"
find . -type f -exec grep -li '/bin/ksh' {} \;

List all regular files residing in the current directory tree and containing string "/bin/ksh"
find . -type f -print | xargs grep -li 'bin/ksh'

List and remove all regular files named "core" under /prog that are larger than 500k
find /prog -type f -size +1000 -print -name core -exec rm {} \;

list all running jobs
jobs

list all samba files in /var/l* directory ( /var/lib or /var/log )
find  /var -path */l??/samba*

List all SGID and SUID files in entire file system
find / -type f \( -perm -4000 -o -perm -2000 \) -ls

List all symlinks under current directory and search for targetfile.txt in this list
find . -type l | xargs -I % ls -l % | grep targetfile.txt

list all system calls during process of symbolic link creation process on  "/tmp/output.txt" file
strace -o /tmp/output.txt ln -s -f .bash_aliases test

list all the ".ksh" files in the current directory
find . -ls -name "*.ksh"

List all the .c files under the current directory and below in a 3 column format
find . -name "*.c" | xargs -n3

List all the .c files under the current directory and below in a 3 column format
find . -name "*.c" | xargs -n3 echo

list all the directories in the folder httpdocs
find httpdocs -type d

list all the drectories present in the current directory and do not search in the sub directories.
find -maxdepth 1 -type d

List all the emptry files in thecurrent directory only.
find . -maxdepth 1 -empty

list all the files in the file system excluding proc folder and excluding symbolic links which have write permission for the user
find / -path /proc -prune -o -perm -2 ! -type l -ls

List all unique parent directories of .class files found under the current directory
find -name '*.class' -printf '%h\n' | sort -u

List all users logged into the current(null) tty
who | grep "$(tty | sed 's:/dev/::')"

List all variables (names and values) whose name or value contains X.
env | grep ".*X.*"

list all zero-length files under the current directory
find . -empty -exec ls {} \;

List all ~/bin/FilesDvorak/.* (non-recursive) and ~/.PAST_RC_files/.* (recursive) files/directories and take common entries between these two lists
comm -12 <(find ~/bin/FilesDvorak/.* -maxdepth 0) <(find ~/.PAST_RC_files/.*)

List an empty environment (prints nothing)
env -i

List characters from standard input showing backslash escapes for non-displayables
od -cvAnone -w1

List common files in directories "1" and "2"
cat <(ls 1 | sort -u) <(ls 2 | sort -u) | uniq -d

list complete path name to process associated with pid "$1"
find /proc/$1/exe -printf '%l\n'

List content of 'myfile' in a subshell and returns output to parent shell
$(cat myfile)

List current user's crontab.
crontab -l

List detailed information about all Jar files in the current directory tree
find . -iname "*.jar" | xargs -n1 zipinfo

List detailed information about all Jar files in the current directory tree
find . -iname "*.jar" | xargs zipinfo

List detailed information about all Jar files in the current directory tree
find . -name "*.jar" -exec zipinfo {} \;

List directories under current directory
find . -type d

List each directory in the current directory prefixed with its disk usage in human readable format and sorted from smallest to largest
du -sh */ | sort -n

List each file or directory in the current directory prefixed by its filesize in bytes and sorted from smallest to largest
du -a --max-depth=1 | sort -n

List each file or directory in the current directory prefixed by its human readable filesize and sorted from largest to smallest
du -h --max-depth=0 * | sort -hr

List each file or directory in the current directory prefixed with its filesize in bytes and sorted from smallest to largest
du -s * | sort -n

List each file or directory in the current directory prefixed with its filesize in MB and sorted from smallest to largest
du -smc * | sort -n

List each subdirectory name composing the current working directory
pwd | cut -b2- | tr '/' '\n'

List each subdirectory name composing the current working directory
pwd | cut -f 1- -d\/ --output-delimiter=$'\n'

List each unique character in "file" prefixed by number of occurrences
grep -o . file | sort | uniq -c

List each unique character in "file" prefixed by number of occurrences and sorted from most frequent to least frequent
grep -o . filename | sort | uniq -c | sort -nr

List each unique case insensitive character in "file" prefixed by number of occurrences
grep -o . file | sort -f | uniq -ic

List each unique case insensitive character in "file" prefixed by number of occurrences and sorted from most frequent to least frequent
grep -o . filename | tr '[:upper:]' '[:lower:]' | sort | uniq -c | sort -nr

List empty directories in the current directory tree
find . -depth -empty -type d

List every directory under current directory with their child executable files
find . -type d -print -exec bash -c 'find {} -type f -depth 1 -perm +0111 | sort -r' \;

List every directory under current directory with their child executable files
find . -type d | sort | xargs -n1 -I{} bash -c "find {} -type f -maxdepth 1 -executable | sort -r"

List every directory under current directory with their child executable files
find `pwd` -perm 111 -type f | sort -r | xargs -n1 -I{} sh -c "dirname {};basename {}" | awk '/^\// {dir=$0 ; if (dir != lastdir) {print;lastdir=dir}} !/^\// {print}'

List every symbolic link in every home directory's subdirectory owned by group `staff'
find `pwd` -group staff -exec find {} -type l -print ;

List existing screen sessions
screen -ls

list files found under the current directory ending in "txt" or ending in "html"
find . -name '*.txt' -o -name '*.html'

list files in /u/bill that were last read from 2 to 6 minutes ago
find /u/bill -amin +2 -amin -6

list files in /usr modified after February 1 of the current year
find /usr -newermt "Feb 1"

list files in /usr modified after the time which /tmp/stamp$$ modified
find /usr -newer /tmp/stamp$$

list files in the directory "$directory" with permissions "$permissions"
find "$directory" -perm "$permissions"

list files under the current directory that match the filename '...', suppressing all error messages
find . -name '...' 2>/dev/null

list files that the user does not have permissions to read, do not try to descend into directories that cannot be read.
find . ! -perm -g+r,u+r,o+r -prune

list files that the user does not have permissions to read, do not try to descend into directories that cannot be read.
find . ! -readable -prune

List file contents of compressed file $i
gzip -l $i

List file contents of compressed file 'compressed.tar.gz'
gzip -l compressed.tar.gz

List file information of the full path of command "c++"
ls -ald `which c++`

List first 5 files named 'something' that are found under current directory
find . -name something -print | head -n 5

List HTML files starting from the home directory that are 50k at the most
find . \( -size 100 -o -size -100 \)  -name '*.html' -exec  ls -l {} \;  2> /dev/null

list in long format all files from / whose filename ends in "jbd", not descending into directories that are not readable while searching, and not descending into directories on other filesystems
find / -mount \! -readable -prune  -o  -path /dev -prune  -o  -name '*.jbd' -ls

List in detail the regular files from the /somelocation/log_output directory tree that were last changed more than 40 days ago
find /somelocation/log_output -type f -ctime +40 -exec ls -l {} \;

List jobs and their process ids and print them by replacing newline with '^'
joblist=$(jobs -l | tr "\n" "^")

List largest 200 files over 1,000,000 bytes in the filesystem mounted at "/usr/pcapps"
find /usr/pcapps/ -mount -type f -size +1000000c | perl -lpe ' s{ }{\\ }g ' | xargs ls -l | sort +4nr | head -200

List level 2 subdirectories of the current directory
find . -mindepth 2 -maxdepth 2 -type d -ls

List level 2 subdirectories of the current directory
find . -mindepth 2 -maxdepth 2 -type d -printf '%M %u %g %p\n'

List files/directories at least three levels down the directory tree
find / -mindepth 3  -name "*log"

List files and directories recursively
find . -print | xargs ls -gilds

List files cart1, cart2, ..., cart6 in directory ~/junk
find ~/junk  -name 'cart[1-6]' -exec ls -l {} \; 2> /dev/null

List files ending in .html and residing in the current directory tree
find . -name "*.html"

List files in "dir1" that are not in "dir2"
comm -23 <(ls dir1 |sort) <(ls dir2|sort)

List files in directory "one" and "two" that do not exist in the other
sort <(ls one) <(ls two) | uniq -u

List files in the current directory
find . \( ! -name . -prune \)

List files in the current directory
find . \( -path './*' -prune \)

List files in the current directory and below
find -ls

List files in the current directory and below except for GIT files
find . -not -iwholename '*/.git/*'

List files in the current directory and below that are exactly 1234 bytes in size
find . -size 1234c

List files in the current directory tree using echo
find . -exec echo {} ;

List files in the current directory tree which have permissions rwx for user and rw for group and others
find . -perm 766 -exec ls -l {} \;

List files under $CURR_DIR which were modified, accessed or whose status were changed $FTIME ago and sort them and remove duplicate entries
sort <(cd $CURR_DIR && find . -type f -ctime $FTIME) <(cd $CURR_DIR && find . -type f -atime $FTIME) <(cd $CURR_DIR && find . -type f -mtime $FTIME) | uniq

List files under $CURR_DIR which were modified, accessed or whose status were changed $FTIME ago replacing the $CURR_DIR path string to './'
find ${CURR_DIR} -type f \( -ctime ${FTIME} -o -atime ${FTIME} -o -mtime ${FTIME} \) -printf "./%P\n"

List files under current directory according to their size in descending order
find . -type f -exec ls -s {} \; | sort -n -r

List files larger than 10MB in the /var directory recursively
find /var/ -size +10M -exec ls -lh {} \;

List files larger than 10MB in the /var directory recursively
find /var/ -size +10M -ls

List files larger than 10MB under /var/log
find /var/log -size +10M -ls

List files larger than 10MB under /var/log /tmp that haven't changed in a month
find /tmp /var/tmp -size +30M -mtime 31 -ls

List files larger than 10MB under /var/log /tmp that haven't changed in a month
find /tmp /var/tmp -size +30M -mtime 31 -print0 | xargs -0 ls -l

List files larger than 9MB residing in the current directory and below
find . -size +9M

List files named "accepted_hits.bam" in the current directory tree prefixing their names with "somecommand"
find `pwd` -name "accepted_hits.bam" | xargs -i echo somecommand {}

List files smaller than 9kB residing in the current directory and below
find . -size -9k

List files that have been renamed in Git repository.
find -name .git -prune -o -exec git log --pretty=tformat:'' --numstat --follow --find-copies-harder --reverse {} ';' | cut -f3- | grep '.* => .*'

List files with C-style escape sequences for non-alphanumeric characters
ls -b

list names of bind functions containing "/"
bind -l | grep /

List non-hidden regular files in the current directory tree that were last modified more than 500 days ago
find . -type f -not -name '.*' -mtime +500 -exec ls {} \;

list any files modified since /bin/sh was last modified
find . -newer /bin/sh

List only file names matching "*2012*" from "serveripaddress::pt/dir/files/" listening on port 111 and write to "output.txt"
sync --list-only --include "*2012*.xml" -exclude "*.xml" serveripaddress::pt/dir/files/ --port=111 | awk '{ $1=$2=$3=$4=""; print substr($0,5); }' >output.txt

List any line in "f1" or "f2" which does not appear in the other and delete all tab characters in the output
comm -3 <(sort -un f1) <(sort -un f2) | tr -d '\t'

List only the non-hidden empty files only in the current directory.
find . -maxdepth 1 -empty -not -name ".*"

List path/filename of all PHP files under current directory whose file type description or path/name contains "CRLF"
find . -type f -iname "*.php"  -exec file "{}" + | grep CRLF

list PID of a group leader
jobs -lp

List recursively all files and directories in /var/www
find /var/www

list regular files ending in .mbox
find . -type f -wholename \*.mbox

list regular files under the current directory
find . -type f

list regular files under the user's home directory that are over 100KB and have not been accessed in over 30 days.
find $HOME -type f -atime +30 -size 100k

list regular file which file name end with '*.c' or '*.sh' in current directory
find . -type f \( -name "*.c" -o -name "*.sh" \)

list regular file which file name is NOT end with '.html' in current directory in current directory
find . -type f -not -name "*.html"

List regular files in current directory with read, write and execute permission for all users and also show the permissions
find . -type f  -perm 777 -exec ls -l {} \;

List regular files in current directory with read, write and execute permission for all users and also show the permissions
find . -type f  -perm a=rwx -exec ls -l {} \;

List running screen sessions
screen -ls

List screen session IDs
screen -list

List screen IDs
screen -ls

List screen IDs
screen -r

Delimit standard input with ":" and display as a table
column -s: -t

List subdirectories in the current directory
find . -maxdepth 1 -type d -exec ls -ld "{}" \;

List subdirectories in the current directory
find . -maxdepth 1 -type d -print0 | xargs -0 ls -d

list symbolic links under the directory "$directory"
find $directory -type l

List the .py files which reside in the current directory tree and whose parent directory contains a Makefile
find . -name '*.py' -exec bash -c 'test -f $(dirname "$1")/Makefile' -- {} \; -print

List the 10 largest files or directories and their sizes under (and including) "/var"
du -a /var | sort -n -r | head -n 10

List the abc.def files under the directories /ghi and /jkl which have commented entries and display those entries
find /ghi /jkl -type f -name abc.def 2> /dev/null -exec grep -H ^# {} \;

List the combined path of the current working directory and "file.txt"
ls "`pwd`/file.txt"

List the current directory recursively ignoring ./src/emacs/ and all its contents
find . -path ./src/emacs -prune -o -print

List the current directory recursively ignoring the "dir1" subdirectory
find . -path ./dir1  -prune -o -print

List the current directory recursively ignoring the "dir1" subdirectory
find . -path ./dir1\*  -o -print

List the current directory recursively ignoring the "dir1" subdirectory
find . -path ./dir1\*  -prune -o -print

list the details of all the directories in the current folder
find . -type d -exec ls -ld {} \;

List the directory paths of all *.ext (case insensitive) files under /path directory
find /path -type f -iname "*.ext" -printf "%h\n"

List the directory paths of all file.ext files under present working directory
find $PWD -name "file.ext" -exec sh -c 'echo $(dirname {})' ';'

List the directory paths of all file.ext files under present working directory
find . -name "file.ext" -execdir pwd ';'

List the directory paths of all file.ext files under present working directory
find `pwd` -name "file.ext" -exec dirname {} \;

List the directory paths of all file.ext files under present working directory
find `pwd` -name file.ext |xargs -l1 dirname

List the entire cron job list of user "apache".
crontab -u apache -l

list the files with a name ending with '.mp3' or '.jpg' and beginning with 'foo'
find . \( -name '*.mp3' -o -name '*.jpg' \) -name 'foo*' -print

List the full path of each directory in the current working directory
tree -dfi -L 1 "$(pwd)"

List the full path of each directory under the current working directory
tree -dfi "$(pwd)"

List the largest file in long list format of all the files under the current directory
find . -type f -ls | sort -nrk7 | head -1 #unformatted

List the largest file prefixed by its size in bytes of all files under the current directory
find . -type f -name '*.gz' -printf '%s %p\n'|sort -nr|head -n 1

List the last entry of the numerically sorted list of all files and folders under "/foldername"
find /foldername | sort -n | tail -1

List the files from the current directory tree that contain lines approximately matching regular expression '^Subject:.*unique subject'
find . -type f -print | xargs agrep -2 -il '^Subject:.*unique subject'

List the files from the current directory tree that contain lines matching regular expression '^From:.*unique sender', ignoring ~/src and ~/bin
find . -name bin -prune -o -name src -prune -o -type f -print | xargs egrep -il '^From:.*unique sender'

List the files from the current directory tree that contain lines matching regular expression  '^Subject:.*unique subject'
find . -type f -print | xargs grep -il '^Subject:.*unique subject'

List the files from the current directory tree that contain lines matching regular expression  '^Subject:.*unique subject'
find . -type f -print0 | xargs -0 grep -il '^Subject:.*unique subject'

List the files in "archive.tar.gz"
gzip -l archive.tar.gz

List the files in the /etc directory tree containing text "old1.old2.co.com"
find /etc -type f -print | xargs grep -il old1\.old2\.co\.com

List the files in the /etc directory tree containing text '128.200.34.'
find /etc -type f -print | xargs grep -il '128\.200\.34\.'

List the files matching 'my key phrase' either in their names or contents
find | xargs -I {} bash -c '(([[ -f "{}" ]] && grep -l "my key phrase" "{}") || ([[ "{}" =~ "my key phrase" ]] && echo {}))'

List the MD5 digest of all files under "teste1" and "teste2" sorted alphabetically
find teste1 teste2 -type f -exec md5 -r {} \; | sort

List the names of all file.ext files/directories under present working directory
find `pwd` -name "file.ext" -printf "%f\n"

List the names of all files under current directory
find . -type f -exec basename {} \;

List the names of the directories in current directory without going into sub-directories
find . -maxdepth 1 -mindepth 1 -type d -printf '%f\n'

List the names of the directories in current directory without going into sub-directories
find . -mindepth 1 -maxdepth 1 -type d -printf "%P\n"

List the number of occurrences of each unique character in "The quick brown fox jumps over the lazy dog" sorted from most frequent to least frequent
echo "The quick brown fox jumps over the lazy dog" | grep -o . | sort | uniq -c | sort -nr

Limits the number of results from grep to 2 lines
grep -o '1.' yourfile | head -n2

List the unique tab delimited field number "$FIELD" in all files, prefix with the number of occurrences, sort from most frequent to least frequent
cut -f $FIELD * | sort| uniq -c |sort -nr

List the unique file extensions of all files under the current directory
find . -type f | grep -o -E '\.[^\.]+$' | sort -u

List the unique parent directories of all .class files found in the entire filesystem
find / -name *.class -printf '%h\n' | sort --unique

List the unique parent directories of all .class files found under "/root_path"
find /root_path -type f -iname "*.class" -printf "%h\n" | sort -u

List the unique second "/" delimited field of every line from standard input prefixed by the number of occurrences
cut -d/ -f1-2 | cut -d/ -f2- | sort | uniq -c

List the users having <groupname> as their secondary group.
getent group <groupname> | cut -d: -f4 |  tr ',' '\n'

List the z* links in the /usr/bin directory with inode information and the file to which it points to
find /usr/bin -type  l  -name "z*" -ls

List unique series of 3 characters in file "$1" prefixed by the number of occurrences and sorted from most frequent to least frequent
fold -w3 "$1" | sort | uniq -c | sort -k1,1nr -k2

Gives the primary group of $USERNAME.
groups $USERNAME | cut -d\  -f 1

Lists '/tmp/hashmap.$1' file or folder '/tmp/hashmap.$1' content one file per line.
ls -1 /tmp/hashmap.$1

Lists all content in a current folder but names like *.c and *.h.
ls -d !(*.[ch])

Lists all content in a current folder but names like *.c and *.h.
ls -d !(*@(.c|.h))

Lists all directories in '/home/alice/Documents/'.
ls -d /home/alice/Documents/*/

Lists all directories in a current folder.
ls -d */

Lists all files and folders with its content in a current folder, excluding names ending with 'foo'.
ls !(*foo)

Lists all files and folders with its content in a current folder, excluding names starting with 'b'.
ls !(b*)

Lists all files in a '/home/dreftymac/' folder and subfolders without recursion.
ls /home/dreftymac/*

Lists all files in a current folder, separating names with 'some_delimiter'.
ls -1 | perl -pe 's/\n$/some_delimiter/'

Lists all files in a current folder, separating names with space.
ls -1 | perl -l40pe0

Lists all files in a current folder, separating names with comma.
ls -1 | paste -sd "," -

Lists all files in a current folder, separating names with comma.
ls -m

Lists all files in a current folder, separating names with comma.
ls | perl -F'\n' -0777 -anE 'say join ",", @F'

Lists all files in a current folder, separating names with comma.
ls | xargs -I {} echo {}, | xargs echo

Lists all files that matches path pattern with wildcards.
ls -l /lib*/ld-linux*.so.2

Lists all manual pages.
apropos -r '.*'

Lists all running tmux sessions.
tmux ls

Lists all subdirectories in a current folder, removing trailing slash.
ls -d */ | cut -f1 -d'/'

Lists all subdirectories in current directory with a trailing slash
ls -d ./*/                     ### more reliable BSD ls

Lists all subdirectories in the current directory
ls -d -- */                    ### more reliable GNU ls

Lists all subdirectories in the current directory with the trailing slash removed
ls -d1 */ | tr -d "/"

Lists long format information about file '/bin/echo'.
ls -l /bin/echo

Lists available updates for installed packages.
yum check-update | awk 'p; /Updated packages/ {p=1}'

Lists available updates for installed packages.
yum check-update | awk '{if($5 ~ /updates/){print $1}}' | tr '\n' ','

Lists content of compressed text file.
zless MyFile

Lists content of the current folder.
$ ls

Lists enabled repositories along with debugging information.
yum -v repolist enabled

Lists file descriptors of a current process.
ls -l /proc/self/fd/

Lists installed packages from  'fedora' repository only.
yum list installed  --disablerepo="*" --enablerepo="fedora*"

listing of the files starting from home dir, that have size 50k or less and have extention html."
find . \( -size 100 -o -size -100 \)  -name '*.html' \    -exec  ls -l {} \;  2> /dev/null

Lists tmux sessions.
tmux list-sessions

Locates 'gcc' executable file, strips last two parts of the full path, adds '/lib' to the end and saves result in 'libdir' variable.
libdir=$(dirname $(dirname $(which gcc)))/lib

Locate all "copyright" files under and below /usr/share/doc
find /usr/share/doc -name "copyright"

Locate all `readme.txt' files under the home directory
find ~ -name readme.txt

Locate all *.csv files under the current directory tree separating the file names with zeroes
find . -name "*.csv" -print0

Locate all *.mov files in the current directory tree
find . -name '*.mov'

Locate all .txt files in and below the current directory
find . -name "*.txt"

Locate all files "needle.txt"
find . -name "needle.txt"

Locate all files in the current directory and below that do not have "testfileasdf" in their names
find -not -name "*testfileasdf*"

Locate all files in the current directory and below that have "testfile" in their names
find -name "*testfile*"

Locate all files in the current directory and below that have "testfile" in their names regardless of the case
find -iname "*TESTFILE*"

Locate all files named 'restore.php' in the current directory and 3 levels below
find . -maxdepth 4 -name 'restore.php'

Locate all OGG files that reside in the home directory and have not been accessed in the past 30 days
find $HOME -iname '*.ogg' -atime +30

Locate all passwd files on the system
find / -name passwd

Locate and rename unprintable directories using inode numbers
find . -inum 211028 -exec mv {} newname.dir \;

Locate all the hard links of file `passwd'
find / -samefile passwd

Locate file "file1"
find -name file1

locate large files (> 100 MB) in /home/ for 'cleaning'
find /home -type f -size +100M -delete

locate large files (> 100 MB) in /home/ for 'cleaning'
find /home -type f -size +100M -print0 |xargs -0 rm

Locate files not owned by any user or group
find / -path /proc -prune -o -nouser -o -nogroup

Locate files that reside in the /u/bill directory tree and were last accessed between 2 and 6 minutes ago
find /u/bill -amin +2 -amin -6

Locate files that reside in the home directory and have not been accessed in the past 30 days
find $HOME -atime +30

Locate files whose status was changed less than 1 day ago
find . -ctime -1 -print

Locate files with user permissions rwx owned by my_user
find . -user my_user -perm -u+rwx

Locate logo.gif in the /var/www directory tree
find /var/www -name logo.gif

Locate OGG files under the home directory larger than 100 megabytes
find $HOME -iname '*.ogg' -size +100M

Locate OGG files under the home directory smaller than 100 megabytes
find $HOME -iname '*.ogg' -type f -size -100M

Locate python interpreter and show its human-readable file type description, resolving any symlinks.
file -L $(python -c 'import sys; print(sys.executable)')

Locate symbolic links in /usr and below
find /usr -type l

Locate symlinks in directory trees lpi104-6 and research/lpi104-6
find lpi104-6 research/lpi104-6 -type l

Locate world-writable files and directories on the system
find / -path /proc -prune -o -perm -2 ! -type l -ls

login as user postgres
su - postgres

login as user postgres
sudo su -l oracle

login as user username
su - username

Login in 'whatever.com' as user 'whoever' with X11 forwarding to enable GUI programs on remote to be run
ssh -X whoever@whatever.com

Login to "$HOST" and create file "$FILE_PATH" if it does not exist
ssh -q $HOST "[[ ! -f $FILE_PATH ]] && touch $FILE_PATH"

Login to "host" using identity file "id_rsa"
ssh -i id_rsa host

Login to "user@host" with key "keyFile" and execute "./script arg1 arg2 > output.txt 2>&1" in the background
ssh -i keyFile user@host bash -c "\"nohup ./script arg1 arg2 > output.txt 2>&1 &\""

Login to a bash shell on localhost via ssh and print the bash version
echo 'echo "Bash version: ${BASH_VERSION}"' | ssh -q localhost bash

Login to remote system "app1" through an ssh gateway system called "gw"
ssh -At gw ssh -A app1

Look for "filename" in the current directory and below
find -name filename

Look for "testfile.txt" in the "/" directory and 1 level below
find / -maxdepth 2 -name testfile.txt

Look for `regexp' in binary files
find .  -type f -print|xargs file|grep -i text|cut -fl -d:    | xargs grep regexp

Look for *.jpg files
find . -name “*.jpg”

Look for *.jpg files on the system
find / -name “*.jpg”

Look for *log files in directories at least three levels down the directory tree
find / -mindepth 3  -name "*log"

Look for *log files in directories at most three levels down the directory tree
find / -maxdepth 3  -name "*log"

Look for all files managed by git in the current repository whose name or file type description contains the word "ASCII", display the number of lines contained in each match.
git ls-files | xargs file | grep "ASCII" | cut -d : -f 1 | xargs wc -l

Look for all files whose names match pattern 'my*'
find / -name 'my*'

Look for directory `Cookbook'
find -name Cookbook -type d

Look for file `Chapter1' under /usr and /home
find /usr /home -name Chapter1 -type f

Look for files in the current directory tree to which the group users have full access
find . -perm -070 -print

Look for files whose names begin with letters a-j
find  / -name "[a-j]*" -print

Look for files with wide open permissions
find . -type f  -perm 777 -exec ls -l {} \;

Look for files with wide open permissions
find . -type f  -perm a=rwx -exec ls -l {} \;

Look for files with the name 'search' under current directory
find . -name "search"

(Linux specific) Look for any instance of "HIGHMEM" in the current kernel's compile-time config file.
grep “HIGHMEM” /boot/config-`uname -r`

(Linux-specific) Look for any instance of "ds1337" in the modules.alias file matching current kernel release
grep ds1337 /lib/modules/`uname -r`/modules.alias

Look for any files that have not been modified in the last two days
find -mtime +2

Look for any files that were modified 2-5 days ago
find -mtime +2 -mtime -5

Look for SGID files and directories
find / -perm /g=s

look for the largest 200 files over 1,000,000 bytes in the filesystem mounted at "/usr/pcapps"
find /usr/pcapps/ -mount -type f -size +1000000c | perl -lpe ' s{ }{\\ }g ' | xargs ls -l | sort +4nr | head -200

Look for SUID files and directories
find / -perm +4000

Look in /home/dm and below for files with 'uniform' in their names
find /home/dm -name "*uniform*"

Look in the current directory and below for all files whose names begin with either "my" or "qu"
find . \( -name "my*" -o -name "qu*" \) -print

Lookup information for user "vivek"
finger vivek

Lookup information of the current user
finger `whoami`

Look up for 'myip.opendns.com' in server 'resolver1.opendns.com' and save the terse output in 'IP' variable
IP=$(dig +short myip.opendns.com @resolver1.opendns.com)

Look up IP address of the current host
/usr/sbin/host `hostname`

Make "bar" executable
chmod +x bar

Make "file.sh" executable
chmod +x file.sh

Make $WEEKS_TO_SAVE+1 directories named "weekly.N" where N ranges from 0 to "$WEEKS_TO_SAVE"
mkdir -p $(seq -f "weekly.%.0f" 0 $WEEKS_TO_SAVE)

Make 3 directories named "$HOME/Labs/lab4a/folder" followed by a 3 width zero padded number from 1 to 3
mkdir $(seq -f "$HOME/Labs/lab4a/folder%03g" 3)

Make 3 directories named "~/Labs/lab4a/folder" followed by a 3 width zero padded number from 0 to 3
mkdir $(printf "$HOME/Labs/lab4a/folder%03g " {0..3})

Make 3 directories named "~/Labs/lab4a/folder" followed by the number 1, 2, or 3
mkdir ~/Labs/lab4a/folder{1,2,3}

Make 3 directories named "~/Labs/lab4a/folder" followed by the number 1, 2, or 3
mkdir ~/Labs/lab4a/folder{1..3}

Make 999 folders one inside another where first 998 of them is named as "folderX" where X goes from 1 to 998 and the last folder named as "folder9991000"
mkdir -p folder$( seq -s "/folder" 999 )1000

Make a .tar.bz2 archive of all *.txt files from the dir/ directory tree
find dir/ -name '*.txt' | tar -c --files-from=- | bzip2 > dir_txt.tar.bz2

make a copy of file file1 named file2
su - jetty cp file1 file2

Make a copy of file.txt in all directories in current directory - names may not contain spaces.
ls -d */ | xargs -iA cp file.txt A

Make a copy of file1 in dir1, dir2, and dir3.
echo dir1 dir2 dir3 | xargs -n 1 cp file1

Make a copy of the entire contents of dir1 in the Pictures directory located in the user's home directory.
cp -r dir1/ ~/Pictures/

Make a copy of the entire contents of SRCFOLDER called "DESTFOLDER", if DESTFOLDER exists, the copy will be placed within it.
cp -R SRCFOLDER DESTFOLDER/

Make a directory structure same as the current directory tree under /tmp/tar_root directory
for i in `find . -type d`; do mkdir -p /tmp/tar_root/`echo $i|sed 's/\.\///'`; done

Make a POST request to "http://dweet.io/dweet/for/cycy42" with data "PiIP" set to the IP address of the system
wget --post-data="PiIP=$(hostname -I)" http://dweet.io/dweet/for/cycy42

Make a new directory "new-dir" in every directory in the current directory tree
find . -type d | xargs -I "{x}" mkdir "{x}"/new-dir

Make a new directory "new-dir" in every directory in the current working directory non-recursively
find . -maxdepth 1 -type d | xargs -I "{x}" mkdir "{x}"/new-dir

Make a playlist out of all the mp3 and ogg files in the home directory
find ~ -type f \( -iname '*.mp3' -o -iname '*.ogg' \) > mynewplaylist.m3u

Make all directories in the current directory tree accessible to anybody
find . -type d -print0 | xargs -0 chmod go+rx

Make all regular files in the current directory tree world-readable
find . -type f -print0 | xargs -0 chmod go+r

Make all the bugzilla subdirectories permission 775
find bugzilla -type d -exec chmod 775 {} \;

Make an archive of .txt files from the dir/ directory tree
find dir/ -name '*.txt' | tar -c --files-from=- | bzip2 > dir_txt.tar.bz2

Make directories "./es/es_MX.utf8/LC_MESSAGES" as needed and do not error if it exists
mkdir --parents ./es_MX.utf8/LC_MESSAGES

Make directory "/cpuset"
mkdir /cpuset

Make directory "/data/db"
sudo mkdir /data/db

Make directory "/etc/cron.15sec"
mkdir /etc/cron.15sec

make directory "/etc/cron.15sec"
mkdir /etc/cron.15sec

Make directory "/etc/cron.5minute"
mkdir /etc/cron.5minute

Make directory "/etc/cron.minute"
mkdir /etc/cron.minute

Make directory "/path/to/destination"
mkdir /path/to/destination

Make directory "/tmp/foo"
mkdir /tmp/foo

Make directory "/tmp/googleTestMock"
mkdir /tmp/googleTestMock

Make directory "/tmp/imaginary/" on remote host before archiving "file" to "user@remote:/tmp/imaginary/"
rsync -aq --rsync-path='mkdir -p /tmp/imaginary/ && rsync' file user@remote:/tmp/imaginary/

Make directory "/tmp/new"
mkdir /tmp/new

Make directory "/var/svn"
sudo mkdir /var/svn

Make directories "Labs/lab4a/folder1", "Labs/lab4a/myfolder", and "Labs/lab4a/foofolder"
mkdir Labs/lab4a/{folder1,myfolder,foofolder}

Make directory "TestProject"
mkdir TestProject

Make directories "a", "b", "c", "d", and "e"
mkdir a b c d e

Make directories "a/b/c" as needed without causing an error if it exists
mkdir -p a/b/c

Make directory "aaa"
mkdir aaa

Make directory "aaa/bbb"
mkdir aaa/bbb

Make directory "backup"
mkdir backup

Make directories "bravo_dir" and "alpha_dir"
mkdir bravo_dir alpha_dir

Make directory "certs"
mkdir certs/

Make directory "destdir"
mkdir destdir

Make directory "foo"
mkdir foo

Make directory "foo" and do not cause an error if it exists
mkdir -p foo

Make directories "foo/bar/baz" as needed and do not cause an error if it exists
mkdir -p foo/bar/baz

Make directories "mnt" and "point"
mkdir mnt point

Make directory "mybuild"
mkdir mybuild

Make directory "new_dir"
mkdir new_dir

Make directory "saxon_docs"
mkdir saxon_docs

Make directory "subdirectory"
mkdir subdirectory

Make directory "tata"
mkdir tata

Make directory "temp"
mkdir temp

Make directory "testExpress"
mkdir testExpress

Make directories "tmp/real_dir1" and "tmp/real_dir2" as needed
mkdir -p tmp/real_dir1 tmp/real_dir2

Make directories "~/foo/bar/baz", "~/foo/bar/bif", and "~/foo/boo/bang" as needed
mkdir -p ~/foo/bar/baz ~/foo/bar/bif ~/foo/boo/bang

Make directory "~/log"
mkdir ~/log

Make directory "~/practice"
mkdir ~/practice

Make directory "~/public_html"
mkdir ~/public_html

Make directory "~/temp"
mkdir ~/temp

Make directorie(s) 'es_MX.utf8/LC_MESSAGES' as needed in the current directory
mkdir --parents ./es_MX.utf8/LC_MESSAGES

Make directories a, b, c, ..., z under path2 as needed.
mkdir -p path2/{a..z}

Make directory and parents as needed for each unique mime type in the current directory
mkdir -p `file -b --mime-type *|uniq`

Make directory and parents as needed for the directory name of file "$f"
mkdir -p -- "$(dirname -- "$f")"

Make directory and parents as needed to "$FINALPATH"
mkdir -p "$FINALPATH"

Make directories and parents as needed to "${raw_folder}" and "${split_folder}"
mkdir -p ${raw_folder} ${split_folder}

Make directory and parents as needed to "~/temp/bluecove/target/"
mkdir -p ~/temp/bluecove/target/

Make directories and parents for each file path in "somefile.txt" excluding the file name
xargs -n 1 dirname <somefile.txt | xargs mkdir -p

Make directory expanded by $dir variable
mkdir $dir

Make directories for each line in "folder_list.txt"
cat folder_list.txt | xargs mkdir

Make directories in "/TARGET_FOLDER_ROOT/" for each ".mov" file in the current directory tree
find . -type f -iname \*.mov -printf '%h\n' | sort | uniq | xargs -n 1 -d '\n' -I '{}' mkdir -vp "/TARGET_FOLDER_ROOT/{}"

Make directories to "$2" as needed
mkdir -p $2

Make directories to "$TARGET_PATH" as needed without causing an error if it exists
mkdir -p "$TARGET_PATH"

Make directories to "/my/other/path/here" as needed
mkdir -p /my/other/path/here

Make directories to "/some/path" as needed
mkdir -p ./some/path

Make directories to "/tmp/boostinst" as needed and print a message for each created directory
mkdir -pv /tmp/boostinst

Make directories to "/tmp/test/blah/oops/something" as needed
mkdir -p /tmp/test/blah/oops/something

Make directories to "directory{1..3}/subdirectory{1..3}/subsubdirectory{1..2}" as needed
mkdir -p directory{1..3}/subdirectory{1..3}/subsubdirectory{1..2}

Make directories to "x/p/q" as needed
mkdir -p x/p/q

Make directories to file "/full/path/to/file.txt" as needed
mkdir -p `dirname /full/path/to/file.txt`

Make hidden directory ".hiddendir"
mkdir .hiddendir

Make DNS lookup for hostname stackoverflow.com
dig stackoverflow.com

Make DNS lookup requests for domain list in file '/path/to/host-list.txt'
dig -f /path/to/host-list.txt

Make regular files from debian/fglrx-amdcccle/usr/lib/fglrx/bin/ executable for all
find debian/fglrx-amdcccle/usr/lib/fglrx/bin/ -type f | xargs chmod a+x

Make sure the file ".bash_profile" exists in current directory, update its timestamp to current date/time.
touch .bash_profile

To match only hidden dot directories
find /nas01/backups/home/user/ -type d -name ".*" -print0 -exec ls -lrt {} \;

Mathematically add each line in "filename"
paste -sd+ filename | bc

Mathematically sum a column of numbers in "FileWithColumnOfNumbers.txt"
cat FileWithColumnOfNumbers.txt | xargs ruby -e "puts ARGV.map(&:to_i).inject(&:+)"

Mathematically sum all lines in "filename"
cat filename | python -c"from fileinput import input; print sum(map(int, input()))"

Mathematically sum all lines in "filename"
cat filname | lua -e "sum = 0;for i in io.lines() do sum=sum+i end print(sum)"

Mathematically sum all lines in "infile"
sed 's/^/.+/' infile | bc | tail -1

Mathematically sum all numbers in "numbers.txt"
cat numbers.txt | php -r "echo array_sum(explode(PHP_EOL, stream_get_contents(STDIN)));"

Mathematically sum each line in "infile"
paste -s -d+ infile | bc

Mathematically sum each line in "infile"
paste -sd+ infile | bc

Md5sum the last 5 files in /directory1/directory2/
find /directory1/directory2/ -maxdepth 1 -type f | sort | tail -n 5 | xargs md5sum

Measure the disk space taken up by all *.txt files in directory trees folder1 and folder2
find folder1 folder2 -iname '*.txt' -print0 | du --files0-from - -c -s | tail -1

Measure the disk space taken up by all *.txt files in the /path directory tree
find /path -iname '*.txt' | perl -lane '$sum += -s $_; END {print $sum}'

Measure the execution time of the command: find /usr/src -name "*.html" -exec grep -H "foo" {} ';' | wc -l
time find /usr/src -name "*.html" -exec grep -H "foo" {} ';' | wc -l

Merge already sorted files "*.txt" and split the result into files of at most 1000000 lines each with a numeric suffix and a prefix "output"
sort -m *.txt | split -d -l 1000000 - output

Merge already sorted files "file*.txt" and split the result into files of at most 100000 lines each with a prefix "sorted_file"
sort --merge file*.txt | split -l 100000 - sorted_file

Merge already sorted files in the current directory ending in ".$suffix"
sort -m *.$suffix

Merge already sorted files in the current directory starting with "_tmp" and write the output to "data.tsv.sorted"
sort -m _tmp* -o data.tsv.sorted

Merge colon-separated information from file1 and file2 where first field of both files matches
join -t: <(sort file1) <(sort file2)

Merge colon-separated information from file1 and file2 where second field of both files matches, sorting the result based on this field - for each line, output: first 3 fields of first file, followed by first 3 fields of second file.
join -o 1.1,1.2,1.3,2.1,2.2,2.3 -j2 <(sort -k2 file1) <(sort -k2 file2)

Merge colon-separated information from standard input and file1.txt where the first field of both files matches, print unpairable lines from both files, replace missing fields with "no-match", and output the second field from standard input and the second and third field from file1.txt
join -t, -o 1.2,2.2,2.3 -a 1 -a 2 -e 'no-match' - <(sort file1.txt)

Merge colon-separated information from standard input and file1.txt where the first field of both files matches, print unpairable lines from standard input, replace missing fields with "no-match", and output the second field from standard input and the second and third field from file1.txt
join -t, -o 1.2,2.2,2.3 -a 1 -e 'no-match' - <(sort file1.txt)

Merge content of decompressed files "$part0", "$part1", and so on
sort -m <(zcat $part0 | sort) <(zcat $part1 | sort) ...

Merge data in file1 and file2 where second field is common in both files
join -j2 <(sort -k2 file1) <(sort -k2 file2)

Merge each line in "file" into a single comma separated line
paste -d, -s file

Merge each line of standard input into a single comma separated line
paste -s -d","

Merge each non-blank line of standard input into a single comma separated line
grep -v '^$' | paste -s -d"," -

Merge file1 and file2 by outputting all lines where the first comma-separated field of both files matches, followed by extra fields in file1 and those in file2
join -t, <(sort file1) <(sort file2)

Merge files 'text.txt' and 'codes.txt' by outputting any lines whose second field in the first matches the first field in the second.
join -1 2 -2 1 text.txt codes.txt

Merge lines from "file_1" and "file_2" and format the output as a table with tab separators
paste file_1 file_2 | column -s $'\t' -t

Merge lines whose first comma-separated field in file 'in1' also appears as a first comma-separated in file 'in2' - both files must be sorted, and the output format of each line will be: first field of in1, second field of in2, and third field of in2.
join -t, -o 1.1,1.2,2.3 in1 in2

Merge the first "$lc" lines of "current.txt" and the last "$lc" lines of "current.txt" and display the result as a comma separated table
paste <(head -"$lc" current.txt) <(tail -"$lc" current.txt) | column -t -o,

Fix files to default permissions 644
find . -type f -exec chmod 644 {} \;

Fix files to default permissions 755
find . -type d -exec chmod 755 {} \;

Fix permissions for a group of files with given extension
find /usr/local -name "*.html" -type f -exec chmod 644 {} \;

Modify interval to 0.1 seconds for the watch command
watch -n 0.1

modify the permissions of all the folders in a directory
find /path/to/dir -type d -exec chmod 755 {} \;

Monitor 3 specific process IDs: 18884, 18892, and 18919 (GNU specific)
top -p 18884 -p 18892 -p 18919

(GNU specific) Monitor all processes whose command contains 'http'.
top -p $(pgrep -d',' http)

(GNU specific) Monitor all processes whose command includes 'java'.
top -p "$(pgrep -d ',' java)"

(GNU specific) Monitor all processes whose command includes 'process-name'.
top -p `pgrep process-name | tr "\\n" "," | sed 's/,$//'`

(GNU specific) Monitor only processes whose command contains string_to_match_in_cmd_line.
top -c -p $(pgrep -d',' -f string_to_match_in_cmd_line)

(GNU specific) Monitor process activity, starting with the last remembered "c" state reversed: typing "c" toggles between using process names or full command lines.
top -c

move all files in the current folder another folder and do not move the files in the sub folder
find . -name "*" -maxdepth 1 -exec mv -t /home/foo2/bulk2 {} +

move all files in the current folder another folder and do not move the files in the sub folder
find . -name "*" -maxdepth 1 -exec sh -c 'mv "$@" "$0"' /home/foo2/bulk2 {} +

move all the files in the current folder  to temp folder and search atleast in one subfolder
find . -mindepth 1 -exec mv -t /tmp {} +

move all the files in the current folder  to temp folder and search atleast in one subfolder
find . -mindepth 1 -print0|xargs -0 -I, mv , /tmp

move all the html files from current folder to another folder and if a symbolic link is found copy the original referenced file and not the link
find . -follow -iname '*.htm' -print0 | xargs -i -0 mv '{}' ~/webhome

move files accessed more than one day ago to directory TMP
find . -atime +1 -type f -exec mv {} TMP \; # mv files older then 1 day to dir TMP

Moves the file that named like file $1 from '/tmp' folder to the folder where $2 file is located.
mv "/tmp/`basename $1`" "`dirname $2`"

gives the chars in line 5 and chars 5 to 8 of line 5, in tst.txt
head -5 tst.txt | tail -1 |cut -c 5-8

Moves (change order) window from 4 place to 3.
tmux movew -s 4 -t 3

Non-recursively finds all '*.pdf' files in a current folder and removes them.
find -maxdepth 1 -name '*.pdf' -exec rm "{}" \;

Non-recursively finds all '*.pdf' files in a current folder and removes them.
find . -maxdepth 1 -name "*.pdf" -print0 | xargs -0 rm

Normalize the path to command "rename" resolving any symlinks, and display what type of file it is.
file $(readlink -f $(type -p rename))

Number each line in "/etc/passwd" as right-justified zero padded to a width of 9
nl -nrz -w9  /etc/passwd

Number each line in "foobar" as right-justified zero padded to a width of 9
nl -nrz -w9 foobar

Number each non-blank line of standard input
nl

Number every line of standard input as zero padded to 6 characters followed by "-"
nl -s- -ba -nrz

Numberically sort content of file 'files', using for sorting part of second one of dash separated fields beginning from second letter.
cat files | sort -t- -k2,2 -n

Numerically sort each line in file "bb" and output the result to console from greatest value to least value
sort -nr bb

Numerically sort each line in file "out" and print the result to console
sort -n out

Numerically sort each line of standard input
sort -n

Numerically sort file "files" by the second "-" separated value of each line ordered from least value to highest value
tac files | sort -t- -k2,2 -n

Numerically sort file "temp.txt" by the second "-" separated value of each line ordered from highest value to least value
tac temp.txt | sort -k2,2 -r -u

Numerically sort IPv4 addresses specified on standard input with presedence to first, second, third, then fourth octet
tr '.' ' ' | sort -nu -t ' ' -k 1 -k 2 -k 3 -k 4 | tr ' ' '.'

Numerically sort standard input by the second word of each line
sort -n -k 2

Numerically sort standard input by the second word of each line and output from greatest value to least value
sort -nrk 2,2

On host "server_b", connect as ssh user "user" and copy "/my_folder/my_file.xml" to directory "/my_new_folder/".
scp user@server_b:/my_folder/my_file.xml user@server_b:/my_new_folder/

On host "server_b", connect as ssh user "user" and copy "/my_folder/my_file.xml" to directory "/my_new_folder/", with all transfer data relayed through local host.
scp -3 user@server_b:/my_folder/my_file.xml user@server_b:/my_new_folder/

Move "/usr/bin/openssl" to directory "/root/"
mv /usr/bin/openssl /root/

Move "file.txt" to docker container "$COUNTAINER_ID" in path "/var/lib/docker/aufs/mnt/$CONTAINER_ID/rootfs/root/file.txt"
mv -f file.txt /var/lib/docker/aufs/mnt/$CONTAINER_ID/rootfs/root/file.txt

Move "phantomjs-1.8.1-linux-x86_64.tar.bz2" to "/usr/local/share/" directory
sudo mv phantomjs-1.8.1-linux-x86_64.tar.bz2 /usr/local/share/.

cope *.mp3 files to /tmp/MusicFiles
find . -type f -name "*.mp3" -exec cp {} /tmp/MusicFiles \;

Move *wp-admin/index.php files under /var/www/  to ./index_disabled
find /var/www/ -path '*wp-admin/index.php' -exec mv {} $(dirname {})/index_disabled

Move *wp-admin/index.php files to *wp-admin/index_disabled under /var/www/
find /var/www/ -path '*wp-admin/index.php' | xargs -i sh -c 'mv {} $(dirname {})/index_disabled'

Move all *$lower1* files/directories under current directory to paths formed by replacing the match of $lower1 with $lower2 in their paths
find . -name "*$lower1*" -exec bash -c 'mv "$1" "${1/$2/$3}"' -- {} $lower1 $lower2 \;

Move all *.data files/directories in $S directory to $S/data/ directory
find "${S}" -name '*.data' -exec mv '{}' "${S}/data/" \;

Move all *.log files under $sourcePath that were modified more than 10 days ago to a zip archive $zipFile with only file names (not full path)
find $sourcePath -type f -mtime +10 -name "*.log" | xargs zip -jmT $zipFile -@

Move all *.mp4 files from directory /foo/bar and its subdirectories to /some/path
find /foo/bar -name '*.mp4' -exec mv -t /some/path {} +

Move all *.mp4 files from directory /foo/bar and its subdirectories to /some/path
find /foo/bar -name '*.mp4' -print0 | xargs -0 mv -t /some/path {}

Move all *.pdf.marker files and their corresponding *.pdf files under ${INPUT_LOCATION} to ${OUTPUT_LOCATION}
find "${INPUT_LOCATION}" -name '*.pdf.marker' | xargs -i bash -cx 'pdf=`dirname {}`/`basename {} .marker`;[ -e "$pdf" ]&&{ mv {} "$pdf" "$0";}' "${OUTPUT_LOCATION}"

Move all *.pdf.marker files and their corresponding *.pdf files under ${INPUT_LOCATION} to ${OUTPUT_LOCATION}
find $INPUT_LOCATION -name '*.pdf.marker' -exec bash -c 'mv ${0%.marker} $0 $1' {} $OUTPUT_LOCATION \;

Move all *.pdf.marker files and their corresponding *.pdf files under ${INPUT_LOCATION} to ${OUTPUT_LOCATION}
find $INPUT_LOCATION -name '*.pdf.marker' | xargs -i bash -c 'mv ${0%.marker} $0 $1' {} $OUTPUT_LOCATION

Move all *.pdf.marker files and their corresponding *.pdf files under ${INPUT_LOCATION} to ${OUTPUT_LOCATION}
find ${INPUT_LOCATION} -name '*.pdf.marker' -exec sh -c 'mv $0 `dirname $0`/`basename $0 .marker` $1' {} ${OUTPUT_LOCATION} \;

Move all *.pdf.marker files and their corresponding *.pdf files under ${INPUT} to ${OUTPUT}
find ${INPUT}/ -name "*.pdf" -exec mv '{}' '{}'.marker ${OUTPUT} \;

Move all *.pdf.marker files and their corresponding *.pdf files under ${INPUT} to ${OUTPUT}
find ${INPUT}/ -name "*.pdf" -exec test -e '{}'.marker \; -exec mv '{}' '{}'.marker ${OUTPUT} \;

Move all *.php~ (case insensitive) files under current directory to /mydir
find . -iname "*.php~" -exec mv "{}" /mydir +;

Move all *.php~ (case insensitive) files under current directory to /mydir
find . -iname "*.php~" -exec mv {} /mydir \;

Move all *.php~ (case insensitive) files under current directory to /mydir
for D in `find . -iname "*.php~"`; do mv ${D} /mydir; done

Move all *foo* (case insensitive) directories under current directory to new paths obtained by replacing all occurrences of 'foo' (case insensitive) with 'Bar' in their paths
find . -type d -iname '*foo*' -exec bash -O nocasematch -c '[[ $1 =~ (foo) ]] && mv "$1" "${1//${BASH_REMATCH[1]}/Bar}"' -- {} \;

Move all directories from the `sourceDir' directory tree to the `destDir' directory
find sourceDir -mindepth 1 -type d  -exec mv -t destDir "{}"  \+

Move all directories from the `sourceDir' directory tree to the `destDir' directory
find sourceDir -mindepth 1 -type d  -print0 | xargs -0 mv --target-directory=destDir

Move all directories in the current directory that match "some-dir" to "x/"
find ./ -maxdepth 1 -name "some-dir" -type d -print0 | xargs -0r mv -t x/

Move all directories in the current directory tree that have been modified in the last day to "/path/to/target-dir"
find . -depth -type d -mtime 0 -exec mv -t /path/to/target-dir {} +

Move all directories in the current directory tree that have been modified in the last day to "/path/to/target-dir"
find . -type d -mtime -0 -exec mv -t /path/to/target-dir {} +

Move all directories in the current directory tree that have been modified in the last day to "/path/to/target-dir"
find . -type d -mtime -0 -print0 | xargs -0 mv -t /path/to/target-dir

Move all directories under current directory to new paths obtained by replacing all occurrences of 'foo' with 'Bar' in their paths
find . -type d -exec bash -c 'mv "$1" "${1//foo/Bar}"' -- {} \;

Move all Emacs backup files from the current directory tree to ~/backups/
find . -name '*~' -print 0 | xargs -0 -I % cp % ~/backups

Move all hidden files in "wordpress" to the current directory
mv wordpress/.* .

Move all files and directories in the current directory to "/tmp/blah/"
find . -depth=1 -exec mv {} /tmp/blah/ \;

Move all files and directories in the current directory to "/tmp/blah/"
mv * /tmp/blah/

Move all files/directories under current directory to ~/play
find . -exec mv '{}' ~/play/ \;

Move all files/directories under current directory to ~/play
find . | xargs -I'{}' mv '{}' ~/play/

Move all files and directories matching "*.boo" in the current directory to "subdir"
mv `ls *.boo` subdir

Move all files and directories not starting with "l" in "/mnt/usbdisk" to "/home/user/stuff/."
mv /mnt/usbdisk/[^l]* /home/user/stuff/.

Move all files from "src/test/" to "dest" displaying progress
rsync -a --progress --remove-source-files src/test/ dest

Move all files from the `sourceDir' directory to the `destDir' directory
find sourceDir -mindepth 1 -maxdepth 1 -exec mv --target-directory=destDir '{}' +

Move all files from the `sourceDir' directory to the `destDir' directory
find sourceDir -mindepth 1 -maxdepth 1 -print0 | xargs -0 mv --target-directory=destDir

Move all files from the `sourceDir' directory tree to the `destDir' directory
find sourceDir -mindepth 1 -exec mv "{}" --target-directory=destDir \;

Move all files from the `sourceDir' directory tree to the `destDir' directory
find sourceDir -mindepth 1 -print0 | xargs -0 mv --target-directory=destDir

Move all files from the current directory to "targetdirectory"
find . ! -name . -prune -exec sh -c 'mv "$@" targetdirectory/' sh  {} +

Move all files from the current directory to "targetdirectory"
find . ! -name . -prune -exec sh -c 'shift $1; mv "$@" targetdirectory/' 2 1 {} +

Move all files in "/path/subfolder" to "/path" without clobbering any destination files
find /path/subfolder -maxdepth 1 -type f -name '*' -exec mv -n {} /path \;

Move all files in the current directory tree that match "some_pattern" to "target_location"
find . -name some_pattern -print0 | xargs -0 -I % mv % target_location

Move all files in the current directory tree that match "some_pattern" to "target_location"
find . -name some_pattern -print0 | xargs -0 -J % mv % target_location

Move all files including hidden files and excluding ".." in "/path/subfolder/" to "/path/"
mv /source/path/{.[!.],}* /destination/path

Move all files excluding hidden files in "/path/subfolder/" to "/path/"
mv /path/subfolder/* /path/

Move all files including hidden files in "/path/subfolder/" to "/path/"
mv /path/subfolder/{.,}* /path/

Move all files listed in $i file to dir.$count directory
cat $i | xargs mv -t dir.$count

Move all files matching case insensitive ".cpp" in the current directory tree to "./test/"
find . -type f -iname '*.cpp' -exec mv -t ./test/ {} \+

Move all files matching patterns "*.old", ".old", ".*.old" from the current directory to directory "../old/"
find . ! -name . -prune -name '*.old' -exec mv {} ../old/ \;

Move all files matching patterns "*.old", ".old", ".*.old" from the current directory to directory "../old/"
find . ! -name . -prune -name '*.old' -exec sh -c 'mv "$@" ../old/' sh {} +

Move all files not matching "Tux.png" in "~/Linux/Old" to "~/Linux/New/" using zsh with "EXTENDED_GLOB"
mv ~/Linux/Old/^Tux.png ~/Linux/New/

Move all files that contain "Subject: \[SPAM\]" to "DIR"
grep -L -Z -r 'Subject: \[SPAM\]' . | xargs -0 -I{} mv {} DIR

Move all files that contain "Subject: \[SPAM\]" to "DIR"
grep -l 'Subject: \[SPAM\]' | xargs -I '{}' mv '{}' DIR

Move all files that contain "Subject: \[SPAM\]" to "your_file"
grep -L -r 'Subject: \[SPAM\]' . | while read f; do mv "$f" out; done

Move all regular files under current directory to ./newdir
find ./ -type f -print | xargs    -i mv -f {} ./newdir

Move all regular files under current directory to ./newdir
find ./ -type f -print | xargs    -l56 -I {} mv -f {} ./newdir

Move all the .c files from the current directory tree to temp/
find . -name "*.c" -print0 | xargs -0 -n1  -I '{}' mv '{}' temp

Move each of the 'm?' directories in $path_to_folders to another directory whose name is constituted by appending .mbox to each directory name and create a directory named Messages in this directory then move all *.emlx files into this directory
find "$path_to_folders" -name 'm?' -type d -exec mv {} {}.mbox \; -exec mkdir {}.mbox/Messages \; -exec sh -c "mv {}.mbox/*.emlx {}.mbox/Messages" \;

Move each of the 'm?' directories in current directory to another directory whose name is constituted by appending .mbox to each directory name and create a directory named Messages in this directory then move all *.emlx files into this directory
find . -name 'm?' -type d -exec mv '{}' '{}.mbox' ';' -exec mkdir '{}.mbox/Messages' ';' -exec sh -c 'mv {}.mbox/*.emlx {}.mbox/Messages' ';'

Move each of the directories in /path/to/folders/* to another directory whose name is constituted by appending .mbox to each directory name and create a directory named Messages in this directory
find /path/to/folders/* -type d -exec mv {} {}.mbox \; -exec mkdir {}.mbox/Messages \;

Move each of the directories in /path/to/folders/* to another directory whose name is constituted by appending .mbox to each directory name and create a directory named Messages in this directory then move all *.emlx files into this directory
find /path/to/folders/* -type d  -exec mv {} {}.mbox \; -exec mkdir {}.mbox/Messages \; -exec sh -c "mv {}.mbox/*.emlx {}.mbox/Messages" \;

only get md5sum of a file
md5 -q file

Move files from $sourcePath to $destPath that have not been modified in the last 10 days
find $sourcePath -type f -mtime +10 -name "*.log" -exec mv {} $destPath \;

Move files older than 1 day to directory TMP
find . -atime +1 -type f -exec mv {} TMP \;

DNS lookup of the current host
nslookup `hostname`

Move server.log to 'logs' directory with new name as the current date formatted as "%Y%m%d%H%M" and with '.log' extension
mv server.log logs/$(date -d "today" +"%Y%m%d%H%M").log

Move the directory named "some-dir" and residing under the current one to x/
find ./ -maxdepth 1 -name "some-dir" -type d -print0 | xargs -0r mv -t x/

Opens gawk info manual and goes to command-line options node.
info -O gawk

Opens menu item 'Basic Shell Features' -> 'Shell Expansions' -> 'Filename Expansion' -> 'Pattern Matching' in the 'bash' manual.
info bash 'Basic Shell Features' 'Shell Expansions' 'Filename Expansion' 'Pattern Matching'

Opens gcc info manual and goes to a node pointed by index entry "funroll-loops".
info gcc --index-search=funroll-loops

Opens gcc info manual and selects "option index" menu entry.
info gcc "option index"

Output "file.txt", omitting all containing directories "some/unknown/amoutn/of/sub/folder/"
basename "some/unknown/amount/of/sub/folder/file.txt"

Output "stuff", removing "/foo/bar/" from the specified path.
basename /foo/bar/stuff

Output "testFile.txt.1" without the ".1" suffix.
basename testFile.txt.1 .1

Output all lines from file1 except those present in file2.
diff --new-line-format="" --unchanged-line-format="" <(sort file1) <(sort file2)

Output all lines from file1 except those present in file2, assuming both files are sorted.
diff --new-line-format="" --unchanged-line-format=""  file1 file2

Output all lines that have a common first colon-separated field in files 'selection2.txt' and 'selection1.txt' by displaying the common (first) field of each line, followed by the extra fields in both lines.
join -t: selection2.txt selection1.txt

Output only the filetype suffix of "foo.tar.gz", in this case "gz"
echo "foo.tar.gz" | rev | cut -d"." -f1 | rev

Output success.txt omitting lines whose first field appears in fail.txt - lines in fail.txt must appear in the same order as they do in success.txt.
join -v1 success.txt fail.txt

Output the base name of first argument to script or function, that is the part following the last slash.
echo $(basename "$1")

Output the specified path removing all containing directories and the .txt suffix, in this case "filename".
basename /path/to/dir/filename.txt .txt

Output the string 'yes' continously until killed
yes

Output the variable "filename" without the last dot-separated section.
echo ${filename%.*}

Output two lines of "-tcp"
yes -- "-tcp" | head -n 2

Output two lines of "-tcp"
yes -- -tcp | head -n 2

Overwrite a file 'my-existing-file' with random data to hide its content
shred my-existing-file

Overwrites file $FILE with random content, then truncates and deletes it.
shred -u $FILE

Overwirte file '/path/to/your/file' with random content, showing progress while execution.
shred -v -n 1 /path/to/your/file #overwriting with random data

Overwirte file '/path/to/your/file' with random content, then overwrite with zeroes, and remove, showing progress while execution.
shred -v -n 1 -z -u /path/to/your/file

Overwrites file 'filename' with random content 35 times, finally writes it with zeros, truncates and deletes.
shred -uzn 35 filename

Case insensitive search using find command in Linux
find . –iname "error" –print ( -i is for ignore )  find . –iname "error" –print ( -i is for ignore )

Page interactively through the output of running 'command' - the arrow keys move the view around, the < and > keys go to the beginning/end of the output, the / key initiates a search, the Q key quits, etc.
command | less

Page through extended information about all PCI devices on system.
lspci -v -v | less

(Linux-specific) Page through extended USB information.
sudo lsusb -v|less

Page through the disassembler output of objdump on executable file 'my-crashing-program'.
objdump --disassemble my-crashing-program | less

Page through the information of the system's PHP setup.
less -f <(php -i)

Page through the output of 'some_command' positioning the view at the first occurrence of regular expression 'regex'.
some_command | less -p regex

Parse "file.json" to print JSON "title" entries whose "price" are less than 10
cat file.json | python -c "import sys, json, jsonpath; print '\n'.join(jsonpath.jsonpath(json.load(sys.stdin), 'store.book[?(@.price < 10)].title'))"

Parse XML file "example.xml" and extract and number all "key" tags from the "config" section
xmllint example.xml --xpath "/config/*/@*" | sed "s| key|\nkey|g" | nl

Perform a default Plesk configuration
find /var/www/vhosts/*/httpdocs -type f -iwholename “*/wp-includes/version.php” -exec grep -H “\$wp_version =” {} \;

Perform a dry run replacing "special" with "regular" in all file names in the current directory
rename -n 's/special/regular/' **

Perform a dry run to recursively copy "test/a" to "test/dest" excluding "test/a/b/c/d"
rsync -nvraL test/a test/dest --exclude=a/b/c/d

perform a case insensitive search
find  / -type d -iname "apt" -ls

Perform a case insensitive search for *.jpg files which are greater than 500KB in size under /ftp/dir/ directory
find /ftp/dir/ -size +500k -iname "*.jpg"

Perform a case insensitive search for *filename* files/directories under current directory tree
find . -iname "*filename*"

Perform a white space safe search for all files/directories under current directory
find . -print0 | xargs -0

Perform case insensitive search for *.gif files/directories under downloads directory
find downloads  -iname "*.gif"

Perform white space safe deletion of files named core under /tmp
find /tmp -name core -type f -print0 | xargs -0 /bin/rm -f

Places current job to background.
bg %  so it wont die when you logoff

Pair side-by-side content of the 'file' and its side-mirrored content
paste -d ' ' file <(rev file)

Prefix all files and directories in the current directory with "Unix_"
ls | xargs -I {} mv {} Unix_{}

Prefix all files and directories in the current directory with "Unix_" if the files contain no whitespace or subdirectories
for FILENAME in *; do mv $FILENAME Unix_$FILENAME; done

Prefix all files and directories in the current directory with "unix_"
ls | xargs -i mv {} unix_{}

Prefix all files and folders in the current directory with "PRE_"
find * -maxdepth 0 ! -path . -exec mv {} PRE_{} \;

Prefix all files and folders in the current directory with "PRE_"
ls | xargs -I {} mv {} PRE_{}

Prefix all files in the current directory with "unix_"
for f in *; do [[ -f "$f" ]] && mv "$f" "unix_$f"; done

Prefix each non-blank line in "filename" with a line number
nl filename

Prepends date to ping output
ping www.google.com | while read endlooop; do echo "$(date): $endlooop"; done

Prepends date to ping output
ping www.google.fr | while read pong; do echo "$(date): $pong"; done

Preprocess C++ file 'omnitest.cpp' (resolve all preprocessor directives) and page interactively through the result.
g++ omnitest.cpp -E | less

Prepend "foo" to the file "bar"
{ echo foo; cat bar; } | tee bar > /dev/null

Represent current date in RFC 3339 format with precision to seconds and save it to 'timestamp' variable
timestamp=`date --rfc-3339=seconds`

prevents curl from returning error (23) Failed writing body when grepping for foo
curl "url" | tac | tac | grep -qs foo

Prepend date to ping output to google.com
ping google.com | xargs -L 1 -I '{}' date '+%+: {}'

Represent the current time as seconds since epoch and save it to variable 'TODAY'
TODAY=$(date  -d "$(date +%F)" +%s)

Represent the UTC date given in time string "1970.01.01-$string1" as number of seconds since the epoch and save it in 't1' variable
t1=$(date -u -d "1970.01.01-$string1" +"%s")

Prepend the reverse history number to the output of the history command with arguments "$@"
history "$@" | tac | nl | tac

Prepend time stamps to entries in "/path/to/log" as they appear and write to "/path/to/log-with-timestamps"
tail -f /path/to/log | perl -pne 'print scalar(localtime()), " ";' > /path/to/log-with-timestamps

Represent time string $MOD_DATE as seconds since epoch and save to variable 'MOD_DATE1'
MOD_DATE1=$(date -d "$MOD_DATE" +%s)

Print "#include" statements found in "file2" that are not in "file1"
comm -13 <(grep '#include' file1 | sort) <(grep '#include' file2 | sort)

Print "$1" or default 10 random lines from standard input
nl | sort -R | cut -f2 | head -"${1:-10}"

Prints "$NEWFILE" to the terminal and file '/etc/timezone' as a root user.
echo "$NEWFILE" | sudo tee /etc/apt/sources.list

Print "$line" in hexadecimal 2-byte units
echo -n $line | od -x

Print "$somedir is empty" if $somedir is empty
find "$somedir" -maxdepth 0 -empty -exec echo {} is empty. \;

Print "*Checking Partition Permission* Hostname=$(hostname) LastChecked=" followed by the current date
echo -n *Checking Partition Permission* Hostname=$(hostname) LastChecked=$(date)

Print "/tmp/myfile" starting at line 11
tail -n +11 /tmp/myfile

Print  "Cannot acquire lock - already locked by " followed by content of $lockfile file
echo "Cannot acquire lock - already locked by $(cat "$lockfile")"

Print "I am USER and the program named ls is in LS_PATH" where "USER" is the current user's user name and "LS_PATH" is the full path of the command "ls"
echo I am $(whoami) and the program named ls is in $(which ls).

Print "Mounted" if /mnt/myUSBdisk exists on a mounted file system or print "Not mounted" otherwise.
df /mnt/myUSBdisk | grep -q /mnt/myUSBdisk && echo "Mounted" || echo "Not mounted"

Print "RDBMS exit code : $RC  " to the console and append to "${LOG_FILE}"
echo " RDBMS exit code : $RC  "     | tee -a ${LOG_FILE}

Print "Shared Memory" if shared memory mounted at /tmp or print "Not Shared Memory" otherwise.
df /tmp | grep -q tmpfs && echo "Shared Memory" || echo "Not Shared Memory"

Print "This is a sentence." by replacing all consecutive space characters with a single newline character
echo "This is   a sentence." | tr -s " " "\012"

Print "Total generated: " followed by the number of unique lines in "$generated_ports"
echo "Total generated: $(echo "$generated_ports" | sort | uniq | wc -l)."

Print "a\nb\ncccccccccccc\nd" as two columns and neatly format into a table
echo -e "a\nb\ncccccccccccc\nd" | paste - - | column -t

Print "deb http://ppa.launchpad.net/webupd8team/java/ubuntu precise main" and append to file "/etc/apt/sources.list"
echo "deb http://ppa.launchpad.net/webupd8team/java/ubuntu precise main" | tee -a /etc/apt/sources.list

Print "deb-src http://ppa.launchpad.net/webupd8team/java/ubuntu precise main" and append to file "/etc/apt/sources.list"
echo "deb-src http://ppa.launchpad.net/webupd8team/java/ubuntu precise main" | tee -a /etc/apt/sources.list

Print "echo ping -c 2" on each string in file 'ips'
cat ips | xargs -n1 echo ping -c 2

Print "echo ping -c 2" on each string in file 'ips'
cat ips | xargs echo ping -c 2

Print "file1.txt" "file2.txt" and "file3.txt" with filename headers
tail -n +1 file1.txt file2.txt file3.txt

Print "found" if "blah" contains the hex byte string "\xCA\xFE\xBA\xBE"
cat blah | perl -en '/\xCA\xFE\xBA\xBE/ && print "found"'

Print "hello" followed by the current user name
echo hello `whoami`

Print "huge-file.log" starting at line 1000001
tail -n +1000001 huge-file.log

Print "huzzah" if directory "/some/dir" is empty
find /some/dir/ -maxdepth 0 -empty -exec echo "huzzah" \;

Print "new.txt" with line numbers prepended
cat new.txt  | nl

Print "on" to standard output and to files matching "/sys/bus/usb/devices/usb*/power/level"
echo "on" | tee /sys/bus/usb/devices/usb*/power/level

Print "test=hello world"
echo "hello world" | echo test=$(cat)

Print $d if $d is an empty directory
find "$d" -prune -empty -type d

Print '"HTTP/1.1 200 OK', two new lines and the current date
echo -e "HTTP/1.1 200 OK\n\n $(date)"

Print '-exec is an action so an implicit -print is not applied' for every file/directory found by the name 'file' under current directory tree
find -name file -exec echo '-exec is an action so an implicit -print is not applied' \;

Print '-ok is an action so an implicit -print is not applied' with confirmation from the user for each file or directory found by the name 'file' under current directory tree
find -name file -ok echo '-ok is an action so an implicit -print is not applied' \;

Print '-okdir is an action so an implicit -print is not applied' for each file/directory found by the name 'file' under current directory tree
find -name file -okdir echo '-okdir is an action so an implicit -print is not applied' \;

Print '111 22 3\n4 555 66\n' by replacing the spaces with tabs and '\n' with newlines
echo -en '111 22 3\n4 555 66\n' | tr ' ' '\t'

Print 'Empty dir' if $some_dir is empty
if find "`echo "$some_dir"`" -maxdepth 0 -empty | read v; then echo "Empty dir"; fi

Print 'Empty dir' if $some_dir is empty
if find /some/dir/ -maxdepth 0 -empty | read v; then echo "Empty dir"; fi

Print 'Empty dir' if $some_dir is empty, otherwise print 'Dir is NOT empty'
if find "`echo "$some_dir"`" -maxdepth 0 -empty | read v; then echo "Empty dir"; else "Dir is NOT empty" fi

Print 'Since -printf is an action the implicit -print is not applied\n' for every file named 'file' found under current directory tree
find -name file -printf 'Since -printf is an action the implicit -print is not applied\n'

Print 'bla.txt' if at least one file with such name is present below the current directory.
ls -alFt `find . -name "bla.txt"` | rev | cut -d" " -f1 | rev | head -1

Print 'cp' commands that would copy a file xyz.c to all the files with '.c' extension present in the ./C directory and below
find ./C -name "*.c" | xargs -n1  echo cp xyz.c

Print 'echo 'hello, world'
echo 'hello, world' | cat

Print 'empty' if $some_dir is an empty directory, otherwise print 'not empty'
find "$some_dir" -prune -empty -type d | read && echo empty || echo "not empty"

Print 'empty' if aaa/ is an empty directory
[ -z "$(find aaa/ -maxdepth 1 -type f)" ] && echo "empty"

Print 'file' content, formatting output as 29-symbol wide column
cat file | fold -w29

Print 'file' content, formatting output as 29-symbol wide column, regarding space symbol as a word separator
cat file | fold -s -w29

Print 'huzzah' if /some/dir/ is empty
find /some/dir/ -maxdepth 0 -empty -exec echo "huzzah" \;

Print 'infile' content with line numbers
cat -n infile

Prints +-10 lines around $LINENUM in filename
head -<$LINENUM + 10> filename | tail -20

Print /some/dir/ if it's empty
find /some/dir/ -maxdepth 0 -empty

Print 1 byte from "/dev/urandom" as a signed decimal value and no address radix
od -A n -t d -N 1 /dev/urandom

Print 1 to 10 by separating them with colon (':')
echo {1..9}: 10 | tr -d ' '

Print 10 "#" characters in a row
yes '#' | head -n 10 | tr -d '\n'

Print 10 space padded "x"s to a width of 10 with at most 4 per line
printf '%-10s%-10s%-10s%s\n' $(yes x | head -n 10)

Print 10 lines of a single "x"
yes x | head -n 10

Print 3 space separated '%'
echo $(yes % | head -n3)

Print 3 newline separated "y"s
yes | head -3

Print 4th white space separated field in file "file"
tr -s ' ' < file | cut -d' ' -f4

Print 7 spaces in a row
yes ' ' | head -7 | tr -d '\n'

Print a 2 byte decimal integer from "/dev/random"
od -An -N2 -i /dev/random

Print a 2 byte hexadecimal value, printable character, and octal value of "$1"
echo "$1" | od -xcb

Print a space separated list of numbers from 1 to 10
seq 10 | xargs

Print a colon-separated list of all directories from the $root directory tree
find $root -type d -printf '%p:'

Print a colon-separated list of all directories from the $root directory tree
find $root -type d | tr '\n' ':'

Print a colon-separated list of all directories from the $root directory tree, except those matching pattern ".[a-z]*"
find "$root" -name ".[a-z]*" -prune -o -type d -printf '%p:'

Print a colon-separated list of all directories from the ~/code directory tree, except hidden ones and those below them
find ~/code -name '.*' -prune -o -type d -printf ':%p'

Print a colon-separated list of all directories from the ~/code directory tree, except hidden ones and those below them
find ~/code -name '.*' -prune -o -type f -a -perm /u+x -printf ':%h\n' | sort | uniq | tr -d '\n'

Print a column of CPU usage numbers
ps aux | tr -s '[:blank:]' | cut -d' ' -f3

Print a count of all unique entries in "ips.txt" with the most frequent results at the top
sort ips.txt | uniq -c | sort -bgr

Print a count of all unique lines in "ports.txt" sorted from most frequent to least frequent
sort ports.txt | uniq -c | sort -r

Print a count of duplicate lines in "filename"
sort filename | uniq -c

Print a count of each unique line from standard input
sort | uniq -c

Print a count of each unique line from standard input sorted from least frequent to most frequent
sort | uniq -c | sort -n

Print a count of each unique line in "ip_addresses"
sort ip_addresses | uniq -c

Print a count of each unique line in "ip_addresses.txt" sorted numerically
sort -n ip_addresses.txt | uniq -c

Print a count of case insensitive duplicate filenames in the current directory
ls -1 | tr '[A-Z]' '[a-z]' | sort | uniq -c | grep -v " 1 "

Print a count of files and directories in the current directory tree
tree | tail -1

Print a detailed list of all files under and below the two directories given as variables $FULFILLMENT and $ARCH1
find $FULFILLMENT $ARCH1 -exec stat -c '%i,%b,%A,%h,%U,%G,%y,%n' {} \;

Print a detailed list of all regular files from the current directory tree
find . -type f -ls

Print a dump of the plain hex data in "$VAR1" as printable characters
echo -ne "$VAR1" | xxd -r -p | od -c

Print a null delimited list of all *.emlx files/directories under /path/to/folders/ to filelist
find /path/to/folders/ -name \*.emlx -print0 > filelist

Print a hex dump byte to byte of the output of "printf Aa"
printf Aa | od -t x1

Print a hex dump of "$DIREC" as characters
echo "$DIREC" | od -c

Print a list of all *.code files from the current directory tree
find . -name *.code

Print a list of all duplicate case insensitive file paths in the current directory tree
find . | sort -f | uniq -i -d

Print a list of all files and directories in the /var/log directory tree
find /var/log/

Print a list of all files/directories under current directory in myfile.sh file
find . -print >myfile.sh

Print a list of all regular files residing in the current directory
find . -maxdepth 1 -type f -print0

Print a list of all the files in entire file system whose inode has been modified no later than one minute ago
find / -newerct '1 minute ago' -print

Print a list of differing files
diff -q /dir1 /dir2|cut -f2 -d' '

Print a list of each file with the full path prefix in the current directory tree excluding symbolic links
tree -fi |grep -v \>

Print a list of case insensitive duplicate filenames in the current directory
ls | sort -f | uniq -i -d

Print a list of JPG files residing in the current directory tree
find . -name “*.jpg”

Print a list of most often changed files in git
git whatchanged --all | \grep "\.\.\." | cut -d' ' -f5- | cut -f2- | sort | uniq -c | sort

Print a list of regular files from directory tree sort_test/ sorted with LC_COLLATE=C
find sort_test/ -type f | env -i LC_COLLATE=C sort

Print a list of regular files from directory tree sort_test/ sorted with LC_COLLATE=en_US.UTF-8
find sort_test -type f | env -i LC_COLLATE=en_US.UTF-8 sort

Print a list of regular files from directory tree sort_test/ sorted with LC_COLLATE=en_US.utf8
find sort_test/ -type f | env -i LC_COLLATE=en_US.utf8 sort

Print a list of symbolic links reachable from the current directory that do not resolve to accessible files
find -L. -type l

Print a list of unique users who are logged in
who | cut -d' ' -f1 | sort | uniq

Print a line of "$variable" '-' characters
printf '%0.s-' $(seq 1 $variable)

Print a line of 10 '#' characters
seq  -f "#" -s '' 10

Print a line of 100 '=' characters
head -c 100 < /dev/zero | tr '\0' '='

Print a line of 100 '=' characters
printf %100s |tr " " "="

Print a line of 100 random characters either "." or " "
cat /dev/urandom | tr -dc '. ' | fold -w 100 | head -1

Print a line of 3 '%' characters
seq -s % 4|tr -d '[:digit:]'

Print a line of 99 '=' characters
seq -s= 100|tr -d '[:digit:]'

Print a minimal set of differences between files in directories "a" and "b", ignore differences in whitespace, and print 0 lines of unified context
diff -dbU0 a b

Print a minimal set of differences between files in directories "a" and "b", ignore the first 3 lines of output, and print any line starting with "-" with the first character removed
diff -dbU0 a b | tail -n +4 | grep ^- | cut -c2-

Print a minimal set of differences between files in directories "teste1" and "teste2", treat absent files as empty, ignore differences in whitespace, treat all files as text, and print 3 lines of unified context
diff -burNad teste1 teste2

Print a NULL-separated list of all directories of the current directory tree
find . -type d -print0

Print a NULL-separated list of all hidden regular files from the home directory
find $HOME -maxdepth 1 -type f -name '.*' -print0

prints a number stored among text in $filename
echo $filename | egrep -o '[[:digit:]]{5}' | head -n1

Prints a random line from $FILE
sort --random-sort $FILE | head -n 1

Prints a random N-digit number with leading zeroes
tr -dc '1-65000' </dev/urandom | head -c N

Prints a random number between 2000 and 65000
head -200 /dev/urandom |cksum | cut -f1 -d " " | awk '{print $1%63000+2001}'

Prints a random number between 2000 and 65000
seq 2000 65000 | sort -R | head -n 1

Print a random number from 2000 to 65000
seq 2000 65000 | sort -R | head -n 1

Print a randomly sorted list of numbers from 1 to 10 to file "/tmp/lst" and outputs "-------" followed by the reverse list to the screen
seq 1 10 | sort -R | tee /tmp/lst |cat <(cat /tmp/lst) <(echo '-------') | tac

Print a randomly sorted list of numbers from 1 to 10 to file "/tmp/lst" and the screen followed by " -------"
seq 1 10 | sort -R | tee /tmp/lst |cat <(cat /tmp/lst) <(echo '-------')

Print A record for domain 'domain.' from 'ns1.newnameserver' nameserver
dig @ns1.newnameserver domain. a

Print A record for domain 'domain.' from 'ns2.newnameserver' nameserver
dig @ns2.newnameserver domain. a

Print A record for domain 'domain.' from 'some.other.ip.address' nameserver
dig @some.other.ip.address domain. a

Print A record for domain 'domain.' from 8.8.8.8 nameserver
dig @8.8.8.8 domain. a

Print a single line of numbers from "001" to "100"
yes | grep y | sed 100q | awk '{printf( "%03d ", NR )}'; echo

Print a sorted list of all .jpg files in the current directory and below
find -name '*.jpg' | sort -n

Print a sorted list of directories from the ~/Music tree containing files whose names begin with "cover."
find ~/Music/ -iname 'cover.*' -printf '%h\n' | sort -u

Print a sorted list of the extensions of the regular files from the current directory tree
find . -type f | grep -o -E '\.[^\.]+$' | sort -u

Print a sorted list of the extensions of the regular files from the current directory tree
find . -type f | perl -ne 'print $1 if m/\.([^.\/]+)$/' | sort -u

Print a sorted list of the extensions of the regular files from the current directory tree, skipping SVN directories
find . -type f -path '*/.svn*' -prune -o -print | perl -ne 'print $1 if m/\.([^.\/]+)$/' | sort -u

Print a sorted list of the extensions of the regular files from the current directory tree with counts per extension
find . -type f | perl -ne 'print $1 if m/\.([^.\/]+)$/' | sort | uniq -c | sort -n

Print a sorted list of the subdirectories of ~/Music
find ~/Music/ -maxdepth 2 -mindepth 2 -type d | sort

Print a sorted list of unique directory paths in entire file system that match the pattern '<name_pattern>' in their names
find / -name '<name_pattern>' -type d | sort | uniq

Print a unique list of characters from standard input showing backslash escapes for non-displayables
od -cvAnone -w1 | sort -bu

Print a welcome message with the current user's user name
echo "Welcome $(whoami)!"

Print a welcome message with the current user's user name
echo "Welcome `whoami`!"

Print a welcome message with the current user's user name
echo -ne "Welcome $(whoami)!\n"

Print a welcome message with the current user's user name
echo -ne "Welcome `whoami`!\n"

prints absolute file paths for files in current directory
find `pwd` -maxdepth 1

prints absolute file path of a file
echo $(cd $(dirname "$1") && pwd -P)/$(basename "$1")

Print absolute path of "PATH"
readlink -f PATH

Print absolute path of "YOUR_PATH"
readlink -f YOUR_PATH

Print all '-' separated digits in file 'infile' as dot ('.') separated digits
grep -Eo '([0-9]+-){3}[0-9]+' infile | tr - .

print all active readline keybindings
bind -P | grep --fixed-strings ' can be found on ' | perl -pe 's/((?<!\\)(?:\\\\)*)\\C/\1Ctrl/g;s/((?<!\\)(?:\\\\)*)\\e/\1Esc,/g'

Prints all business days in a current month.
cal -h | cut -c 4-17

Print all business days in the current month without column titles
cal -h | cut -c 4-17 | tail -n +3

Print sed commands that would replace all occurrences of 'previousword' with 'newword' in all regular files with '.cpp' extension under '/myprojects' directory tree
find /myprojects -type f -name '*.cpp' -print0 |    xargs -0 echo sed -i 's/previousword/newword/g'

Print and delete all directories named 'work' under '/usr/ports/' directory tree
find /usr/ports/ -name work -type d -print -exec rm -rf {} \;

Print all directories under $root appending a : (colon) at the end of each path
find $root -type d -printf '%p:'

Print all directories under $root appending a : (colon) at the end of each path without descending into directories matching the pattern .[a-z]*
find "$root" -name ".[a-z]*" -prune -o -type d -printf '%p:'

Print all distinct characters in input "He likes cats, really?"
echo "He likes cats, really?" | fold -w1 | sort -u

Print all files and directories in the `.' directory tree skipping SCCS directories
find . -name SCCS -prune -o -print

Print all files and directories in the `.' directory tree skipping SCCS directories but printing out the SCCS directory name
find . -print -name SCCS -prune

Print all files/directories under ... directory by terminating their paths with a null character
find ... -print0

Print all files/directories with their sizes under $WHATEVER directory tree
find $WHATEVER -printf "%s %p\n"

Print all files containing "word1" and "word2" in the current directory tree
comm -12 <(grep -rl word1 . | sort) <(grep -rl word2 . | sort)

Print all files in the current directory as a comma separated list
ls -1 | paste -sd "," -

Print all files in the current directory tree as a comma separated list
find . -type f -print0 | tr '\0' ','

Print all files in the current directory tree as a comma separated list
find . -type f | paste -d, -s

Print all files on the system owned by group `name_of_group'
find / -group name_of_group

Print all files that exceed 1000 blocks and were modified at least a month ago
find / -size +1000 -mtime +30 -exec ls -l {} \;

print all files in the directories except the ./src/emacs directory
find . -wholename './src/emacs' -prune -o -print

print all files in the file system excluding those ending with ".c"
find / \! -name "*.c" -print

print all files which name is xyzzy  followed by null and save to list
find / -name xyzzy -print0 > list

Print all filenames in /usr/src except for those that are of the form '*,v' or '.*,v'
find /usr/src -not \( -name "*,v" -o -name ".*,v" \) '{}' \; -print

Print all filenames under /proc and below
find /proc -exec ls '{}' \;

Print all filenames under /proc and below
find /proc -print0 | xargs -0

Print all filenames under /proc and below
find /proc | xargs

print all filenames of files under current dir containing 'foo', case-insensitive
find . -type f -exec grep -il 'foo' {} \;

Print all file/directory names with white space safety under the /proc directory
find /proc -print0 | xargs -0

Print all file/directory names without white space safety under the /proc directory
find /proc | xargs

Print all file/directory paths under current directory
find -print0 | while IFS= read -rd $'\0' f ; do echo "[$f]" ; done

Ping all hosts in file "ips" twice
cat ips | xargs -i% ping -c 2 %

Ping all hosts in file "ips" twice
cat ips | xargs -n1 ping -c 2

Print all group names known to the system.
getent group | cut -d: -f1

Print all lines from file 'report.txt' containing any-cased 'error' pattern
cat report.txt | grep -i error

Print all lines of "seq 1 10" except the last 3
seq 1 10 | perl -e '@x=("")x3;while(<>){print shift @x;push @x,$_}'

Print all lines of "seq 1 10" except the last 3
seq 1 10 | perl -e'@x=<>;print@x[0..$#x-3]'

Print all lines of "seq 1 10" except the last 3
seq 1 10 | perl -ne 'print if ( !eof  )' | perl -ne 'print if ( !eof  )' | perl -ne 'print if ( !eof  )'

Print all lines of "seq 1 10" except the last 3
seq 1 10 | perl -ne 'push @l, $_; print shift @l if @l > 3'

Print all matching commands in $PATH for command "python"
which -a python

Print all non-hidden files in the current directory and its subdirectories
find . -not -path '*/\.*'

Print and recursively remove the alphabetically last directory in the current directory
find -mindepth 1 -maxdepth 1 -type d | cut -c 3- | sort -k1n | tail -n 1 | xargs -r echo rm -r

Print and save the ping results of 25 requests to "google.com" in "/home/user/myLogFile.log" containing at most 100000 bytes
ping -c 25 google.com | tee >(split -d -b 100000 - /home/user/myLogFile.log)

Print and split the output of "my_program" into files of at most 100000 bytes each and use numeric suffixes
my_program | tee >(split -d -b 100000 -)

Print all string from file 'file2.txt' matching pattern in file 'file1.txt'
grep "$(cat file1.txt)" file2.txt

Print all the banned IPs from your server along with their origin (country) using the geoip-bin package
zcat /var/log/fail2ban.log* | gawk  '/.*Ban.*/  {print $7};' | sort | uniq -c | sort | gawk '{ "geoiplookup " $2 "| cut -f2 -d: " | getline geoip; print $2 "\t\t" $1 " " geoip}'

print all the files in the current folder which do not begin with a capital letter
find . \! -name '[A-Z] *' -exec lpr { }\;

Print all the file/directory paths under current directory
find | xargs

Print all unique strings in $1.tmp file.
cat $1.tmp | sort -u

Print all user names and terminals of users who are logged in
who | cut -d " " -f1,2

Prints long listing of "$dir/$file" file.
ls -l -- "$dir/$file"

Prints long listing of ${0} file.
ls -l ${0}

Prints long listing of content in a root folder, including hidden files, with human-readable sizes, and stores output to '/root/test.out' file.
echo 'ls -hal /root/ > /root/test.out' | sudo bash

Prints long listing of content in a root folder, including hidden files, with human-readable sizes, and stores output to '/root/test.out' file.
ls -hal /root/ > /root/test.out

Prints long listing of content in a root folder, including hidden files, with human-readable sizes, and stores output to '/root/test.out' file.
ls -hal /root/ | sudo tee /root/test.out

Prints long listing of content in a root folder, including hidden files, with human-readable sizes, and stores output to '/root/test.out' file.
sudo ls -hal /root/ | sudo bash -c "cat > /root/test.out"

Prints long listing of content in a root folder, including hidden files, with human-readable sizes, and stores output to '/root/test.out' file.
sudo ls -hal /root/ | sudo dd of=/root/test.out

Prints long listing of content in a root folder, including hidden files, with human-readable sizes, and stores output to '/root/test.out' file.
sudo ls -hal /root/ | sudo tee /root/test.out > /dev/null

Prints long listing of content in the current folder with C-style escapes for nongraphic characters
ls -lb

Prints long listing of directories "./my dir" and "./anotherdir" sorted from oldest to newest, with appended indicators.
$ ls -Fltr "./my dir" "./anotherdir"

Prints long listing of directory $var sorted from oldest to newest, with appended indicators.
$ ls -Fltr $var

Prints long listing of directories '/tmp', '/tnt' themselves.
ls -ld /tmp /tnt

Prints long listing of file 'file.ext'.
ls -al file.ext

Prints long listing of top ten most memory using processes in a system.
ps -e -orss=,args= | sort -nr | head

Prints long listing of the current directory and top-level directories within, sorted from oldest to newest, with appended indicators.
$ ls -Fltr *

Prints long recursive listing of all content of a current folder, saving output to 'output.file'.
ls |& tee files.txt

Prints long recursive listing of all content of a root folder, appending output to 'output.file'.
ls -lR / | tee -a output.file

Print an alert message containing the IP address and information of the user connecting via SSH
echo -e "ALERT - Shell Access on:' `date` `who` '\n\n' `whois $(who | cut -d'(' -f2 | cut -d')' -f1)`"

Print space separated list of numbers from "$start" to "$end"
echo `seq $start $end`

Print space separated list of numbers from "$start" to "$end"
seq -s' ' $start $end

Print space separated numbers from 1 to 10
seq 10 | xargs echo

Print appended data in "/var/log/some.log" that match "foo" and "bar"
tail -f /var/log/some.log | grep --line-buffered foo | grep bar

Print appended data in "/var/log/syslog" as the file grows
tail -f /var/log/syslog

Print appended data in "file" and search for "my_pattern" without buffering
tail -f file | stdbuf -o0 grep my_pattern

Print appended data in "file" that match "my_pattern"
tail -f file | grep --line-buffered my_pattern

Print argument "$1" "$number" times
yes $1 | head -$number

Print as many dots as there are files named "file.ext" in the /home/kibab directory tree
find /home/kibab -name file.ext -exec echo . ';'

print bindings for "p" and "e" with no case sensitivity
bind -p|grep -i '"[pE]"'

Prints brief information about available package with word 'zsh'.
yum list zsh

Prints strings with MAC address configuration of each network interface in system.
ifconfig | grep HW

Prints strings with text "texthere" in all files recursively in a current folder.
grep -r "texthere" .

Prints calendar for a current month.
cal

Print calendar for February, March and April of year 2009 side-by-side
paste <(cal 2 2009) <(cal 3 2009) <(cal 4 2009)

Prints calendar of February, 1900.
cal 2 1900

Prints calendars of July, 2009 and July, 2010 side-by-side.
paste <(cal 6 2009) <(cal 6 2010)

Print canonical filename of "/path/here/.."
readlink -f  /path/here/..

Print characters 2 through 4 of "abcdefg"
echo 'abcdefg'|tail -c +2|head -c 3

Print chmod commands that can change permissions of regular files residing in the current directory tree to u=rw,g=r,o=
find . -type f -exec echo chmod u=rw,g=r,o= '{}' \;

Print either "one" or "two" randomly three times
yes $'one\ntwo' | head -10 | nl | sort -R | cut -f2- | head -3

Print common files of directory "1" and "2"
comm -12  <(ls 1) <(ls 2)

Print common files of directory "one" and "two"
comm -12  <(ls one) <(ls two)

print command for alias "list" with low priority command
nice -10 `alias list | sed "s/^\(alias \)\?[^=]\+='//; s/'$//;"`

Print command history
history

Print common lines in "file1" and "file2"
comm -12 file1 file2

Print common lines in files "set1" and "set2"
comm -12 <(sort set1) <(sort set2)

Print common lines in sorted files "ignore.txt" and "input.txt"
comm -12 ignore.txt input.txt

Print common lines of files "file1", "file2", "file3", and "file4"
comm -12 <(comm -12 <(comm -12 <(sort file1) <(sort file2)) <(sort file3)) <(sort file4)

Print command line of process with pid 17709
cat /proc/17709/cmdline | xargs -0 echo

Print comma separated gaps in file "file" that contains new line separated ordered numbers
seq $(tail -1 file)|diff - file|grep -Po '.*(?=d)'

Print command with PID 11383
ps | egrep 11383 | tr -s ' ' | cut -d ' ' -f 4

Print concatenated content of all files ending with '.foo' under the current folder
cat `find . -name '*.foo' -print`

Print contents of "file" as space separated hexadecimal bytes on a single line
od -t x1 -An file |tr -d '\n '

Print contents of "file" as space separated hexadecimal bytes on a single line
xxd -p file | tr -d '\n'

Print content of '1' file
$ cat 1

Print content of 'a' file, showing all non-printing characters including TAB characters, and displaying $ at the end of each line.
cat -vet a

Print content of 'domains.txt' with removed first one of dot-delimited fields
rev domains.txt | cut -d '.' -f 2- | rev

Print content of 'file' file reverted characterwise
rev file

Print content of 'filename' file, showing all non-printing characters and displaying $ at the end of each line.
cat -v -e filename

Print content of 'whatever' file
cat whatever | egrep 'snozzberries|$'

Print content of /etc/passwd and /etc/group files
cat /etc/passwd /etc/group

Print content of all files found regarding seach options '[whatever]'
find [whatever] -exec cat {} +

Print content of all files found regarding seach options '[whatever]'
find [whatever] -exec cat {} \;

Print content of all files found regarding seach options '[whatever]'
find [whatever] -print0 | xargs -0 cat

Print content of all files found regarding seach options '[whatever]'
find [whatever] | xargs cat

Print content of all files ending with '*.foo' in current directory recursively
find . -name '*.foo' -exec cat {} \;

Print content of all files ending with '*.foo' under the current directory
cat $(find . -name '*.foo')

Print content of each file under the current directory followed by that file name
find . -type f -exec cat {} \; -print

Print continuous characters '/' and '\' randomly from /dev/urandom
grep -ao "[/\\]" /dev/urandom|tr -d \\n

Print continuous lines of 100 random characters either "." or " "
cat /dev/urandom | tr -dc '. ' | fold -w 100

Print count of unique lines in all files like 'list_part*'
cat list_part* | sort --unique | wc -l

Print mount point of the file system containing $path.
df --output=target "$path" | tail -1

Print CPU usage and memory usage of all unique processes on a system
ps aux | awk '{print $4"\t"$11}' | sort | uniq -c | awk '{print $2" "$1" "$3}' | sort -nr

Print CPU usage and memory usage of processes running "mysql"
ps aux | awk '{print $4"\t"$11}' | sort | uniq -c | awk '{print $2" "$1" "$3}' | sort -nr |grep mysql

Print current UTC date in ISO format with precision to seconds
date -u -Iseconds

Print current date as epoch seconds
date +%s

Prints current directory name
pwd | grep -o "\w*-*$"

Prints current month calendar, without highlighting of a current date.
cal -h

Print current shell settings
set -o

Print current shell using process ID
ps  -ef | grep $$ | grep -v grep

Print current shell using process ID
ps -p $$

Print days between date $A and $B
echo "( `date -d $B +%s` - `date -d $A +%s`) / (24*3600)" | bc -l

Print details for all files in the ./work directory tree with extension .sh that were modified less than 20 days ago
find ./work/ -type f -name "*.sh" -mtime -20 | xargs -r ls -l

Print differences between files in directories folder1 and folder2 recursively, with unified context, ignoring changes in the amount of white space
diff -bur folder1/ folder2/

Print differences between the sorted content of file $1 and file $2, executing 'diff' with options from "${@:3}" array slice
diff "${@:3}" <(sort "$1") <(sort "$2")

Print difference between two strings "$s" and "$r"
diff <(fold -w1 <<< "$s") <(fold -w1 <<< "$r") | awk '/[<>]/{printf $2}'

print difference in days between two dates
echo $(( ( $(date -ud '2003-08-02 17:24:33' +'%s') - $(date -ud '2003-04-21 22:55:02' +'%s') )/60/60/24 )) days

Print directories in the the current directory as a list with no report information
tree -d -L 1 -i --noreport

Print each character in "Hello" as a hexadecimal value
echo -n "Hello" | od -A n -t x1

Print each character in "orange" on a new line
echo orange | fold -w 1

Print each character of "abcdefg" on a line
echo "abcdefg" | fold -w1

Print each line in "f1" and "f2" separated by a space and "f3" separated by a tab
paste <(paste -d" " f1 f2) f3

Print each line in "file1" whose first word does not exist as the first word of any line in "file2"
join -v 1 <(sort file1) <(sort file2)

Print each line in "set1" and "set2" that does not exist in the other
sort set1 set2 | uniq

Print each line in parallel in files "tmp/sample-XXX.tim" and "tmp/sample-XXX.log"
paste tmp/sample-XXXX.{tim,log}

Print each line that is found only once in "file1" and "file2" combined
sort file1 file2 | uniq -u

Print each logged in user's full name
finger -l | grep "Name:" | cut -d ":" -f 3 | cut -c 2- | sort | uniq

Print each logged in user's username and full name
finger -l | grep "Name:" | tr -s ' ' | cut -d " " -f 2,4- | sort | uniq

Print epoch seconds for given time string "Oct 21 1973"
date -d "Oct 21 1973" +%s

Print each unique line that is duplicated in files "file1" and "file2" combined
sort file1 file2 | uniq -d

Prints elapsed time of command execution.
\time -f%e sleep 1

Print entire virtual memory usage of the current user
ps -u $(whoami) --no-header -o vsz | dc -f - -e '[+z1<r]srz1<rp'

Print enumerated sorted list of all group names known to the system.
getent group | cut -d: -f1 | sort | cat -n

Print equal lines in compressed files "number.txt" and "xxx.txt"
comm -12 <(zcat number.txt.gz) <(zcat xxx.txt.gz)

Print base name of the file name without all extensions.
basename "$FILE" | cut -d'.' -f-1

Print every 16 bytes of standard input in groups of two followed by a space
fold -b16 | sed 's/../& /g'

Print every 20 bytes of standard input as tab separated groups of bytes 1-3, 4-10, and 11-20
fold -b -w 20 | cut --output-delimiter $'\t' -b 1-3,4-10,11-20

Print every 3 characters of standard input as a line
fold -w3

Ping every address from 192.168.0.1 to 192.168.0.254 with a timeout of 1 second and filter out no responses
echo $(seq 254) | xargs -P255 -I% -d" " ping -W 1 -c 1 192.168.0.% | grep -E "[0-1].*?:"

Print every found file like '*.cfg' under '/path/to/files/' directory followed by its content, and wait 2 seconds after each printed file
find /path/to/files -type f -name \*.cfg  -print -exec cat {} \; -exec sleep 2 \;

Print every file's type, name, and inode
find -printf "%y %i %prn"

Print extended file information for regular files found under the home directory whose names start with my
find . -name 'my*' -type f -ls

Print files created/modified in the last day
find /directory -newermt $(date +%Y-%m-%d -d '1 day ago') -type f -print

Prints file.txt without the last N bytes
head -c -N file.txt

Print file information of command "passwd"
ls -l `which passwd`

Print file information of the executable file of command "g++"
ls `which g++` -al

Print file information of the executable file of command "gcc"
ls `which gcc` -al

Print file names of all files ending with '*.csv' in  '/home/ABC/files/' directory
ls /home/ABC/files/*.csv | rev | cut -d/ -f1 | rev

Print file name without extension assuming there is only one dot in the file name.
echo "$FILE" | cut -d'.' -f1

Print file name without the last two extensions assuming the file name doesn't contain any other dots.
echo "$FILE" | cut -d'.' --complement -f2-

Print file name without the last two extensions assuming the file name doesn't contain any other dots.
echo "$FILE"|rev|cut -d"." -f3-|rev

Print file size and user name with color support for each file in the current directory tree
tree -Csu

Print file size with the file name
find . -name '*.ear' -exec du -h {} \;

Print file system disk space usage
df

Print file system disk space usage and grand total for the root file system with sizes in powers of 1000
df -H --total /

Print file system disk space usage in 1 KiB blocks of the current directory's file system
df -k .

Print file system disk space usage in posix and human readable format, format as a table
df -Ph | column -t

Print file system disk space usage of the current directory's file system
df .

Print file system disk space usage with a grand total
df --total

Print file system disk space usage with sizes in powers of 1000
a=$( df -H )

Print file type information of the "java" executable
cat `which java` | file -

Print file type of command "gcc"
file -L `which gcc`

Print file type of the command "c++"
file `which c++`

Print file type of the executable file of command "file"
file `which file`

Print file type of the executable file of command "file"
which file | file -f -

Print file type of the executable file of command "foo"
file $(which foo)

Print file type of the executable file of command "python"
file `which python`

Print first 11 characters from $line, print a tab, print the md5 sum of the file specified by the 13th and onward characters from $line and print a null character at end without a trailing new line
echo -en "${line:0:11}" "\t" $(md5sum "${line:12}") "\0"

Prints first found folder that contains 'ssh' file and has 'bin' in path.
dirname `find / -name ssh | grep bin | head -1`

Print first field from semicolon-seprated line $string.
echo $string | cut -d';' -f1

Print first field from semicolon-seprated line <line>.
echo "<line>" | cut -d ";" -f 1

prints first line of $bigfile
head -n1 $bigfile

Print first word of lines unique for 'file1' file
grep -o '^\S\+' <(comm file1 file2)

Print fourth column of data from text file "file" where columns separated by one or more whitespace.
tr -s ' ' < file | cut -d' ' -f4

Print fourth column of data from text file text.txt where columns separated by one or more whitespaces.
cat text.txt | tr -s ' ' | cut -d ' ' -f4

Prints full path of a 'cat.wav' file in a current folder.
ls $PWD/cat.wav

Print full path of command "c++"
which c++

Print full path of command "gradle"
which gradle

Print full path of command "python"
which python

Print full path of command "python2.7"
which python2.7

prints full path of given file
echo $(cd $(dirname "$1") && pwd -P)/$(basename "$1")

Prints full path to files in a current folder.
ls -d $PWD/*

Prints full path to files in a current folder.
ls -d -1 $PWD/**

Prints full path to files with dot in name in a current folder.
ls -d -1 $PWD/*.*

Prints full process tree with id number of each process.
pstree -p

Prints out all the logged-in users along with their group information.
groups $(who | cut -d' ' -f 1)

Prints git log message with a custom time format string
date -d @$(git log -n1 --format="%at") +%Y%m%d%H%M

Print out the contents of all *.txt files in the home directory
find ~ -name '*.txt' -print0 | xargs -0 cat

Print out the contents of all *.txt files in the home directory
find ~/ -name '*.txt' -exec cat {} ;

Print out the full path name of "mypathname" with dots resolved
readlink -ev mypathname

Print out the names and types of all files in the current directory tree
find . -printf "%y %p\n"

Print out the names of all directories in mydir recursively
find mydir -type d

Print out the names of broken symlinks in the current directory
for l in $(find . -type l); do cd $(dirname $l); if [ ! -e "$(readlink $(basename $l))" ]; then echo $l; fi; cd - > /dev/null; done

Print flow of random data, showing all non-printing characters
cat -v /dev/urandom

Prints groups list that current user belongs to.
groups                                        //take a look at the groups and see

Print groups of all users logged in
groups $(who | cut -d' ' -f 1)

Print help on 'cat' command usage
cat --help

Prints help on 'cp' utility.
cp --help

Prints help on 'yum' utility.
yum --help

Prints help on 'yum' utility.
yum -h

Prints hierarchical process tree.
pstree

Print info about all mounted file systems
df

Print info about all mounted file systems, and grand total statistic about available and used space
df --total

Print info about thread number of process with pid 1
cat /proc/1/sched  | head -n 1

Print information about all users who are logged in
who -la

Prints information about active network interfaces in system.
echo "$(ifconfig)"

Prints information about user $euids currently on machine and its processes, without printing header.
w -h $euids

Print information of the root mount point
mount -v | grep " on / "

Print information of the process running the current script as the current user
ps -ef | grep $0 | grep $(whoami)

Print IP addresses of the host name
hostname  -i

Print IP addresses of the host name
hostname --all-ip-address|cut -d ' ' -f1

Print IP addresses of the host name
hostname --ip-address

Print IP addresses of the host name
hostname -I

Print IP addresses of the host name
hostname -I | cut -d' ' -f1

Prints Kb size of all top-level files and folders in a current folder in descending order.
du -ks * | sort -n -r

Prints Kb size of all top-level files and folders in a current folder in descending order in human readable format.
du -ksh * | sort -n -r

Prints latest modified file in a directory
ls -1t | head -1

Print last 10 commands in history
history 10

Print last 10 commands in history with the first 7 characters removed
history 10 | cut -c 8-

Print last day of April, 2009
cal 4 2009 | tr ' ' '\n' | grep -v ^$ | tail -n 1

Print last four bytes of string '0a.00.1 usb controller some text device 4dc9'
echo 0a.00.1 usb controller some text device 4dc9 | rev | cut -b1-4 | rev

Prints last modified file in a current folder.
find . -type f -printf '%T@ %p\n' | sort -n | tail -1 | cut -f2- -d" "

Prints last modified file in a current folder with modification time.
find . -type f -printf '%TY-%Tm-%Td %TH:%TM: %Tz %p\n'| sort -n | tail -n1

print list of all alias commands
alias -p | cut -d= -f1 | cut -d' ' -f2

Prints list of all libraries linked with binaries in '/bin/' and '/usr/bin/', with number of linkages for each library.
ldd /bin/* /usr/bin/* | sed -e '/^[^\t]/ d; s/^\t\(.* => \)\?\([^ ]*\) (.*/\2/g' | sort | uniq -c

Print list of disk and mountpoint of disks matching "/dev/sd*"
paste <(mount | awk 'tolower($0) ~ /\/dev\/sd*/ {print NR "\t" $1 "\t" $3}') <(/usr/sbin/smartctl -a /dev/sdb | awk '/Device:/ {print $2}')

Print list of disk and mountpoint of disks matching "/dev/sd*" into "mount_point" as a background task
mount | grep -i "/dev/sd.*" | awk '{ print NR "\t" $1 "\t" $3 }' > mount_output &

Print list of bash command aliases.
alias -p | cut -d= -f1 | cut -d' ' -f2

Prints list of folders containing '.git', searching recursively from a current folder.
find . -name '.git' | xargs -n 1 dirname

Print list of missing files in a Subversion repository.
svn status |  grep '\!' | cut -d\  -f2-

Prints list of processes in system ascending by memory usage.
ps -e -orss=,args= | sort -b -k1,1n | pr -TW$COLUMNS

Prints list of top-level subfolders in a current folder, sorted by number of contained files.
find . -maxdepth 1 -type d -print0 | xargs -0 -I {} sh -c 'echo -e $(find {} | wc -l) {}' | sort -n

Print lines 10000 to 10010 from input "seq 1 100000"
seq 1 100000 | tail -n +10000 | head -n 10

Print lines 15967 to 16224 in file "dump.txt"
cat dump.txt | head -16224 | tail -258

Print lines 16225 to 16482 in file "file"
cat file | head -n 16482 | tail -n 258

Print lines 347340107 through 347340206 in "filename"
tail -n +347340107 filename | head -n 100

Print lines containing string TEXT from all log files in the current directory.
grep -e TEXT *.log | cut -d':' --complement -s -f1

Prints lines count in each *.c file of a current folder and total count.
wc -l *.c

Prints lines count of each *.php file in a current folder and subfolders, and prints total count.
find . -name '*.php' -print0 | xargs -0 wc -l

Prints line count of each file within current directory.
find . -type f -print | xargs -L1 wc -l

Prints line count of each file within current directory.
find . -type f -print0 | xargs -0L1 wc -l

Print linker search path using ld formatted on new lines
ld --verbose | grep SEARCH_DIR | tr -s ' ;' \\012

Print linux group names on multiple lines instead of single line output
groups | tr \  \\n

Print lines in "file1" that exist in "file2"
join -t " " -j 1 <(sort file1) <(sort file2)

Print lines in "file1.txt" that do not exist in "file2.txt"
sort <(sort -u file1.txt) file2.txt file2.txt | uniq -u

Print lines in "foo.txt" that are found only once
sort foo.txt | uniq

Print lines in file 'file' that do not match any word specified in file 'blacklist' (one word per line)
grep -w -v -f blacklist file

Print lines in the sorted contents of "a.txt" that are not in the sorted contents of "b.txt"
comm -23 <(sort a.txt) <(sort b.txt)

Print lines in the sorted contents of "file1" that are not in the sorted contents of "file2"
comm -23 <(sort file1) <(sort file2)

Print lines in the sorted contents of "file2" that are not in the sorted contents of "file1"
comm -13 <(sort file1) <(sort file2)

Print line number of each line in /etc/passwd file, where current user name is found
cat /etc/passwd -n | grep `whoami` | cut -f1

Print lines of 'file' reverted order, and reverted characterwise
tac file | rev

Print lines unique and common to sorted files "file1" and  "file2"
comm file1 file2

Print line, word and byte counts for each .php files in current directory tree and also show the total counts
wc `find | grep .php$`

Print line, word and byte count for each file recursively and also show the total counts
wc `find`

Print local files without descending non-local directories
find . ! -local -prune -o -print

Prints local machine's LAN IP address
ifconfig $(netstat -rn | grep -E "^default|^0.0.0.0" | head -1 | awk '{print $NF}') | grep 'inet ' | awk '{print $2}' | grep -Eo '([0-9]*\.){3}[0-9]*'

Prints local machine's LAN IP address
ifconfig `ip route | grep default | head -1 | sed 's/\(.*dev \)\([a-z0-9]*\)\(.*\)/\2/g'` | grep -oE "\b([0-9]{1,3}\.){3}[0-9]{1,3}\b" | head -1

Print local SRV record of domain '_etcd-client._tcp.'
dig @"127.0.0.1"  _etcd-client._tcp. SRV

Prints logged in users in sorted order.
w | sort

Print ls output for all non-empty files under under current directory
find . -type f ! -size 0 -exec ls -l '{}' \;

Prints message info about filename and location of the current script
echo "The script you are running has basename `basename $0`, dirname `dirname $0`"

Print sub domains of "mydomain.com"
hostname -a -l mydomain.com | sed -n '/;; ANSWER/{n;N;p;q}'

Print host name followed by ":" and the contents of "/sys/block/sda/size"
echo "$(hostname):$(cat /sys/block/sda/size)"

Print host name without a newline
echo -n `hostname`

Print multiline text "ONBOOT=\"YES\"\nIPADDR=10.42.84.168\nPREFIX=24" to the terminal, replacing '\n' with newline symbol, and append that text to file /etc/sysconfig/network-scripts/ifcfg-eth4 as root user.
echo -e "ONBOOT=\"YES\"\nIPADDR=10.42.84.168\nPREFIX=24" | sudo tee -a /etc/sysconfig/network-scripts/ifcfg-eth4

Print mv commands to rename all files under current directory by formatting the filenames with the sed scripts '\''s/^([^-]*)-\s*([^\.]*)/\L\1\E-\2/'\'', '\''s/ /_/g'\'' and '\''s/_-/-/g'\''
find ./ -type f -exec bash -c 'echo "mv \"$1\" \"$(echo "$1" | sed -re '\''s/^([^-]*)-\s*([^\.]*)/\L\1\E-\2/'\'' -e '\''s/ /_/g'\'' -e '\''s/_-/-/g'\'')\""' - {} \;

Prints name of temporary file but doesn`t create nothing.
mktemp -u

Print newline, word and byte count for all .h, .c, .cpp, .php and .cc files under current directory tree and also show the total counts
wc `find . -name '*.[h|c|cpp|php|cc]'`

Prints newline, word, and byte count for each *.py in a current folder.
wc *.py

Print newline, word, and byte counts of each '*.java' file within current directory, and total newline, word, and byte counts
find . -name \*.java | tr '\n' '\0' | xargs -0 wc

Print nothing because 'MYVAR' string doesn`t match with '/[^/]+:' pattern
echo MYVAR | grep -oE '/[^/]+:' | cut -c2- | rev | cut -c2- | rev

Print NS record for domain 'domain.' from 'some.other.ip.address' nameserver
dig @some.other.ip.address domain. ns

Print NS record for domain 'domain.' from 8.8.8.8 nameserver
dig @8.8.8.8 domain. ns

Print numbers 1 through 10 separated by ":"
yes | head -n10 | grep -n . | cut -d: -f1 | paste -sd:

Print numbers from 1 to 10 with padded leading zeros
seq -w 1 10

Print numbers from 1 to 100
seq 1 100

Print numbers from 1 to 30 with a leading 0
seq -w 30

Print numbers from 1 to 30 with equalized 0 padding
seq -w 30

Print numbers from 1 to the number in variable "$1"
seq $1

Print numbered list of all third-level files under the current directory
ls -d -1 $PWD/**/*/* | cat -n

Prints number of files with extension "${EXTENSION}" in the "${SEARCHPATH}" directory.
echo "Number files in SEARCH PATH with EXTENSION:" $(ls -1 "${SEARCHPATH}"/*."${EXTENSION}" | wc -l)

print number of jobs
n_jobs=`expr $(jobs | wc -l)`

Print numerically sorted list of unique strings from 'ip_addresses' file, with number of occurrences of each string.
sort -n ip_addresses.txt | uniq -c

Print on the standard output the names of all directories that reside in the current directory tree and contain file "YourProgram"
find $(pwd) -name YourProgram -exec dirname {} \; | while read d; do cd "$d" && pwd; done

Print only alphanumeric values from "/dev/urandom"
cat /dev/urandom | tr -dc 'a-zA-Z0-9'

Print only strings from file 'file2' that not found in 'file1'
comm -1 -3 file1 file2

Print only common strings in content of files 'file1.sorted' and 'file2.sorted'
comm -1 -2 file1.sorted file2.sorted

Print only common strings in sorted content of files 'file1' and 'file2'
comm -1 -2 <(sort file1) <(sort file2)

Print only common file names in sorted listings of directory 'dir1' and 'dir2'
comm -1 -2 <(ls /dir1 | sort) <(ls /dir2 | sort)

Print only digits in variable "$name"
echo $name | tr -c -d 0-9

Print only first line of 'file' content, formatted as 29-symbol wide column
cat file | fold -w29 | head -1

Print only first line of 'file' content, formatted as 29-symbol wide column, regarding space symbol as a word separator
cat file | fold -s -w29 | head -1

Prints only first ten characters of each string of file $file.
cat $file | cut -c 1-10

Print only group names from /etc/group.
cut -d: -f1 /etc/group

Print onlt last slash-separated field from $PATH value
echo "$PATH" | rev | cut -d"/" -f1 | rev

Print only lines from 'file1.txt' that not present in 'file2.txt' and beginning with 'Q'
cat file1.txt | grep -Fvf file2.txt | grep '^Q'

Print only printable characters from "/dev/urandom"
cat /dev/urandom | tr -dC '[:graph:]'

Print only second from the end field from slash-separated string in file 'datafile'
cat datafile | rev | cut -d '/' -f 2 | rev

Print only the line "foo///" given two empty directories foo and bar
find foo/// bar/// -name foo -o -name 'bar?*'

Print only the number of lines in file "$f"
wc -l $f | tr -s ' ' | cut -d ' ' -f 1

Prints only unique strings of those stored in variables $COMMANDS and $ALIASES.
echo "$COMMANDS"$'\n'"$ALIASES" | sort -u

Print only unique lines in files 'set1' and 'set2'
cat set1 set2 | sort -u

Prints only unique lines of './script.sh' output.
./script.sh | sort -u

Prints only unique lines of './yourscript.ksh' output.
./yourscript.ksh | sort | uniq

Print only unique lines of 'file_name' file
cat -n file_name | sort -uk2 | sort -nk1 | cut -f2-

Print output of "qstat" with full job names and format as a table
qstat -xml | tr '\n' ' ' | sed 's#<job_list[^>]*>#\n#g' \   | sed 's#<[^>]*>##g' | grep " " | column -t

Print output of 'script -c "./a" /dev/null' to standard output and "output.txt"
script -c "./a" /dev/null | tee output.txt

Print output of 'script -q /dev/null ./a' to standard output and "output.txt"
script -q /dev/null ./a | tee output.txt

Print output of command "stdbuf -o 0 ./a" to standard output and "output.txt"
stdbuf -o 0 ./a | tee output.txt

Print output of script 'trap.sh'
~ $ . trap.sh | cat

Print package information the command "ldconfig" belongs to in rpm
rpm -qfi `which ldconfig`

Prints path location of $BASH_SOURCE file.
echo this dir: `dirname $BASH_SOURCE`

Prints path to folder that contains file "/path/to/vm.vmwarevm/vm.vmx".
dirname "/path/to/vm.vmwarevm/vm.vmx"

Prints path to folder that contains file "/path/to/vm.vmwarevm/vm.vmx".
echo /path/to/vm.vmwarevm/vm.vmx | xargs dirname

Prints path to folder that contains target of the symbolic link ../../../../etc/passwd.
$(dirname $(readlink -e ../../../../etc/passwd))

Prints path to the folder that contains target of symbolic link ../../../../etc/passwd.
$(dirname $(readlink -e ../../../../etc/passwd))

Prints path to the target of symbolic link 'relative/path/to/file'
dirname `readlink -e relative/path/to/file`

Print pathname of a file that is connected to the standard output of the command "yes"
echo <(yes)

Print pathnames of all files in the current directory and below skipping directories named SCCS and files in them
find . -name SCCS -prune -o -print

Print pathnames of all files in the current directory and below skipping files under SCCS directories
find . -print -name SCCS -prune

Print permissions of every directory in the current directory tree
tree -p -d

print top 10 largest files and directories
du -a . | sort -nr | head

prints top 10 processes sorted by memory usage
ps aux | awk '{print $2, $4, $11}' | sort -k2rn | head -n 10

Prints top ten of most memory using processes in system.
ps aux | awk '{print $2, $4, $11}' | sort -k2rn | head -n 10

Print PID and user of processes running ssh or sshd and replace sequential spaces with a single space
ps h -o pid,user -C ssh,sshd | tr -s " "

Prints process list with id numbers of a process having id 'pid'.
pstree -p [pid ...]

Prints process tree for the current process with ASCII line drawing characters.
pstree -A -s $$

Prints process tree of a cron process with command arguments and process id number.
pstree -ap `pidof cron`

Prints process tree of a current process with id numbers and parent processes.
pstree -sp $$

Prints process tree of a bash process.
pstree $(pgrep -fn bash)

Prints process tree of a process having id $ID with parent processes.
pstree -s $ID

Prints process tree of user 'user' processes.
pstree -p user

Prints process tree, showing only strings with 'MDSImporte', and chopping output after ${WIDTH} characters.
pstree | grep MDSImporte | cut -c 1-${WIDTH}

Prints process tree with command line arguments and process id numbers.
pstree -apl

Prints process tree with command line arguments of a process having id $PID.
pstree -a "$PID"

Prints random line from file $FILE.
sort --random-sort $FILE | head -n 1

Prints real path of the folder containing $0 file.
$(readlink -f $(dirname "$0"))

print readline bindings that use key code '\\e\\C-k'
bind -P | grep '\\e\\C-k'

Print received input to the terminal
tee

Prints reversed content of a file 'myfile.txt' with string numbers.
grep -n "" myfile.txt | sort -r -n | gawk -F : "{ print $2 }"

Print reverse lookup for adress 127.0.0.1
dig -x 127.0.0.1

Print reverse lookup for IP address 72.51.34.34
dig -x 72.51.34.34

Print revesed second from the end dot-bounded field in $i value
j=`echo $i | rev | cut -d "." -f2`;

Prints running process that has id 'pid' with command line arguments.
pstree -a pid

Print shared lines in "number.txt.gz" and "xxx.txt.gz"
zcat number.txt.gz | { zcat xxx.txt.gz | comm -12 /dev/fd/3 - ; } 3<&0

Print shared object dependencies of command "YOURAPPNAME"
ldd $(which YOURAPPNAME)

Print second field from semicolon-seprated line <line>.
echo "<line>" | cut -d ";" -f 2

Print second section of data coming from stdin where sections are separated by one or more whitespace.
tr -s ' ' | cut -d ' ' -f 2

Print second section of space-separated data coming from stdin.
cut -d ' ' -f 2

Print second section of space-separated data coming from stdin.
cut -d\  -f 2

Print second section of space-separated data from text file "a".
cut "-d " -f2 a

Print short TXT record of domain o-o.myaddr.l.google.com from nameserver 8.8.8.8
dig TXT +short o-o.myaddr.l.google.com @8.8.8.8

Prints sizes of all top-level folders in a current folder with human-readable format and descending order.
du -h --max-depth=1 . | sort -n -r

Print sorted list of all group names known to the system.
getent group | cut -d: -f1 | sort

Print sorted list of strings from 'ip_addresses' file, with number of occurrences of each string.
sort ip_addresses | uniq -c

Print source directory of bash script
dirname "$(readlink -f "$0")"

Print source of the file system containing $path.
df -P $path | tail -1 | cut -d' ' -f 1

Print specific lines in "File-out" that do not match "File-Reference" to standard output
diff --old-line-format '%L' --new-line-format '' --unchanged-line-format ''  <(nl File-out) <(nl File-Reference)

Print standard input to standard output line by line, discarding any adjascent duplicate lines.
uniq

Prints string "0 1 * * * /root/test.sh" to the terminal, and append it to file '/var/spool/cron/root'
echo "0 1 * * * /root/test.sh" | tee -a /var/spool/cron/root

Print string "123" once with '1' replaced by 'a' and second time replaced by 'b'
echo 123 | tee >(tr 1 a)  | tr 1 b

Print summary of files present only in dir1.
diff -rq dir1 dir2 | grep 'Only in dir1/'

Print summary of new/missing files, and which files differ between /path/to/folder1 and /path/to/folder2, sorted alphabetically.
diff -rq /path/to/folder1 /path/to/folder2

Print summary of new/missing files, and which files differ between dir_one and dir_two, sorted alphabetically.
diff -qr dir_one dir_two | sort

Print summary of new/missing files, and which files differ between folder1 and folder2.
diff -arq folder1 folder2

Print summary of new/missing files, and which files differ between folder1 and folder2, excluding those matching pattern "node_modules".
diff -rqyl folder1 folder2 --exclude=node_modules

Print symlink resolved script file name
echo $(basename $(readlink -nf $0))

Print the $N'th line from file by replacing commas (',') with newlines
head -$N file | tail -1 | tr ',' '\n'

Print the 2nd white space separated fields in "file.txt" as a comma separated list
awk '{print $2}' < file.txt | paste -s -d, -

Print the 5th space separated fields in "file" as a comma separated list
cut -d' ' -f5 file | paste -d',' -s

Prints the absolute directory path of the current script preceded by the string "dirname/readlink: "
echo "dirname/readlink: $(dirname $(readlink -f $0))"

Print the absolute path of third-level files under the current directory tree and number the output
ls -d -1 $PWD/**/*/* | nl

Print the average round trip time of 5 pings to "google.com" from OSX
ping -c 5 google.com | grep "round-trip" | cut -f 5 -d "/"

Ping the broadcast address "10.10.0.255"
ping -b 10.10.0.255

Print the byte count of all regular files found in the current directory tree
find . -type f | xargs | wc -c

Print the calendar for February 1956
cal 02 1956

Print the characters in $b that match with any character in $a without printing any newline
echo "$b" | grep -o "[$a]" | tr -d '\n'

Print the characters in $b that match with any character in $a without printing any whitespace in-between
echo "$b" | grep --only-matching "[$a]" | xargs | tr --delete ' '

Print the commands that would execute "myfile" on all .ogv files from the current directory tree
find ./ -name *.ogv -exec echo myfile {} \;

Print the compressed size, uncompressed size, compression ratio, and uncompressed filename of "file.zip"
gunzip -l file.zip

Print the contents of "/tmp/nums" as input to "addnums"
cat /tmp/nums | addnums

Print the contents of "Little_Commas.TXT"
cat Little_Commas.TXT

Print the contents of "file" in reverse order
nl file | sort -nr | cut -b8-

Print the contents of "filename"
cat filename

Print the contents of "foo.txt" starting with line 2
tail -n +2 foo.txt

Print the contents of "my_script.py"
cat my_script.py

Print the contents of "n"
cat n

Print the contents of "numbers.txt"
cat numbers.txt

Print the contents of "order.txt"
cat order.txt

Print the contents of "xx.sh"
cat xx.sh

Print the contents of "~/.ssh/config"
cat ~/.ssh/config

Print the contents of all file* files under current directory
perl -ple '' `find . -name "file*"`

Print the contents of all file* files under current directory with white space safety in file names
find . -name "file*" -print0 | xargs -0 perl -ple ''

Print the cp commands that would be required to copy all *.data files under /source_path to /target_path by appending the parent directory names in the source paths to the beginning of each of the target file names
find /source_path -name \*.data  | while read -r filename; do printf "print version: cp %s %s\n" "${filename}" "$(printf "%s\n" "${filename}" | sed "s/^.*[/]\(category[^/]*\)[/]\(.*[.]data\)$/\/target_path\/\1_\2/")"; done

Print the current date followed by ' doing stuff'
echo $(date) doing stuff

Print the current date in '%H:%M:%S' format followed by the string ': done waiting. both jobs terminated on their own or via timeout; resuming script'
echo "$(date +%H:%M:%S): done waiting. both jobs terminated on their own or via timeout; resuming script"

Print the current default full path of the "java" executable
echo "The current default java is $(readlink --canonicalize `which java`)"

Print the current directory tree
tree

Print the current directory tree with file permissions
tree -p

Print the current directory tree with file sizes
tree -s

Print the current directory tree with the date of last modification for each file or directory
tree -D

Print the current shell
ps -p $$ | tail -1 | awk '{print $NF}'

Print the current user's mail file in "/var/spool/mail"
cat /var/spool/mail/`whoami`

Print the current user's real name
getent passwd `whoami` | cut -d : -f 5

Print the current user name and inode number of "/home"
echo `whoami` `stat -c %i "/home"`

Print the current working directory and the base name of "$1"
echo "$(pwd)/$(basename "$1")"

Print the current working directory prepended by "pwd: "
echo pwd: `pwd`

Print the current working directory with resolved symbolic links
pwd -P

Print the current working directory without a trailing newline
echo -n $(pwd)

Print the date followed by the host name
echo `date` `hostname`

Print the date formatted with "%a %x %X" followed by the host name
echo `date +"%a %x %X"` `hostname`

Print the date, then prompt "Hit ENTER or wait ten seconds" with a 10 second timeout, then the date again
date ; read -t 10 -p "Hit ENTER or wait ten seconds" ; echo ; date

Print the directory name of the full real path to the current script
echo "dirname/readlink: $(dirname $(readlink -f $0))"

Print the directory name of the physical current working directory
dirname `pwd -P`

Print the directory name of the real full path of "relative/path/to/file" where each symbolic link component must exist
dirname `readlink -e relative/path/to/file`

Print the directory of the full path to the current script
echo $(dirname $(readlink -m $BASH_SOURCE))

Print the directories that are taken by the glob pattern $SrvDir*
find $SrvDir* -maxdepth 0 -type d

Print the day 1 day ago
date --date='1 days ago' '+%a'

Print the day at 1 day ago in 2 months from now
date -d "$(date -d "2 months" +%Y-%m-1) -1 day" +%a

Print the empty directories and files under current directory
find -empty

Print the empty files/directories among empty1, empty2 and not_empty
find empty1 empty2 not_empty -prune -empty

Print the base name via grep of the current working directory
pwd | grep -o '[^/]*$'

Print the base name of the current working directory
basename "`pwd`"

Print the base name of the current working directory
basename $(pwd)

Print the base name of the current working directory
basename `pwd`

Print the base name of the current working directory
echo "$(basename $(pwd))"

Print the base name of the current working directory
pwd | xargs basename

Print the text file paths that match 'needle text' in their contents under 'my_folder' recursively
grep -rl "needle text" my_folder | tr '\n' '\0' | xargs -r -0 file | grep -e ':[^:]*text[^:]*$' | grep -v -e 'executable'

Print the files in the current directory as a list of comma separated values
ls -1 | tr '\n' ','

Print the files in the current directory as a list of semicolon separated values
ls -1b | tr '\n' ';'

Print the files in the current directory as a list of semicolon separated values
ls -m | tr -d ' ' | tr ',' ';'

Print the files under current directory twice per line
find . -type f -exec echo {} {} \;

Print the filenames taken by the glob pattern * with null character as the delimiter
find * -maxdepth 0 -type d -print0

Print the file content of command "[whatever]"
cat `find [whatever]`

Print the file content of command "f"
cat "$(which f)"

Print the file content of command "f"
cat `which f`

Print the file names along with their sizes under current directory tree
find . -type f -printf "%f %s\n"

Print the UID of the owner, GID of the group, the permission bits and the path into /tmp/dir1.txt for all files/directories under /path/to/dir1
find /path/to/dir1 -printf "%U %G %m %p\n" > /tmp/dir1.txt

Print the file paths and their sizes for all files under full_path_to_your_directory
find full_path_to_your_directory -type f -printf '%p %s\n'

Prints the file path composed from the path where symlink target file is located, and name of the symbolic link itself.
echo "$(dirname $(readlink -e $F))/$(basename $F)"

Print the file size and directory size in human readable format of the current directory tree 2 levels deep
tree --du -h -L 2

Print the file sizes along with their paths for all *.txt (case insensitive) files/directories under current directory tree
find . -iname "*.txt" -exec du -b {} +

Print the file sizes along with their paths for all *.txt (case insensitive) files/directories under current directory tree
find . -name "*.txt" -print0 |xargs -0 du -ch

Print the file sizes for all files under current directory
find . -type f -printf '%p %s\n' | perl -n -a -e '$sum+=$S[1]; print "$sum\n"'

Print the file system "file/goes/here" is on
df -P file/goes/here | tail -1 | cut -d' ' -f 1

Print the file system disk space usage for "/dev/disk0s2" if exists
df | grep /dev/disk0s2

Print the file type of the full path of "rename"
file $(readlink -f $(type -p rename))

Print the first 10 files or directories found in the /tmp directory tree by `find'
find /tmp  | head

Print the first 10 files or directories found in the current directory tree by `find'
find | head

Print the first 2 lines of tree's help message by redirecting it from standard error to standard output
tree --help 2>&1 | head -n2

Print the first 2 lines of tree's help message by redirecting it from standard error to standard output
tree --help |& head -n2

Print the first 20 of the most changed ".cs" files in git
git log --pretty=format: --name-only | grep .cs$ | sort | uniq -c | sort -rg | head -20

Print the first 24 alphanumeric characters from "/dev/urandom", determining C locale for all categories
cat /dev/urandom | LC_ALL=C tr -dc 'a-zA-Z0-9' | fold -w 24 | head -n 1

Print the first 32 hexadecimal characters from "/dev/urandom"
cat /dev/urandom | tr -cd 'a-f0-9' | head -c 32

Print the first 32 hexadecimal characters from "/dev/urandom", determining C locale for character handling functions
cat /dev/urandom | env LC_CTYPE=C tr -cd 'a-f0-9' | head -c 32

Print the first 5 decompressed lines of compressed file "$line"
zcat "$line" | head -n5

Print the first line of "filename" as a hex dump of characters
head -n 1 filename | od -c

Print the first line of "seq 1 10000"
seq 1 10000 | head -1

Print the first line of each file under the home directory
find $HOME/. -name *.txt -exec head -n 1 -v {} \;

Print the first line of output after alphabetically sorting the file "set"
head -1 <(sort set)

Print the first two bytes of "my_driver" in octal
od --read-bytes=2 my_driver

Print the full name of "$USER"
finger $USER |head -n1 |cut -d : -f3

Print the full name of the current user
finger `id -un` | head -1 | cut -d: -f3-

Print the full path of a 'file.txt' file in the current folder.
ls "`pwd`/file.txt"

Print the full path of a file under the current working directory with inode number specified on standard input
xargs -n 1 -I '{}' find "$(pwd)" -type f -inum '{}' -print

Print the full path of command "gcc"
which gcc

Print the full path of command "rails"
which rails

Print the full path of executable "lshw"
which lshw

Print the full path prefix for all files in the current directory tree as a list
tree -fi

Print the full real path of "/dev/disk/by-uuid/$1" followed by "is mounted"
echo $(readlink -f /dev/disk/by-uuid/$1) is mounted

Print the full real path of "/dev/disk/by-uuid/$1" followed by "is not mounted"
echo $(readlink -f /dev/disk/by-uuid/$1) is not mounted

Print the git log in a tabular form
git log --pretty=format:'%h|%an|%s' -10 | column -t -s '|'

Print the set difference of "command_which_generate_N" and "command_which_generate_M"
comm -23 <(command_which_generate_N|sort) <(command_which_generate_M|sort)

Print the given file name's extensions.
echo "$NAME" | cut -d'.' -f2-

Print the grand total disk usage of all files listed in "files.txt"
cat files.txt | xargs du -c | tail -1

Print the help message for tree
tree --help

Print the help message of command "split"
split --help

Print the hexadecimal bytes and printable characters of "Hello world"
echo Hello world | od -t x1 -t c

Print the IP addresses for the current host name
host `hostname` | awk '{print $4}'

Print the IP addresses for the current host name
hostname  -I

Print the IP addresses for the current host name
hostname  -I | cut -f1 -d' '

Print the IP addresses for the current host name
hostname -i

Print the IP addresses of the host name
hostname -I

Print the kernel configuration options found in "/proc/config.gz"
cat /proc/config.gz | gunzip

Print the largest 20 files under current directory
find . -type f -printf '%k %p\n' |sort -n |tail -n 20

Print the largest 20 files under current directory
find . -type f -printf '%s %p\n' | sort -rn | head -20

Print the last 10 commands in history
history | tail

Print the last 10 commands in history
history | tail -10

Print the last 10 commands in history
history | tail -n 10

Print the last 10 lines of "great-big-file.log"
tail great-big-file.log

Print the last 10 lines of the file '/var/log/syslog'
tail /var/log/syslog

Print the last 1000 lines of all files matching "/var/spool/cron/*"
tail -n 1000 /var/spool/cron/*

Print the last space separated word from "Your string here"
echo "Your string here"| tr ' ' '\n' | tail -n1

Print the last space separated word from "a b c d e"
echo "a b c d e" | tr ' ' '\n' | tail -1

Print the last line of "$file1" to the console and append to "$file2"
tail -1 $file1 | tee -a $file2

Print the last line of the alphabetically sorted lines in file "set"
tail -1 <(sort set)

prints the last non-empty line of a file
tac $FILE | grep -m 1 '.'

prints the last non-empty line of a file
tac FILE |egrep -m 1 .

Prints the length, line number, and contents of the longest line in myfile
perl -ne 'print length()."  line $.  $_"' myfile | sort -nr | head -n 1

Print the list of .txt files under and below the current directory
find . -name '*.txt' -print0|xargs -0 -n 1 echo

Print the list of 1st level subdirectories in /fss/fin
find /fss/fin -d 1 -type d -name "*" -print

Print the list of all directories in the /myfiles directory tree
find /myfiles -type d

Print the list of all directories under the current directory and below
find ./ -type d -print

Print the list of all files in the current directory except for SVN, CVS, GIT, and binary files
find . -not \( -name .svn -prune -o -name .git -prune -o -name CVS -prune \) -type f -print0 | xargs -0 file -n | grep -v binary | cut -d ":" -f1

Print the list of all files under the current directory and below
find .

Print the list of all regular files from the current directory tree that contain "confirm", case insensitive
find . -type f -exec grep -il confirm {} \;

Print the list of all regular files in the current directory and below
find . -type f

Print the list of all regular files on the system using "echo"
find / -type f -exec echo {} \;

Print the list of all regular files residing in the current directory and below
find ./ -type f -print

Print the list of all subdirectories of the current directory
find . -maxdepth 1 -mindepth 1 -type d

Print the list of directories that are present in the /mnt/raid directory tree
find /mnt/raid -type d

Print the list of files and directories of the /etc directory
find /etc   ! -name /etc

Print the list of files and directories of the /etc directory
find /etc/. ! -name . -prune

Print the list of files and directories of the /etc directory
find /etc/. ! -name /etc/.

Print the list of files and directories of the current directory
find . ! -name . -prune

Print the list of files and directories of the current directory including "."
find . \( -name . -o -prune \)

Print the list of files changed within the last minute
find / -newerct '1 minute ago' -print

Print the list of files from the "/zu/durchsuchender/Ordner" directory tree whose names begin with "beispieldatei" and which contain string "Beispielinhalt"
find "/zu/durchsuchender/Ordner" -name "beispieldatei*" -print0 | xargs -0 grep -l "Beispielinhalt"

Print the list of files in the current directory tree excluding those whose paths contain "exclude3" or "exclude4"
find . | egrep -v "(exclude3|exclude4)" | sort

Print the list of files in the current directory tree skipping SVN files
find . -name .svn -a -type d -prune -o -print

Print the list of files in the current directory tree skipping SVN files
find . -path '*/.svn*' -prune -o -print

Print the list of files in the current directory tree skipping SVN files
find . -type d -name .svn -prune -o -print

Print the list of files in the current directory tree with "xx" preceding and following each filename
find . -exec echo xx{}xx \;

Print the list of files in the home directory tree whose names begin with "Foto"
find ~ -name 'Foto*'

Print the list of non-hidden directories in the current directory
find -type d -maxdepth 1 ! -name ".*" -printf "%f\n"

Print the list of regular files from the current directory that were last modified on November, 22
find . -maxdepth 1 -type f -newermt "Nov 22" \! -newermt "Nov 23" -exec echo {} +

Print the list of regular files from the current directory tree that were modified less than 2 days ago
find . -type f -mtime -2 -exec echo {} +

Print the list of regular files in the current directory and all subdirectories
find . -type f

Print the list of the current directory's subdirectories
find -maxdepth 1 -type d

Print the list of the current directory's subdirectories
find . -maxdepth 1 -mindepth 1 -type d -printf '%f\n'

Print the list of the current directory's subdirectories
find . -type d -maxdepth 1

Print the list of the subdirectories of /path/to/dir
find /path/to/dir/ -mindepth 1 -maxdepth 1 -type d

Print the list of the subdirectories of the current directory
find . -mindepth 1 -maxdepth 1 -type d -printf "%P\n"

print the line containing TERMINATE and everything after in 'file'
tail -n "+$(grep -n 'TERMINATE' file | head -n 1 | cut -d ":" -f 1)" file

Print the lines of file "strings" not specified in file "index"
join -v 2 index <(nl strings)

Print the lines of file "strings" specified in file "index"
join <(sort index) <(nl strings | sort -b)

Print the line with most consecutive repeats prefixed with its count from standard input
uniq -c | sort -n | tail -n1

Print the longest line in "filename"
perl -ne 'print ($l = $_) if (length > length($l));' filename | tail -1

Print the most recently modified file
ls -1tr * | tail -1

Print the most repeated line in "list2.txt" that exists in "list1.txt" prefixed by the number of occurrences
grep -Ff list1.txt list2.txt | sort | uniq -c | sort -n | tail -n1

prints the maven project version
mvn help:evaluate -Dexpression=project.version | tail -8 | head -1

Print the names and sizes of all regular files from the current directory tree
find . -type f -printf "%f %s\n"

Print the names and sizes of regular files residing in the current directory tree
find $(pwd)/* -type f -exec stat -c "f%15s %n" {} +

Print the name of "file1" if this file is newer than "file2"
find file1 -prune -newer file2

Print the names of all files and directories found in the current directory tree
find . -exec printf '%s\0' {} \;

Print the names of all files and directories in the current directory tree
find .

Print the names of all files and directories in the current directory tree
find . -print

Print the names of all files from the /tmp/dir1 directory tree
find /tmp/dir1 -exec basename {} \;

Print the names of all files in or below the current directory, with all of the file permission bits S_ISUID, S_ISGID, and S_IWOTH set
find . -perm -o+w,+s

Print the names of all files in the home directory and its subdirectories recursively whose MIME type is video
find ~ -type f -exec file -i {} + | grep video

Print the names of all hidden regular files from the current directory
find . -maxdepth 1 -type f -name '.*' -exec basename {} \;

print the names of all of the unstripped binaries in the /usr/local directory tree. Builtin tests avoid running file on files that are not regular files or are not executable
find /usr/local -type f -perm /a=x | xargs file |  grep 'not stripped' | cut -d: -f1

Print the names of all regular files in the current directory tree
find . -type f -exec echo {} \;

Print the names of all the files from directory tree ~/some/directory whose names end in "rb"
find ~/some/directory -name "*rb" -exec basename {} \;

Print the names of any differing files in directories "dir1/" and "dir2/"
diff  --brief --recursive dir1/ dir2/

prints the name of the current git branch
git status | head -1 | cut -d ' ' -f 3

Print the names of the directories from the paths expanded by the glob pattern /path/to/directory/*
find  /path/to/directory/* -maxdepth 0 -type d -exec basename {} \;

Print the names of the directories from the paths expanded by the glob pattern /path/to/directory/*
find /path/to/directory/* -maxdepth 0 -type d -exec basename -a {} +

Print the names of the directories from the paths expanded by the glob pattern /path/to/directory/*
find /path/to/directory/* -maxdepth 0 -type d -printf '%f\n'

Print the names of the subdirectories of /usr/local/svn/repos/ prepending "/usr/local/backup" to them
find /usr/local/svn/repos/ -maxdepth 1 -mindepth 1 -type d -exec echo /usr/local/backup{} \;

Print the newest *.txt file under current directory with timestamp and path
find . -name "*.txt" -printf "%T@ %p\n" | sort | tail -1

Print the number of entries (files, directories, symlinks, etc.) in the subdirectories of the current directory, stopping search at any device mount points.
sudo find . -xdev -type f | cut -d "/" -f 2 | sort | uniq -c | sort -n

Print the number of lines for each *.txt file from the $DIR directory tree
find $DIR -name "*.txt" -exec wc -l {} \;

Print the number of lines in file.txt.
wc -l file.txt | cut -f1 -d" "

Print the home folder of "$USER_NAME"
finger $USER_NAME | grep Directory | expand | cut -d ' ' -f 2

Print the path composed of the current working directory and the directory containing "$0"
echo `pwd`/`dirname $0`

Print the path names of all .png files in the /home/kibab directory tree
find /home/kibab -name '*.png' -exec echo '{}' ';'

Print the path names of all files and directories in the current directory tree
find -printf '"%h/%f" '

Print the path names of all regular .rb files prefixing them with string "Hello, "
find . -name "*.rb" -type f | xargs -I {} echo Hello, {} !

Print the paths of the directories from the paths expanded by the glob pattern /path/to/directory/*
find /path/to/directory/* -maxdepth 0 -type d

Print the path to all *.so files under current directory and search for mysymbol in their symbol tables
find . -type f -print -exec sh -c "readelf -s {} | grep mysymbol" \;

Print the pathnames of all files from the /tmp/dir1 directory tree
find /tmp/dir1 -exec echo {} \;

Print the percentage of packets lost of the 5 packets sent to "$host"
ping -c 5 -q $host | grep -oP '\d+(?=% packet loss)'

Print the physical current working directory
echo "`pwd -P`"

Prints the PID, PGID and command name of the process with the name 'test' every second
watch -n1 'ps x -o "%p %r %c" | grep "test" '

Print the real path of "$F" where each symbolic link component must exist
echo "$(dirname $(readlink -e $F))/$(basename $F)"

Print TXT record with server`s hostname from nameserver 'server'
dig @server hostname.bind ch txt

Print the gcc version installed on "machine.example.com" using identity file "identity_file" and suppressing the known hosts check and warnings
ssh -o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no -o LogLevel=quiet -i identity_file machine.example.org gcc -dumpversion

Print the second line of output of "ls -l"
ls -l | head -2 | tail -1

Print the second line of output of "ls -l"
ls -l | tail -n +2 | head -n1

Print the sizes and file names of all files in the current directory tree that are between 700k and 1000k
find . \( -size +700k -and -size -1000k \) -exec du -Hs {} \; 2>/dev/null

Print the sizes and names of all TXT files from the current directory tree
find . -iname "*.txt" -exec du -b {} +

Print the sizes of all files from the current directory tree
find . -iname '*.jpg' -type f -printf +%b

Print the sorted and unique parent directory paths appended with : of all the files that are executable by owner under ~/code directory without descending into hidden directories
find ~/code -name '.*' -prune -o -type f -a -perm /u+x -printf ':%h\n' | sort | uniq | tr -d '\n'

Print the sorted unique column of usernames of users who are currently logged in
finger | cut -d ' ' -f1 | sort -u

Print the sorted unique column of usernames of users who are currently logged in without the header
finger | cut -d ' ' -f1 | sort -u | grep -iv login

Print the sorted uniqe list of folders in compressed archive nginx-1.0.0.tar.gz
tar tf nginx-1.0.0.tar.gz | xargs dirname | sort | uniq

Print the terminal file of the users who are logged in with "admin" in their name
who |grep -i admin |cut -c10-20

Print the time of last boot
who -b

Print the type of the current shell
echo $(cat /proc/$$/cmdline)

Print the unique lines from standard input preserving the order they appear
nl -n ln | sort -u -k 2| sort -k 1n | cut -f 2-

Print the user name of the current user
echo `whoami`

Print the user name of the current user
whoami

Print timestamp as HH:MM:SS
date +"%T"

Prints total count all non-empty lines in files of a current folder.
rgrep . | wc -l

Prints total count of lines of all *.php files in a current folder and subfolders.
find . -name '*.php' -type f -exec cat -- {} + | wc -l

Prints total number of lines of all *.m and *.h files in a current folder and subfolders.
find ./ -type f -name "*.[mh]" -exec wc -l {}  \; | sed -e 's/[ ]*//g' | cut -d"." -f1 | paste -sd+ - | bc

Prints total number of lines of all *.php files in a current folder and subfolders.
cat `find . -name "*.php"` | wc -l

Print total size of file systems in kilobytes.
df | tail -n +2 | tr -s ' ' | cut -d ' ' -f 2 | paste -s -d+ | bc

Prints top-ten biggest top-level folders within a 'var' folder.
sudo du -hDaxd1 /var | sort -h | tail -n10

Print three lines of "some line " followed by a random number
seq -f 'some line %g' 500 | nl | sort -R | cut -f2- | head -3

Print unique list of who is logged in and the time of login formatted in columns
who -su | sort | uniq | column

Print unique lines in "file1" compared to "file2" in the order they appear
comm -23 <(sort file1) <(sort file2)|grep -f - file1

Print unique lines in "file_a" and "file_b"
sort file_a file_b|uniq -u

Print unique lines in sorted file "a.txt" compared to sorted file "b.txt"
comm -23 a.txt b.txt

Print unique lines of "a" and "b"
comm -3 a b

Print unique lines of "second-file-sorted.txt" compared to "first-file-sorted.txt"
comm -23 second-file-sorted.txt first-file-sorted.txt

Print unique lines of sorted "File 1" compared with sorted "File 2"
comm -23 "File 1" "File 2"

Print unique lines of sorted file "f1" compared to sorted file "f2"
comm -2 -3 f1 f2

Print unique lines of sorted file "file1" when compared with the list of first space separated fields of all sorted strings of file "file2"
cut -d' ' -f1 file2 | comm -13 - file1

Print unique lines of sorted file "second.txt" compared to sorted file "first.txt"
comm -13 first.txt second.txt

Prints user and group information for each logged in system user.
w | awk '{print $1}' | xargs -I '{}' id '{}'

Print user and group information of all users logged in
who | awk '{print $1}' | xargs -n 1 id

print value of the variable $PROJ_PATH of the kenneth system user environment
su -l kenneth -c 'echo $PROJ_PATH'

Print variable "$OPTARG" "$opt" times
yes "$OPTARG" | head -$opt

Print variable "$module" in formatted columns with at most 80 characters per line
echo $modules | column -t | fold | column -t

Print variable "$module" in formatted rows
column -x <<< "$(printf '%s\n' $module)"

Print variable "$opt" with double quotes deleted
echo "$opt" | tr -d '"'

Print virtual memory usage of all processes owned by "jbos[s]"
ps axu | grep jbos[s] | tr -s ' ' | cut -d' ' -f5

Print whether the sorted contents of "set1" and "set2" differ
diff -q <(sort set1) <(sort set2)

Print whether the unique contents of "set1" and "set2" differ
diff -q <(sort set1 | uniq) <(sort set2 | uniq)

Print which files differ between "dir1/" and "dir2/"
diff --brief -r dir1/ dir2/

Print which files differ between dir1 and dir2, treating absent files as empty
diff --brief -Nr dir1/ dir2/

Print which files differ in "/tmp/dir1" and "/tmp/dir2" recursively
diff -qr /tmp/dir1/ /tmp/dir2/

Print which files differ in "dir_one" and "dir_two" recursively and sort the output
diff -qr dir_one dir_two | sort

Prints year-month-date format for given time
date -d "yesterday 13:00" '+%Y-%m-%d'

Print yesterday's date
date -j -v-1d

Print yesterday's date as yyy:mm:dd
date +%Y:%m:%d -d "1 day ago"

Print yesterday's date as yyy:mm:dd
date +%Y:%m:%d -d "yesterday"

Prints yesterday's date information
date --date yesterday "+%a %d/%m/%Y"

Print yesterday's date information in "%a %d/%m/%Y" format
date -d "-1 days" +"%a %d/%m/%Y"

Print your/dir if it's an empty directory
find your/dir -prune -empty -type d

Process all files matching pattern 'file*' and residing in the xargstest/ directory tree with script `myscript.sh'
find xargstest/ -name 'file*' -print0 | xargs -0 myscript.sh

Process all files matching pattern 'file??' and residing in the xargstest/ directory tree with script `myscript.sh'
find xargstest/ -name 'file??' | xargs myscript.sh

Process each file beginning with "file" in the current directory as an argument to "bash script.sh"
find -type f -maxdepth 1 -name 'file*' -print0 | sort -z | xargs -0 bash script.sh

Processes all files recursively in /var/spool/cron/tabs folder and filters out all strings with '#'.
grep -v "#" -R  /var/spool/cron/tabs

Prompt the user with a question "This is the question I want to ask?" and save "y" or "n" in variable "REPLY" in zsh
read REPLY\?"This is the question I want to ask?"

Pushes current folder to the directory stack.
pushd $(/bin/pwd)

Quietly searches pattern in a given strings. Exits with zero status if any match is found, otherwise exits with non-zero.
grep -q "tar archive" <<<$filetype

Read 10 bytes from $0 and print them by replacing the set '\000-\377' with '#'
head -c 10 "$0" | tr '\000-\377' '#'

Read a line from an interactive shell's standard input into variable "message" without backslash escapes and prompt $'Please Enter a Message:\n'
read -rep $'Please Enter a Message:\n' message

Read a line from standard input
read

Read a line from standard input and save each word in the bash array variable "arr"
read -a arr

Read a line from standard input and save each word in the bash array variable "first"
read -a first

Read a line from standard input and save received words sequentially in variables XPID XUSERID XPRIORITY XVIRTUAL XRESIDENT XSHARED XSTATE XCPU XMEM XTIME XCOMMAND
read XPID XUSERID XPRIORITY XVIRTUAL XRESIDENT XSHARED XSTATE XCPU XMEM XTIME XCOMMAND

Read a line from standard input in an interactive shell into variable "input" with prompt "Do that? [Y,n]" and suggestion "Y"
read -e -p "Do that? [Y,n]" -i Y input

Read a line from standard input in an interactive shell with prompt in variable "myprompt" interpreted as PS1 is interpreted
read -e -p "${myprompt@P}"

Read a line from standard input into the first argument ("$1") using an interactive shell with prompt "> "
read -e -p '> ' $1

Read a line from standard input into the variable "yn" with the prompt "Do you wish to install this program?"
read -p "Do you wish to install this program?" yn

Read a line from standard input into variable "ENTERED_PASSWORD" without echoing the input
read -s ENTERED_PASSWORD

Read a line from standard input into variable "PASSWORD"
read PASSWORD

Read a line from standard input into variable "REPLY" with prompt "$*"
read -p "$*"

Read a line from standard input into variable "REPLY" with prompt "$1 ([y]es or [N]o): "
read -p "$1 ([y]es or [N]o): "

Read a line from standard input into variable "REPLY" with prompt "> $line (Press Enter to continue)"
read -p "> $line (Press Enter to continue)"

Read a line from standard input into variable "REPLY" with prompt "Press [Enter] key to release lock..."
read -p "Press [Enter] key to release lock..."

Read a line from standard input into variable "YESNO" ignoring backslash escapes and using the prompt "$(echo $@) ? [y/N] "
read -r -p "$(echo $@) ? [y/N] " YESNO

Read a line from standard input into variable "a" without backslash escapes
read -r a

Read a line from standard input into variable "ans" without backslash escapes
read -r ans

Read a line from standard input into variable "date" with prompt "BGC enter something", and storing typed backslash as backslash symbol
read -p 'BGG enter something:' -r data

Read a line from standard input into variable "dir"
read dir

Read a line from standard input into variable "message" with escaped prompt "Please Enter a Message: \n\b"
read -p "$(echo -e 'Please Enter a Message: \n\b')" message

Read a line from standard input into variable "message" with prompt "Please Enter a Message: " followed by a newline
read -p "Please Enter a Message: `echo $'\n> '`" message

Read a line from standard input into variable "message" with prompt "Please Enter a Message: " followed by a newline
read -p "`echo -e 'Please Enter a Message: \n\b'`" message

Read a line from standard input into variable "message" with the prompt "Please Enter a Message: $cr"
read -p "Please Enter a Message: $cr" message

Read a line from standard input into variable "password" without echoing the input
read -s password

Read a line from standard input into variable "password" without echoing the input and using the prompt "Password: "
read -s -p "Password: " password

Read a line from standard input into variable "prompt" with the prompt "Are you sure you want to continue? <y/N> "
read -p "Are you sure you want to continue? <y/N> " prompt

Read a line from standard input into variable "response" ignoring backslash escapes and using the prompt "Are you sure? [y/N] "
read -r -p "Are you sure? [y/N] " response

Read a line from standard input into variable "text" with the prompt " Enter Here: "
read -p " Enter Here : " text

Read a line from standard input with a timeout of 0.1 seconds and prompt "This will be sent to stderr"
read -t 0.1 -p "This will be sent to stderr"

Read a line from standard input with a timeout of 10 seconds
read -t 10

Read a line from standard input with prompt "<Your Friendly Message here> : y/n/cancel" and save the response to variable "CONDITION"
read -p "<Your Friendly Message here> : y/n/cancel" CONDITION;

Read a line from standard input with prompt "Are you alright? (y/n) " and save the response to variable "RESP"
read -p "Are you alright? (y/n) " RESP

Read a line from standard input with prompt "Are you sure you wish to continue?"
read -p "Are you sure you wish to continue?"

Read a line from standard input with prompt "Are you sure? [Y/n]" and save response in variable "response"
read -r -p "Are you sure? [Y/n]" response

Read a line from standard input with prompt "Continue (y/n)?" and save response in variable "CONT"
read -p "Continue (y/n)?" CONT

Read a line from standard input with prompt "Continue (y/n)?" and save response in variable "choice"
read -p "Continue (y/n)?" choice

Read a line from standard input with prompt "Enter your age:\n"
read -p $'Enter your age:\n'

Read a line from standard input with prompt "Enter your choice: " and save response to variable "choice"
read -p "Enter your choice: " choice

Read a line from standard input with prompt "Enter your choice: ", arrow keys enabled, and "yes" as the default input, and save the response to variable "choice"
read -e -i "yes" -p "Enter your choice: " choice

Read a line from standard input with prompt "Is this a good question (y/n)? " and save the response to variable "answer"
read -p "Is this a good question (y/n)? " answer

Read a line of standard input in an interactive shell
read -e

Read a line of standard input into variable "_command" with the prompt as the current working directory followed by "$"
read -p "`pwd -P`\$ " _command

Read a line of standard input into variable "input_cmd" with prompt "command : "
read -p "command : " input_cmd

Read a line of standard input with prompt "Enter the path to the file: " and suggestion "/usr/local/etc/" and save the response to variable "FILEPATH"
read -e -p "Enter the path to the file: " -i "/usr/local/etc/" FILEPATH

Read a line of standard input with prompt "Enter your choice: " in an interactive shell and save the response to variable "choice"
read -e -p "Enter your choice: " choice

Read a line of standard input with prompt "My prompt: " and save it to variable "varname"
read -e -p "My prompt: " varname

Read a single character from standard input and do not allow backslash to escape characters
read -rn1

Read a single character from standard input and save to variable "y"
y=$(bash -c "read -n 1 c; echo \$c")

Read a single character from standard input in zsh
read -sk

Read a single character from standard input into variable "REPLY" ignoring backslash escapes and using the prompt "${1:-Continue?} [y/n]: "
read -r -n 1 -p "${1:-Continue?} [y/n]: " REPLY

Read a single character from standard input into variable "ans"
read -n1 ans

Read a single character from standard input into variable "doit" with prompt "Do that? [y,n]"
read -n1 -p "Do that? [y,n]" doit

Read a single character from standard input into variable "key" without backslash escapes and using an interactive shell with the prompt $'Are you sure (Y/n) : ' and default value $'Y'
read -rp $'Are you sure (Y/n) : ' -ei $'Y' key

Read a single character from standard input into variable "key" without backslash escapes and using the prompt "Press any key to continue..."
read -n1 -r -p "Press any key to continue..." key

Read a single character from standard input into variable "runCommand" with the prompt "Pick a letter to run a command [A, B, or C for more info] "
read -n1 -p "Pick a letter to run a command [A, B, or C for more info] " runCommand

Read a single character from standard input with delimeter '' and no echo
read -d'' -s -n1

Read a single character from standard input with prompt "Are you sure? (y/n) "
read -p "Are you sure? (y/n) " -n 1

Read a single character from standard input with prompt "Are you sure? "
read -p "Are you sure? " -n 1 -r

Read a single character from standard input with prompt "Is this a good question (y/n)? " and timeout of 3 seconds and save the response to variable "answer"
read -t 3 -n 1 -p "Is this a good question (y/n)? " answer

Read a single line from standard input and save to variable "line"
read line

Read all *.txt file paths under /foo into a Bash array ($files)
IFS=$'\n' read -d '' -ra files < <(find /foo -name "*.txt")

read all history lines not already read from the history file
history -n

Read hexadecimal bytes from device "/dev/midi1"
od -vtx1 /dev/midi1

Read line from file descriptor 4 and store received input in 'line' variable
read -u 4 line

Read one character from standard input into variable "REPLY"
read -n 1 -r

Read one character from standard input into variable "REPLY"
read -n1

Read one character from standard input into variable 'c'
read -n 1 c

Read standard input until a null character is found and save the result in variable "f2"
read -r -d $'\0' f2

Read standard input until a null character is found and save the result in variable "line"
read -d '' line

Read standard input until a null character is found and save the result in variable "line"
read -r -d $'\0'

Read the contents of "${some_variable}" until a null character is found and save the result in variable "content"
read -r -d $'\0' content <<< "${some_variable}"

Read the first 10 characters from standard input in an interactive shell into variable "VAR"
read -n10 -e VAR

Read the first line in "$1" and save each word in the bash array variable "to_sort"
read -a to_sort <<< "$1"

Read the first line of "$sh_lock_file" into variable "sh_lock_lastPID"
read sh_lock_lastPID < $sh_lock_file

Read the first line of output from "du -s $i" into variable "k" in ksh
du -s $i | read k

Read the history file and append the contents to the history list
history -r

Read the raw input of "/dev/input/mice" as hexadecimal bytes with 3 bytes per line
cat /dev/input/mice | od -t x1 -w3

Read two bytes from "/dev/urandom" and print them as an unsigned integer
od -A n -N 2 -t u2 /dev/urandom

Read yesterday's date with format "%a %d/%m/%Y" into variable "dt" in a subshell
date --date yesterday "+%a %d/%m/%Y" | read dt

recall the second argument from a previous command by pressing alt-shift-y
bind '"\eY": "\e2\e."'

Receive input and print it to terminal preceeding with line number
cat -n

Receive pattern to search for on the standard input and print only matching part of lines from file 'f.html'
cat f.html | grep -o \

Reconnect to a named screen session
screen -R -O -t mysession -S mysession -f

Reconnect to a named screen session
screen -x screen id

Records the number of occurences of 'needle' in the array 'haystack' into the variable 'inarray'
inarray=$(echo ${haystack[@]} | grep -o "needle" | wc -w)

Recursively add ".jpg" to all files in the current directory tree
find . -type f -exec mv '{}' '{}'.jpg \;

Recursively add ".jpg" to all files without an extension in the directory tree "/path"
find /path -type f -not -name "*.*" -exec mv "{}" "{}".jpg \;

Recursively add read and directory access to all permissions of all files and directories
chmod -R a+rX *

Recursively add read and execute permissions to all files and folders in "directory"
chmod -R +xr directory

Recursively add user write permission to all files under "/path/to/git/repo/objects"
chmod -Rf u+w /path/to/git/repo/objects

Recursively archive "test/a/" to "test/dest" excluding "test/a/b/c/d"
rsync -nvraL test/a/ test/dest --exclude=/b/c/d

Recursively change "/usr/local" owner to the current user and group to admin
sudo chown -R $(whoami):admin /usr/local

Recursively change all permissions under "theDirectory/" to 777(read,write,execute for all users)
sudo chmod -R 777 theDirectory/

Recursively changes group ownership of every file in '/var/tmp/jinfo' to 'www-data'.
chgrp -R www-data /var/tmp/jinfo

Recursively changes group ownership of everything in '/home/secondacc/public_html/community/' to 'fancyhomepage'.
chgrp -R fancyhomepage /home/secondacc/public_html/community/

Recursively changes group ownership of everything in 'files' to 'apache_user'.
chgrp -R apache_user files

Recursively changes group ownership of everything in 'files' to 'my_group'.
chgrp -R my_group files

Recursively changes group ownership of everything in a '/home/user1/project/dev' folder to 'project_dev'.
chgrp -R project_dev /home/user1/project/dev

Recursively changes group ownership of everything within '.git' to 'git'.
chgrp -R git .git

Recursively changes group ownership of everything within '/git/our_repos' to 'shared_group'.
chgrp -R shared_group /git/our_repos

Recursively changes group ownership of everything within a '/path/to/repo' to 'GROUP'.
chgrp -R GROUP /path/to/repo

Recursively changes group ownership of everything within a current folder and having group 'X_GNAME' to 'Y_GNAME'.
find . -group X_GNAME -exec chgrp Y_GNAME {} +

Recursively changes group ownership of everything within a current folder to 'admin'.
chgrp -R admin *

Recursively changes group ownership of everything within current folder to 'git'.
chgrp -R git ./

Recursively changes group ownership of the $PATH_TO_OUTPUT_FOLDER directory to $GROUP group.
chgrp -R $GROUP $PATH_TO_OUTPUT_FOLDER

Recursively changes group ownership on every file in the ${WP_ROOT}/wp-content directory to ${WS_GROUP} group.
find ${WP_ROOT}/wp-content -exec chgrp ${WS_GROUP} {} \;

Recursively changes group ownership on everything in the 'public_html' folder to 'website' group.
chgrp --recursive website public_html

Recursively change owner and group to "$JBOSS_AS_USER" of "$JBOSS_AS_DIR/"
chown -R $JBOSS_AS_USER:$JBOSS_AS_USER $JBOSS_AS_DIR/

Recursively change owner and group to "tomcat7" of "webapps", "temp", "logs", "work", and "conf"
chown -R tomcat7:tomcat7 webapps temp logs work conf

Recursively change owner to "$1" and group to "httpd" of all files in the current directory
chown -R $1:httpd *

Recursively change owner to "amzadm" and group to "root" of all files in "/usr/lib/python2.6/site-packages/"
chown amzadm.root -R /usr/lib/python2.6/site-packages/

Recursively change owner to "amzadm" and group to "root" of all files in "/usr/lib/python2.6/site-packages/awscli/"
chown amzadm.root -R /usr/lib/python2.6/site-packages/awscli/

Recursively change owner to "tomcat6" of "webapps", "temp", "logs", "work", and "conf"
chown -R tomcat6 webapps temp logs work conf

Recursively change owner to "www-data" of "/var/www/.gnome2", "/var/www/.config", and "/var/www/.config/inkscape"
chown -R www-data /var/www/.gnome2 /var/www/.config /var/www/.config/inkscape

Recursively change ownership of "/usr/lib/node_modules/" to the current user
sudo chown -R $(whoami) /usr/lib/node_modules/

Recursively change ownership of "/usr/local" to the current user
sudo chown -R `whoami` /usr/local

Recursively change ownership of "/usr/local/lib" to the current user
sudo chown -R `whoami` /usr/local/lib

Recursively change ownership of "~/.npm" to the current user
sudo chown -R $(whoami) ~/.npm

Recursively change ownership of "~/.npm" to the current user
sudo chown -R `whoami` ~/.npm

Recursively change the group of all files in "/tmp/php_session" to "daemon"
chown -R :daemon /tmp/php_session

Recursively change the group of all files in "/var/lib/php/session" to "lighttpd"
chown -R :lighttpd /var/lib/php/session

Recursively change the group ownership to "laravel" in "./bootstrap/cache"
sudo chown -R :laravel ./bootstrap/cache

Recursively change the group ownership to "laravel" in "./storage"
sudo chown -R :laravel ./storage

Recursively change the owner and group of "/home/el/svnworkspace" and "775" to "your_user_name"
chown -R your_user_name.your_user_name 775 /home/el/svnworkspace

Recursively change the owner and group of "/opt/antoniod/" to "antoniod"
chown -R antoniod:antoniod /opt/antoniod/

Recursively change the owner and group of "/workspace" and "775" to "your_user_name"
chown -R your_user_name.your_user_name 775 /workspace

Recursively change the owner and group of "subdir2" to "user2"
chown user2:user2 -R subdir2

Recursively change the owner and group of "subdir3" to "user3"
chown user3:user3 -R subdir3

Recursively change the owner and group of "~/.ssh/" to "dev_user"
chown "dev_user"."dev_user" -R ~/.ssh/

Recursively change the owner and group of all files in "/your/directory/to/fuel/" to "nginx"
chown nginx:nginx /your/directory/to/fuel/ -R

Recursively change the owner and group of all files in the current directory to "andrewr"
chown -R andrewr:andrewr *

Recursively change the owner and group of all files in the current directory to "apache"
find . -maxdepth 1 -not -name "." -print0 | xargs --null chown -R apache:apache

Recursively change the owner and group of all files in the current directory to "apache"
ls | xargs chown -R apache:apache

Recursively change the owner group of "/var/www" of to "www-data"
sudo chown -R www-data:www-data /var/www

Recursively change the owner of all "*.txt" files under "/mydir" to "root"
find /mydir -type f -name "*.txt" -execdir chown root {} ';'

Recursively change the owner of all files in "/home/test" to "test"
sudo chown -R test /home/test

Recursively change the owner of all files in "/usr/local/lib/node_modules" to the current user
sudo chown -R $USER /usr/local/lib/node_modules

Recursively change the owner of all files in "testproject/" to "ftpuser"
chown ftpuser testproject/ -R

Recursively change the owner of all files in "upload_directory" to "nobody"
chown -R nobody upload_directory

Recursively change the owner of all files in "~/tmp" to "$USER"
sudo chown -R $USER ~/tmp

Recursively change the owner of npm's directories(lib/node_modules, bin and share) to the current user
sudo chown -R $(whoami) $(npm config get prefix)/{lib/node_modules,bin,share}

Recursively change the owner to "$USER" and group to "$GROUP" of "/var/lib/cassandra"
sudo chown -R  $USER:$GROUP /var/lib/cassandra

Recursively change the owner to "$USER" and group to "$GROUP" of "/var/log/cassandra"
sudo chown -R  $USER:$GROUP /var/log/cassandra

Recursively change the owner to "${JBOSS_USER}" of "$JBOSS_LOG_DIR"
chown -R ${JBOSS_USER}: $JBOSS_LOG_DIR

Recursively change the owner to "ec2-user" and group to "apache" of all files in "/vol/html"
sudo chown -R ec2-user:apache /vol/html

Recursively change the owner to "user" and group to "www-data" of "yourprojectfoldername"
chown -R user:www-data yourprojectfoldername

Recursively change the ownership of all directories in the current directory excluding "foo" to "Camsoft"
ls -d * | grep -v foo | xargs -d "\n" chown -R Camsoft

Recursively change the ownership of all files in "/Users/xxx/Library/Developer/Xcode/Templates" to "xxx"
sudo chown -R xxx /Users/xxx/Library/Developer/Xcode/Templates

Recursively change the user and group of all files in "/var/cache/jenkins" to "root"
chown -R root:root /var/cache/jenkins

Recursively change the user and group of all files in "/var/lib/jenkins" to "root"
chown -R root:root /var/lib/jenkins

Recursively change the user and group of all files in "/var/log/jenkins" to "root"
chown -R root:root /var/log/jenkins

Recursively compress every file in the current directory tree and keep the original file
gzip -kr .

Recursively copies "$1" to "$2".
cp -R "$1" "$2"

Recursively copies "$appname.app", preserving symlinks as symlinks to the 'Payload' directory.
cp -Rp "$appname.app" Payload/

Recursively copies '$1' directory to '$2' directory.
cp -r $1 $2

Recursively copies '../include/gtest' directory to '~/usr/gtest/include/'.
cp -r ../include/gtest ~/usr/gtest/include/

Recursively copies 'SRCFOLDER' to the 'DESTFOLDER/'
cp -R SRCFOLDER DESTFOLDER/

Recursively copies 'include/gtest' to '/usr/include', preserving all attributes, and copying symlinks as symlinks, without following in source files.
sudo cp -a include/gtest /usr/include

Recursively copies 'src' to 'dest' preserving overwriting the existing files.
cp -nr src_dir dest_dir

Recursively copies /mnt/usr/lib to the '/usr/' directory, creating symbolic links on each file instead of real copying them.
cp -rs /mnt/usr/lib /usr/

Recursively copies all files in the current directory but ones that names match pattern "dirToExclude|targetDir" to the 'targetDir' directory, printing info message on each operation.
cp -rv `ls -A | grep -vE "dirToExclude|targetDir"` targetDir

Recursively copies all files in the current directory but ones with 'c' in name to the home directory.
cp -r `ls -A | grep -v "c"` $HOME/

Recursively copies everything from '/source/path/*' to the '/destination/path/', preserving from overwriting existing files, and printing info message on each operation.
cp -Rvn /source/path/* /destination/path/

Recursively copies everything under the 'current' folder to the '.hiddendir' folder.
cp * .hiddendir -R

Recursively copy "/path/to/data/myappdata/*.txt" to "user@host:/remote/path/to/data/myappdata/"
rsync -rvv /path/to/data/myappdata/*.txt user@host:/remote/path/to/data/myappdata/

Recursively copy "dir_a" to "dir_b" and delete any new files in "dir_b"
rsync -u -r --delete dir_a dir_b

Recursively copy "dir_b" to "dir_a" and delete any new files in "dir_a"
rsync -u -r --delete dir_b dir_a

Recursively copy "emptydir" to "destination/newdir"
rsync --recursive emptydir/ destination/newdir

Recursively copy "old/" to "new/" as a dry run skipping files that have matching checksums and output the name only
rsync -rcn --out-format="%n" old/ new/

Recursively copy "original_dir" to "copy_dir" preserving file/dir timestamps, displaying progress, and skipping files which match in size, keeps partially transferred files.
rsync -Prt --size-only original_dir copy_dir

Recursively copy "source", "dir", and "target" to "dir" as a dry run
rsync -rvc --delete --size-only --dry-run source dir target dir

Recursively copy /path/foo on host "prod" to local directory "/home/user/Desktop", connecting as ssh username corresponding to local username.
scp -r prod:/path/foo /home/user/Desktop

Recursively copy /path/to/foo on host "your.server.example.com" to local directory "/home/user/Desktop", connecting as ssh username "user".
scp -r user@your.server.example.com:/path/to/foo /home/user/Desktop/

Recursively copy all ".txt" files to "user@remote.machine:/tmp/newdir/"
rsync -rvv *.txt user@remote.machine:/tmp/newdir/

Recursively copy all files and directories matching "*ela*L1*TE*" in localhost's directory /tdggendska10/vig-preview-dmz-prod/docs/sbo/pdf/ to /var/www/html/sbo/2010/teacher/ela/level1 on localhost connecting as ssh user "dalvarado", in batch mode (no prompt for passwords) preserving file permissions and timestamps, and without displaying progress information.
scp -Bpqr /tdggendska10/vig-preview-dmz-prod/docs/sbo/pdf/*ela*L1*TE* dalvarado@localhost:/var/www/html/sbo/2010/teacher/ela/level1

Recursively copy all files and folders in the current directory excluding "exclude_pattern" to "/to/where/"
rsync -r --verbose --exclude 'exclude_pattern' ./* /to/where/

Recursively copy all files with names ending with .txt from dir_1 to the same location within copy_of_dir_1
rsync --recursive --prune-empty-dirs --include="*.txt" --filter="-! */" dir_1 copy_of_dir_1

Recursively copy newer files in "sourcedir/" to "user@dest.com:/dest/dir/" via ssh
rsync -auv -e ssh --progress sourcedir/ user@dest.com:/dest/dir/

Recursively copy directory "/path/to/data/myappdata" to "user@host:/remote/path/to/data/myappdata"
rsync -rvv /path/to/data/myappdata user@host:/remote/path/to/data/myappdata

Recursively copy directory "/path/to/data/myappdata" to "user@host:/remote/path/to/data/newdirname"
rsync -rvv --recursive /path/to/data/myappdata user@host:/remote/path/to/data/newdirname

Recursively copy directories "A" and "D" to directory "/path/to/target/directory" on host "anotherhost", connecting as ssh user matching current user on local host, via default TCP port for ssh (22).
scp -r A D anotherhost:/path/to/target/directory

Recursively copy directory or file /something on host "myServer" to current directory on local host, connecting as ssh user matching username on local host.
scp -r myServer:/something

Recursively copy everything in /source/path whose name doesn't begin with a period, to /destination/path, without overwriting existing files, and outputting a line for each file copied or skipped.
cp -Rvn /source/path/* /destination/path/

Recursively copy local file/directory "/copy/from/path" to remote location "/copy/to/path" on host "server", connecting as ssh user "user" and using identity key file "/path/to/your/.pemkey" instead of the default in ~/.ssh/
scp -i /path/to/your/.pemkey -r /copy/from/path user@server:/copy/to/path

Recursively compresses all files within $2 folder.
find $2 -type f -exec bzip2 {} \;

Recursively delete all files/folders named '.svn' in a current folder.
find . -name .svn -delete

Recursively lists all *.py and *.html files in a current folder.
ls **/*.py **/*.html

Recursively lists all files in a current folder and prints full path along with modification time.
stat --printf="%y %n\n" $(ls -tr $(find * -type f))

Recursively search current directory for all files with name ending with ".t1", change this to .t2
find . -name "*.t1" -exec rename 's/\.t1$/.t2/' '{}' \;

Recursively search for "string here" and write the output to the console followed by the number of matched lines
grep -r "string here" * | tee >(wc -l)

Recursively search for all directories containing "foo" (case insensitive) under the current directory, renaming them to replace "foo" (case insensitive) with "Bar"
find . -type d -iname '*foo*' -depth -exec rename 's@Foo@Bar@gi' {} +

Recursively search for all files not ending in ".xml" under the current directory, append ".xml" to the end of each file name
find . -type f \! -name '*.xml' -print0 | xargs -0 rename 's/$/.xml/'

Recursively search for all files whose name contains 'foo', and change the 'foo' in the filenames to 'bar'.
find -f \( -exec sed -i s/foo/bar/g \; , -name \*foo\* -exec rename 's/foo/bar/ {} \; \)

Recursively search for all files with names ending with "_test.rb", renaming them to end with "_spec.rb".
find . -name "*_test.rb" | xargs rename s/_test/_spec/

Recursively search for all files with names ending with "_test.rb", renaming them to end with "_spec.rb", using at most 1000000 characters per command.
find . -name "*_test.rb" | xargs -s 1000000 rename s/_test/_spec/

Recursively search for all files with names ending with "_test.rb", renaming them to end with "_spec.rb", using at most 4 concurrent processes.
find . -name "*_test.rb" | xargs -P 4 rename s/_test/_spec/

Recursively search for everything under the current directory, displaying human-readable file type description for each entry.
find . -exec file {} \;

Recursively search through directory "test" in home directory, displaying names of all directories without full paths, ie. only the name part following the last slash of each directory.
find ~/test -type d -exec basename {} \;

Recursively bind "/dev" to "/var/snmp3/dev"
mount --rbind /dev /var/snmp3/dev

Recursively bind "/sys" to "/var/snmp3/sys"
mount --rbind /sys /var/snmp3/sys

Recursively finds 'pattern' in files from current folder, and prints matched string with number only if matching whole word.
grep -rnw "pattern"

Recursively finds all "*.pas" and "*.dfm" files and prints strings with "searchtext" ignoring text distinctions, suppressing error messages, highlighting found patterns and preceding each found string with file name and string number.
find . -type f \( -name "*.pas" -o -name "*.dfm" \) -print0 | xargs --null grep --with-filename --line-number --no-messages --color --ignore-case "searchtext"

Recursively finds all "file_pattern_name" files and folders and prints strings with "pattern", searching through found folders recursively.
find ./ -name "file_pattern_name"  -exec grep -r "pattern" {} \;

Recursively finds all '*.pdf' files and folders in a current folder and removes them without prompting.
find . -name "*.pdf" -print0 | xargs -0 rm -rf

Recursively finds all '*.pdf' files in a current folder and removes them.
find . -name "*.pdf" -exec rm {} \;

Recursively finds all '*.pdf' files in a current folder and removes them.
find . -name "*.pdf" -print0 | xargs -0 rm

Recursively finds all '*.pdf' files in a current folder and removes them.
find . -name '*.pdf' -exec rm {} +

Recursively finds all '*.pdf' files in a current folder and removes them without prompting.
find . -name '*.pdf' -exec rm -f {} \;

Recursively finds all 'STATUS.txt' files containing text 'OPEN' and prints containing folder of them.
fgrep --include='STATUS.txt' -rl 'OPEN' | xargs -L 1 dirname

Recursively finds all 'STATUS.txt' files containing text 'OPEN' and prints containing folder of them.
find -type f -name "STATUS.txt" -exec grep -q "OPEN" {} \; -exec dirname {} \;

Recursively finds all *.dbf files from the root folder and prints list of folders with such files.
find / -name "*.dbf"  -exec dirname {} \; 2> /dev/null | sort -u

Recursively finds all *.dbf files from the root folder and prints list of folders with such files.
find / -name \*.dbf -print0 | xargs -0 -n1 dirname | sort | uniq

Recursively finds all bzip2 compressed files in a current folder and decompresses them.
find ./ -iname "*.bz2" -exec bzip2 -d {} \;

Recursively finds and compresses all files in a current folder.
find . -type f -exec bzip2 {} +

Recursively finds and compresses all files in a current folder with 4 parallel processes.
find . -type f -print0 | xargs -0 -n1 -P4 bzip2

Recursively finds and compresses all files in the directory '/path/to/dir'
find /path/to/dir -type f -exec bzip2 {} \;

Recursively finds all files and prints all strings with 'text-to-find-here' from that files.
find / -type f | xargs grep 'text-to-find-here'

Recursively finds all files and prints only names of files that contain "word" and suppressing error messages .
find . | xargs grep 'word' -sl

Recursively find all files ending with '*.txt' and print they names and content
find  . -name \*.txt -print -exec cat {} \;

Recursively finds all files older than 7 minutes under the current directory, saves list of found files, and compresses them, executing at most 10 compress process at a time.
find . -type f  -mtime +7 | tee compressedP.list | xargs -I{} -P10 compress {} &

Recursively finds all files in a current folder excluding already compressed files and compresses them with level 9.
find . -type f | egrep -v '\.bz2' | xargs bzip2 -9 &

Recursively finds all files in root folder and prints all strings with 'text-to-find-here' from that files, ignoring binary files.
find / -type f -exec grep -l "text-to-find-here" {} \;

Recursively finds all files in root folder and prints all strings with 'text-to-find-here' from that files, preceding matched string with filename.
find ~/ -type f -exec grep -H 'text-to-find-here' {} \;

Recursively find all files in the directory "posns" and split each one into files of at most 10000 lines each
find posns -type f -exec split -l 10000 {} \;

Recursively finds all files not like *.itp, *ane.gro, *.top in a current folder and removes them.
find . -depth -type f -not -name *.itp -and -not -name *ane.gro -and -not -name *.top -exec rm '{}' +

Recursively finds all files like "*.log" and "*.trc" in a current folder, modified in a last day, sorts list by modification time and pipes output to pager tool 'less'.
sudo find . \( -name "*.log" -o -name "*.trc" \) -mtime -1 | sudo xargs ls -ltr --color | less -R

Recursively finds all files with any cased text "Text" in a current folder, and precedes found string with its number in file.
grep -inr "Text" folder/to/be/searched/

Recursively finds all files with whole word "pattern" in a current folder, and precedes found string with its number in file.
grep -rnw `pwd` -e "pattern"

Recursively finds all folders in a current folder that contain files like '.git'.
find . -name '.git' | xargs dirname

Recursively find strings in all files under current directory, that matching with comma-separated patterns list in file 'searches-txt'
cat searches.txt| xargs -I {} -d, -n 1 grep  -r {}

Recursively finds strings like "texthere"  in all "*.txt" files of a current folder.
grep -r --include "*.txt" texthere .

Recursively finds strings with 'word-1' or 'word-2' in any file under 'directory-path', following symlinks, and prints found strings.
egrep -R "word-1|word-2” directory-path

Recursively finds strings with the whole word 'word-1' or 'word-2' in any file under 'directory-path', following symlinks, and prints found strings.
egrep -w -R "word-1|word-2” directory-path

Recursively finds strings with"text string to search” in files under 'directory-path', regarding provided options '[option]'.
grep [option] "text string to search” directory-path

Recursively finds strings with"text string to search” in any file within the 'directory-path', following symlinks, and prints found strings with file names.
grep -r -H "text string to search” directory-path

Recursively bind mount "/something" on "/new_something"
mount --rbind /something /new_something

Recursively find files in the current directory with a modification time more than 7 days ago, save the filenames to "compressedP.list", and compress each file in parallel
find . -type f  -mtime +7 | tee compressedP.list | parallel compress

Recursively find files in the current directory with a modification time more than 7 days ago, save the filenames to "compressedP.list", and compress no more than 10 at a time
find . -type f  -mtime +7 | tee compressedP.list | xargs -I{} -P10 compress {} &

Recursively finds files like '*.js', and filters out files with 'excludeddir' in path.
find . -name '*.js' | grep -v excludeddir

Recursively finds files like '*.php' or '*.phtml' in folder /project/directory ignoring case differences, filters out files with any cased pattern '/some/directory' in path, and processes found files with xgettext tool.
find /project/directory -iname '*.php' -or -iname '*.phtml' | grep -iv '/some/directory' | xargs xgettext

Recursively finds files like 'example.com', ignoring case differences, and filters out files with 'beta' in path.
find -iname example.com | grep -v beta

Recursively finds file some_file_name.xml file and prints strings with "PUT_YOUR_STRING_HERE" preceding each found string with file name.
find . -type f -name some_file_name.xml -exec grep -H PUT_YOUR_STRING_HERE {} \;

Recursively finds latest modified file in a directory
find . -type f -print0 | xargs -0 stat -f "%m %N" | sort -rn | head -1 | cut -f2- -d" "

Recursively finds last 5 modified files in a directory
find . -type f -ls 2>/dev/null | sort -M -k8,10 | head -n5

Recursively finds string 'class foo' in all *.c files from current folder.
grep "class foo" **/*.c

Recursively finds string with text "foo" in all files of a current folder.
find ./ -type f | xargs grep "foo"

Recursively find the latest modified "zip" file in the current directory
find . -name "*zip" -type f | xargs ls -ltr | tail -1

Recursively find the latest modified file in the current directory
find . -type f -print0|xargs -0 ls -drt|tail -n 1

Recursively find the latest modified file in the current directory
find . -type f -printf '%T@ %p\n' | sort -n | tail -1 | cut -f2- -d" "

Recursively find the latest modified file in the current directory
find . -type f | xargs ls -ltr | tail -n 1

Recursively find the latest modified file in the current directory and print the modification time and filename
find . -type f -printf '%TY-%Tm-%Td %TH:%TM: %Tz %p\n'| sort -n | tail -n1

Recursively findsfiles with text pattern in current folder, ingnoring case differences, prefixes each matched line with number in file and suppresses error messages about nonexistent or unreadable files.
grep -insr "pattern" *

Recursively set all permissions under "../tools" to 777
chmod -R 777 ../tools

Recursively set all permissions under "/directory" to 755
chmod -R 755 /directory

Recursively set all permissions under "/folder" to 755
chmod 755 /folder -R

Recursively set all permissions under "/opt/lampp/htdocs" to 755
sudo chmod 755 -R /opt/lampp/htdocs

Recursively set all permissions under "/whatever/your/directory/is" to 755
sudo chmod 755 -R /whatever/your/directory/is

Recursively set the file access control list of "app/cache" and "app/logs" to rwx for the current user and for user "www-data"
sudo setfacl -R -m u:www-data:rwx -m u:`whoami`:rwx app/cache app/logs

Recursively unzip files to stdout in "/some/dir/here" and search for "blah"
zcat -r /some/dir/here | grep "blah"

Recursively list contents of the current directory in a tree-like format
tree

Recursively make all mounts under "/" private
mount --make-rprivate /

Recursively move "./dir" to "user@host:/path" compressing data and displaying progress during transmission
rsync -rvz --progress --remove-sent-files ./dir user@host:/path

Recursively move "./dir" to "user@host:/path" via ssh on port 2222 compressing data and displaying progress during transmission
rsync -rvz -e 'ssh -p 2222' --progress --remove-sent-files ./dir user@host:/path

Recursively move all files in "/path/to/srcdir" to "dest/"
find /path/to/srcdir -type f -print0 | xargs -0 -i% mv % dest/

Recursively prints .txt files in current directory
find $(pwd) -name \*.txt -print

Recursively print all directories in the current directory tree
tree -d

Recursively print all files and directories in the current directory tree
tree .

Recursively print all files and directories in the current directory tree including hidden files
tree -a .

Recursively prints all files in a current folders, and searches "stringYouWannaFind" in file content ignoring case differences, and preceding found string with its number in file.
find ./ -type f -print -exec grep -n -i "stringYouWannaFind" {} \;

Recursively prints all folders in a current folder that contain files like "*.class".
find . -name "*.class" -print0 | xargs -0 -n1 dirname | sort --unique

Recursively prints paths to all text file in folder (ignores binary files).
grep -RIl "" .

Recursively removes 'classes' folder, prompting user on each deletion.
rm -r classes

Recursively remove all "*.txt" files and answer "n" to any prompt
yes n | rm -r *.txt

Recursively remove all "*.txt" files and answer "y" to any prompt
yes | rm -r *.txt

Recursively removes all empty folders from the X folder.
find X -depth -type d -exec rmdir {} \;

Recursively removes all empty folders under current folder.
find -depth -type d -empty -exec rmdir {} \;

Recursively removes all empty folders under current folder.
find . -depth -type d -empty -exec rmdir {} \;

Recursively removes all files and folders named '.svn' in a current folder.
find . -name .svn -exec rm -rf {} +

Recursively removes all files and folders named '.svn' in a current folder.
find . -name .svn -exec rm -rf {} \;

Recursively removes all files and folders named '.svn' in a current folder.
find . -name .svn | xargs rm -fr

Recursively removes all files and folders named '.svn' in a current folder.
find . -name .svn |xargs rm -rf

Recursively removes all files and folders like 'FILE-TO-FIND' from current folder.
find . -name "FILE-TO-FIND" -exec rm -rf {} +

Recursively removes all files and folders like 'FILE-TO-FIND' from current folder.
find . -name "FILE-TO-FIND" -exec rm -rf {} \;

Recursively removes all files and folders that match pattern '/usr/local/{lib/node{,/.npm,_modules},bin,share/man}/npm*'
rm -rf /usr/local/{lib/node{,/.npm,_modules},bin,share/man}/npm*

Recursively removes all files in a 'path' folder but 'EXPR' files.
find [path] -type f -not -name 'EXPR' | xargs rm

Recursively removes all files in a current folder but '*txt' files.
find . -type f -not -name '*txt' | xargs rm

Recursively removes all files named '.svn' in a current folder, and prints messages on each action.
find . -name .svn -exec rm -v {} \;

Recursively removes all files like "(__pycache__|\.pyc|\.pyo$)" in a current folder.
find . | grep -E "(__pycache__|\.pyc|\.pyo$)" | xargs rm -rf

Recursively removes all files like '*.pyc' in a current folder.
find . -name "*.pyc" -exec rm -rf {} \;

Recursively removes all files like '*.pyc' in a current folder.
find . -name "*.pyc"|xargs rm -rf

Recursively removes all files like '*.pyc' in a current folder.
find . -name '*.pyc' -print0 | xargs -0 rm

Recursively removes all files like '*.pyc' in a current folder.
rm **/*.pyc

Recursively removes all files like '*.pyc' in a current folder.
rm `find . -name \*.pyc`

Recursively removes all files like '*.pyc' in a current folder, printing info message about each action.
find . -name "*.pyc" | xargs -I {} rm -v "{}"

Recursively removes all files like '*.pyc' of '*.pyo' in a current folder without prompting.
find . -type f -name "*.py[c|o]" -exec rm -f {} +

Recursively removes all files like '*.r*' in current folder and removes folders with such files if they become empty.
find ./ -type f -name '*.r*' -delete -printf "%h\0" | xargs -0 rmdir

Recursively removes all files like '*.xyz' in a current folder.
find . -name \*.xyz -exec rm {} \;

Recursively removes all files like '.DS_Store' from current folder.
rm `find ./ -name '.DS_Store'` -rf

Recursively removes all files like '._*' from current folder.
find . -name "._*" -print0 | xargs -0 rm -rf

Recursively removes all files like '4' under folder './a' and removes folders with such files if they become empty.
find a -type f -name '4' -delete -printf "%h\0" | xargs -0 -r rmdir

Recursively removes all files like '_*' and '.DS_Store' from /var/www/html/ folder.
rm /var/www/html/**/_* /var/www/html/**/.DS_Store

Recursively removes all files like any-cased '*.pyc' in a current folder.
find . -iname '*.pyc' -print0 | xargs -0 --no-run-if-empty  rm

Recursively removes all files with name like "*.war" in  /home/ubuntu/wars folder.
find /home/ubuntu/wars -type f -name "*.war" -exec rm {} \\;

Recursively removes all files with name like "myFile.*" in 'file path' folder.
find <file path> -name "myFile.*" -exec rm -f {} ;

Recursively removes all folders named '.svn' in a current folder.
find . -type d -name .svn -print0|xargs -0 rm -rf

Redirects content of extracted file to a pipe
bunzip2 -c compressedfile.bz2 | yourfilterprogram

redirect output inside screen session
screen /bin/bash -c 'java Foo > foo.txt'

Redirects output of 'time' built-in function and prints only real-time statistic.
{ time find / &>/dev/null; } 2>&1 | grep real

Redirects output of 'time' built-in function and prints only real-time statistic.
{ time ls -l >/dev/null; } |& grep real

Redirect stderr to stdout and write to the console and "/dev/null"
xxx |& tee /dev/null

Redirect the current process's standard error to standard out and write to console and append to "$HOME/logfile"
exec > >(tee -a $HOME/logfile) 2>&1

Remove "\n" from "test1\ntest2\ntest3" and search for "test1.*test3"
echo -e "test1\ntest2\ntest3" |tr -d '\n' |grep "test1.*test3"

Remove "_dbg" from all file or directory names under the current directory
rename _dbg.txt .txt **/*dbg*

Removes 'folderName', and removes all content within if 'folderName' is folder.
rm -rf folderName

Removes 'subversion' packages from system.
yum remove subversion

Remove .DS_Store from the repository you happen to stage by mistake
find . -name .DS_Store -exec git rm --ignore-unmatch --cached {} +

remove a specific file among a group of specific files
find . -name "*.pdf" -print | grep -v "^\./pdfs/" | xargs -J X mv X ./pdfs/

Remove all "CVS" directories from the current directory tree, ignoring the case
find . -iname CVS -type d | xargs rm -rf

remove all "Foo*" files under current dir
find . -type f -name "Foo*" -exec rm {} \;

Remove all "core" files that were last changed more than 4 days ago from the current directory tree
find . -name core -ctime +4 -exec /bin/rm -f {} \;

Remove all "core" regular files in the /tmp/ directory tree
find /tmp -name core -type f -print | xargs /bin/rm -f

Remove all "work" directories residing in /usr/ports and below
find /usr/ports/ -name work -type d -print -exec rm -rf {} \;

Remove all 'a.out', '*.o', and 'core' files in the current directory tree
find . \( -name a.out -o -name '*.o' -o -name 'core' \) -exec rm {} \;

Remove all *.bak and *.backup files that were accessed last time more than 30 days ago
find . \( -name '*.bak' -o -name *.backup \) -type f -atime +30 -exec rm '{}' ';'

Remove all *.bak files under current directory
find . -type f -name \*.bak -print0 | xargs -0 rm -v

Remove all *.log files from the current directory tree
find -name '*.log' -delete

Remove all *.log files from the current directory tree
find ./ -name '*.log' -print0 | xargs -0 rm

Remove all *.log files from the current directory tree
find ./ -name '*.log' | xargs rm

Remove all *.log files from the current directory tree that have been gzipped
find ./ -name '*.log' | xargs -I{} sh -c "if [ -f {}.gz ]; then rm {}; fi"

Remove all *.m4a files in the current directory and its subdirectories
find . -type f -name '*.m4a' -exec bash -c 'rm "$0"' '{}' \;

Remove all *.mp3 files in tmp directory but not in it's subdirectories
find tmp -maxdepth 1 -name '*.mp3' -maxdepth 1 | xargs    -n1 rm

Remove all *.mp3 files in tmp directory but not in it's subdirectories
find tmp -maxdepth 1 -name '*.mp3' -maxdepth 1 | xargs    rm

Remove all *.mp3 files in tmp directory but not in it's subdirectories
find tmp -maxdepth 1 -name *.mp3 -print0 | xargs    -0 rm

Remove all *.mp3 files in tmp directory but not in it's subdirectories
rm `find tmp -maxdepth 1 -name '*.mp3'`

Remove all *.sql files in the $backup_path directory tree that were last modified more than 30 days ago
find $backup_path/* -name *.sql -mtime +30 -exec rm {} \;

Remove all *.swp files/directories under current directory
find . -name "*.swp"-exec rm -rf {} \;

Remove all *.swp files under current directory
find . -name "*.swp"|xargs rm

Remove all *.swp files under current directory ensuring white space safety
find . -name "*.swp" -print0|xargs -0 rm

Remove all *.tmp files from the /tmp directory tree
find /tmp -name "*.tmp" -print0 | xargs -0 rm

Remove all *.tmp files from the /tmp directory tree
find /tmp -name "*.tmp" | xargs rm

Remove all *.txt files, except robots.txt, under the given directory modified more than 5 minutes ago
find /home/u20806/public_html -maxdepth 1 -mmin +5 -type f -name "*.txt" ! -name "robots.txt" -delete

Remove all *.txt files, except robots.txt, under the given directory modified more than 5 minutes ago
find /home/u20806/public_html -name "robots.txt" -o -maxdepth 1 -mmin +5 -type f -name "*.txt" -delete

Remove all *.txt files in the home directory tree with confirmation
find $HOME/. -name *.txt -ok rm {} \;

Remove all *.txt files under the given directory modified more than 5 minutes ago
find /home/u20806/public_html -maxdepth 1 -mmin +5 -type f -name "*.txt" -delete

Remove all *bak files under current directory with confirmation prompt
find . -name '*bak' -exec rm -i {} \;

Remove all *~ files under current directory with confirmation prompt
find . -name '*~' -ok rm {} \;

Remove all *~ files under dir
find dir -name \*~ | xargs echo rm | ksh -s

Remove all .gz files in the current directory tree
find . -name '*.gz' -type f -printf '"%p"\n' | xargs rm -f

Remove all .php files in the /var/www/ directory
find /var/www/*.php -type f -exec rm {} \;

Remove all .sh files in the current directory tree whose names begin with "new"
find . -name "new*.sh" -exec rm -f '{}' \+

Remove all .sh files in the current directory tree whose names begin with "new"
find . -name "new*.sh" -exec rm -f '{}' \;

Remove all .sh files in the current directory tree whose names begin with "t"
find . -name "t*.sh" -exec rm -vf '{}' \;

Remove all .tmp files in and below /tmp
find /tmp -name "*.tmp" -print0 | xargs -0 rm

Remove all .tmp files in and below /tmp
find /tmp -name "*.tmp" | xargs rm

Remove all .txt files from the /full/path/dir directory tree
find /full/path/dir -name '*.txt' -exec /bin/rm {} \;

Remove all .txt files from the /full/path/dir directory tree
find /full/path/dir -name '*.txt' -print0 | xargs -0 rm

Remove all .txt files in and below the current directory
find . -name "*.txt" -delete

Remove all .txt files in and below the current directory
find . -name "*.txt" -exec rm {} +

Remove all .txt files in and below the current directory
find . -name "*.txt" -exec rm {} \;

Remove all .txt files in and below the current directory
find . -name "*.txt" -print0 | xargs -0 rm

Remove all .txt files in and below the current directory
find . -name "*.txt" | xargs rm

Remove all .txt files with spaces in names in and below the current directory
find -name "*\ *.txt" | xargs rm

Remove all Thumbs.db files from the current directory tree
find . -name Thumbs.db -exec rm {} \;

Remove all Thumbs.db (case insensitive)  files under temp/images directory
find temp/images/ -type f -iname Thumbs.db | while read FILE ; do rm "${FILE}" ; done

Remove all \*~ files under dir
find dir -name \\*~ -exec rm {} +

Remove all a.out, *.o, and core files under the current directory
find . \( -name a.out -o -name '*.o' -o -name 'core' \) -exec rm {} \;

Remove all broken symbolic links in /usr/ports/packages
find -L /usr/ports/packages -type l -delete

Remove all broken symlinks from the /usr/ports/packages directory tree
find -L /usr/ports/packages -type l -delete

remove all core dump files from user's home directory
find ~/ -name 'core*' -exec rm {} \;

remove all core files in the file system
find / -name "*.core" -print -exec rm {} \;

remove all core files in the file system
find / -name "*.core" | xargs rm

Remove all core dump files from user's home directory
find ~/ -name 'core*' -exec rm {} \;

Remove all directories found in directory tree $LOGDIR that were modified more than 5 days ago
find $LOGDIR -type d -mtime +5 -exec rm -f {} \;

Remove all directories called "test" from the /path/to/dir directory tree
find /path/to/dir -name "test" -type d -delete

Remove all directories called "test" from the /path/to/dir directory tree
find /path/to/dir -name "test" -type d -exec rm -rf {} \;

Remove all directories called "test" from the current directory tree
find -name "test" -type d -delete

Remove all directories called "test" from the current directory tree
find -path "*/test" -type d -delete

Remove all directories called "test" from the current directory tree
find -path "*/test/*" -delete

Remove all directories called "test" from the current directory tree
find . -name test -type d -exec rm -r {} +

Remove all directories called "test" from the current directory tree
find . -name test -type d -exec rm -r {} \;

Remove all directories called "test" from the current directory tree
find . -name test -type d -print0|xargs -0 rm -r --

Remove all directories in and below the current directory
find \! -name . -type d -print0 | xargs -0 rmdir

Remove all empty files in /tmp/ and below
find /tmp -type f -empty -print | xargs rm -f

Removes all empty folders under '/path/to/the/folder' path.
find /path/to/the/folder -depth -type d -print0 | xargs -0 rmdir

Removes all empty folders under current folder.
find . -type d -empty -exec rmdir "{}" \;

Removes all empty folders under current folder.
find . -type d -exec rmdir {}\;

Removes all empty folders under path '/foo/bar' and the path itself.
find /foo/bar -type d -depth -exec rmdir -p {} +

Removes all empty folders under path '/thepath', printing info message on each operation.
find /thepath -type d -empty -print0 | xargs -0 rmdir -v

Removes all empty folders that ends with any-cased '*.bak' under '/Users/' path.
find /Users -type d -iname '*.bak' -print0 | xargs -0 rmdir

Removes all empty folders within $DELETEDIR folder.
find "$DELETEDIR" -mindepth 1 -depth -type d -empty -exec rmdir "{}" \;

Removes all empty folders with modification time more that 10 minutes ago from $homeDirData folder.
find $homeDirData -type d -mmin +10 -print0 | xargs -0 rmdir

Remove all empty regular files under the current directory and below
find ./ -type f -empty -print0 | xargs -0 rm

Remove all empty regular files under the current directory and below
find ./ -type f -size 0c -print | xargs rm

Remove all empty sub-directories under current directory
find . -depth  -type d  -empty -exec rmdir {} \;

Remove all empty sub-directories under current directory
find . -type d | tac | xargs rmdir 2>/dev/null

Remove all CVS directories from the current directory tree
find . -name 'CVS' -type d -exec rm -rf {} \;

Remove all CVS directories in the current directory tree
find . -type d -name CVS -exec rm -r {} \;

Remove all text files in the home directory with confirmation
find $HOME/. -name *.txt -ok rm {} \;

remove all text files from the current folder
find -name "*.txt" | xargs rm

remove all text files from the current folder. Print0 is used to handle files whose names have only spaces or those files which have newlines in their names
find -name "*.txt" -print0 | xargs -0 rm

Remove all files 'a.out' and *.o in the home directory tree that were accessed more than 7 days ago
find $HOME \( -name a.out -o -name '*.o' \) -atime +7 -exec rm {} \;

Remove all files and directories in the /home directory tree whose names are "Trash"
find /home -name Trash -exec rm {} \;

Remove all files and directories in the current directory by answering with "y" to all prompts
yes | /bin/rm -i *

Remove all files and directories under '/home/foo' directory tree that match with one of the name patterns '.DS_Store', '._.DS_Store' , '._*', '.TemporaryItems' or '.apdisk'
find /home/foo \( -name '.DS_Store' -or -name '._.DS_Store' -or -name '._*' -or -name '.TemporaryItems' -or -name '.apdisk' \) -exec rm -rf {} \;

Removes all files but $1 newest ones from current folder.
ls -tp | grep -v '/' | tail -n +"$1" | xargs -I {} rm -- {}

Removes all files but 5 newest ones from current folder.
ls -tp | grep -v '/$' | tail -n +6 | tr '\n' '\0' | xargs -0 rm --

Removes all files but 5 newest ones from current folder.
ls -tp | grep -v '/$' | tail -n +6 | xargs -I {} rm -- {}

Remove all files containing 'sample' (case insensitive) in their names under '/home/user/Series' directory tree
/usr/bin/find /home/user/Series/ -iname "*sample*" -exec rm {} \;

Remove all files containing 'sample' (case insensitive) in their names under '/home/user/Series' directory tree
find /home/user/Series/ -iname '*sample*' -exec rm {} \;

Removes all files from current folder but 3 newest ones
ls -tQ | tail -n+4 | xargs rm

Removes all files from current folder but 5 newest ones.
ls -tr | head -n -5 | xargs rm

Removes all files from current folder but 5 newest ones, filtering out directories from initial search.
ls -tp | grep -v '/$' | tail -n +6 | xargs -d '\n' rm --

Remove all files from the current directory tree whose names contain whitespaces
find . -name "* *" -exec rm -f {} \;

Remove all files from the current directory tree whose names end in "~"
find -iname '*~' | xargs rm

Remove all files from the current directory tree whose names do not end with ".tex" or ".bib"
find . | egrep -v "\.tex|\.bib" | xargs rm

Remove all files except the ones listed in "MANIFEST"
find -type f -printf %P\\n | sort | comm -3 MANIFEST - | xargs rm

Remove all files in and below the current directory whose names begin with "not"
find . -name not\* -print0 | xargs -0 rm

Remove all files in and below the current directory whose names begin with "not"
find . -name not\* | tr \\n \\0 | xargs -0 rm

Remove all files in and below the current directory whose names begin with "not"
find . -name not\* | xargs -d '\n' rm

Remove all files in the $backup_path directory recursively that were last modified more than 30 days ago
find $backup_path/* -mtime +30 -exec rm {} \;

Remove all files in the /myfiles directory tree that were accessed at least 30 days ago
find /myfiles -atime +30 -exec rm {} ;

Remove all files in the current directory tree that have the name "abc.xxx"
find . -name abc.xxx -exec rm {} \;

Remove all files in the ~/backups/mydatabasename directory recursively that were last modified more than 30 days ago
find ~/backups/mydatabasename/* -mtime +30 -exec rm {} \;

Remove all files under $DIR that were accessed more than 5 days ago
find "$DIR" -type f -atime +5 -exec rm {} \;

Remove all files under /home/user/Maildir/.SPAM/cur
find /home/user/Maildir/.SPAM/cur -type f -exec rm '{}' +

Remove all files under /home/user/Maildir/.SPAM/cur
find /home/user/Maildir/.SPAM/cur -type f -exec rm -f '{}' '+'

Remove all files under /home/user/Maildir/.SPAM/cur
find /home/user/Maildir/.SPAM/cur -type f | xargs rm

Remove all files under /myfiles that were accessed more than 30 days ago
find /myfiles -atime +30 -exec rm {} \;

Remove all files under current directory
find -exec rm '{}' +

Remove all files last modified more than 10 days ago from the current directory tree
find . -mtime +10 | xargs rm

Remove all files matching the pattern *[+{;"\\=?~()<>&*|$ ]* under current directory
find . -name '*[+{;"\\=?~()<>&*|$ ]*' -exec rm -f '{}' \;

Remove all files named "filename" from the current directory tree, ignoring directory "FOLDER1"
find . -name FOLDER1 -prune -o -name filename -delete

Remove all files named `junk' and `dummy'
find . \( -name junk -o -name dummy \) -exec rm '{}' \;

Removes all files like '*.bak' in a current folder, and prints messages about what is being done.
rm -v *.bak

Removes all files like 'A*.pdf' from current folder without prompting.
rm -f A*.pdf

Remove all files that are not newer than Jul 01 by modification time
find /file/path ! -newermt "Jul 01" -type f -print0 | xargs -0 rm

Remove all files that contain the word GUI in entire file system
find / -type f -print0 | xargs -0 grep -liwZ GUI | xargs -0 rm -f

Remove all files that end with 'prefs copy' in their names under '/mnt/zip' directory tree
find /mnt/zip -name "*prefs copy" -print | xargs rm

Remove all files that were older than 3 days
find . -type f -mtime +3 –exec rm –f {} \;

Remove all files whose names begin with "heapdump" and write their names to "delete.txt"
find . -name heapdump* -exec rm '{}' \; -print >delete.txt

Remove all files whose names begin with "no-such-thing" in the /home/peter directory tree
find /home/peter -name no-such-thing* |xargs rm

Remove all files whose names end with "~" in the /home/peter directory tree
find /home/peter -name *~ -print0 |xargs -0 rm

Remove all files whose names end with "~" in the /home/peter directory tree
find /home/peter -name *~ |xargs rm

Remove all files whose names start with spam-
find . -name 'spam-*' | xargs rm

Remove all files with '.js' extension from the 'js' directory tree
find ./js/ -type f -name "*.js" | xargs rm -f

Remove all files with a txt extension under current directory
find . -type f -name "*.txt" -exec rm {} \; -print

Remove all files with a txt extension under current directory
find . -type f -name "*.txt" -print|xargs rm

Remove all files with a txt extension under current directory
find . -type f -name "*.txt" | xargs    -I {} ksh -c "echo deleting {}; rm {}"

Remove all files with a txt extension under current directory
find . -type f -name "*.txt" | xargs    -i ksh -c "echo deleting {}; rm {}"

Remove all files with names like "vmware-*.log" from the current directory tree
find . -name "vmware-*.log" -exec rm '{}' \;

Remove all files with names like "vmware-*.log" from the current directory tree
find . -name vmware-*.log -delete

Remove all files with names like "vmware-*.log" from the current directory tree
find . -name vmware-*.log -print0 | xargs -0 rm

Remove all files with names like "vmware-*.log" from the current directory tree
find . -name vmware-*.log | xargs -i rm -rf {}

Remove all files with names like "vmware-*.log" from the current directory tree
find . -name vmware-*.log | xargs rm

Remove all files with the .c extension in the current directory tree
find . -name "*.c" -print0 | xargs -0 rm -rf

Remove all files with the .c extension in the current directory tree
find . -name "*.c" | xargs rm -rf

remove all files that's older than 30 days in '/tmp'
find /tmp -type f -mtime +30 -exec rm -f {} \;

Remove all libEGL* files from the current directory tree
find . -name libEGL* | xargs rm -f

Removes all listed folders with content in sudo mode.
sudo rm -rf /usr/local/bin/npm /usr/local/share/man/man1/node* /usr/local/lib/dtrace/node.d ~/.npm ~/.node-gyp /opt/local/bin/node opt/local/include/node /opt/local/lib/node_modules

Remove all non-hidden files in the current directory tree
find -name "*" | xargs rm -f

Remove all regular files found in and below /path
find /path -type f -exec rm '{}' +

Remove all regular files found in and below /path
find /path -type f -exec rm '{}' \;

Remove all regular files found in and below /path
find /path -type f -print | xargs rm

Remove all regular files from the current directory tree except textfile.txt, backup.tar.gz, script.php, database.sql, info.txt
find . -type f ! -regex ".*/\(textfile.txt\|backup.tar.gz\|script.php\|database.sql\|info.txt\)" -delete

Remove all regular files from the current directory tree that were modified a day ago
find . -type f -mtime 1 -exec rm {} +

Remove all regular files from the current directory tree whose names do not end with "ignore1" or "ignore2"
find . -type f -not -name '*ignore1' -not -name '*ignore2' | xargs rm

Remove all regular files from the current directory tree whose names do not end with "ignore1" or "ignore2"
find . -type f -not -name '*ignore1' -o -not -name '*ignore2' | xargs rm

Remove all regular files from the current directory tree whose names do not end with "txt"
find . -type f -not -name '*txt' -print0 | xargs -0 rm --

Remove all regular files under $DIR directory tree that were accessed more than 5 days ago
find "$DIR" -type f -atime +5 -exec rm {} \;

Remove all regular files under and below directory "$DIR" that were last accessed more than 5 days ago
find "$DIR" -type f -atime +5 -exec rm {} \;

Remove all regular files named "Waldo" in the ~/Books directory tree
find ~/Books -type f -name Waldo -exec rm {} \;

Remove all regular files with extensions php, css, ini, txt from directory tree /old/WordPress/
find /old/WordPress/ -type f -regex ".*\.\(php\|css\|ini\|txt\)" -exec rm {} \;

Remove all regular non-hidden files modified more than 7 days ago and residing in the /tmp directory tree
find /tmp -type f -name '*' -mtime +7 -print0 | xargs -0 rm -f

Remove all spaces from standard input
tr -d ' '

remove all subdirectories named "CVS" under current dir
find . -type d -name CVS -exec rm -r {} \;

remove all the "core" files in the current folder which have not been changed in the last 4 days.
find . -name core -ctime +4 -exec /bin/rm -f {} \;

remove all the DS_Store files in the current directory
find . -name .DS_Store -exec rm {} \;

remove all the log files which have not been modified in the last 5 days
find /logs -type f -mtime +5 -exec rm {} \;

remove all the core files in the home folder
find /home -name core -exec rm {} \;

remove all the core files in the temp file after user confirmation
find /tmp -name core -type f -print0 | xargs -0 /bin/rm -i

remove all the files in current folder which have the extension "DS_Store"
find . -name ".DS_Store" -exec rm {} \;

remove all the files in the current folder which have not been changed in the last 30*24 hours
find ./ -ctime +30 -type f -exec rm -f {} \;

remove all the files in the current folder which have not been modified in the last 10 days
find . -mtime +10 | xargs rm

remove all the files in the current working directory which have a specifc inode number
find . -inum $inum -exec rm {} \;

remove all the files in the folder "myfiiles" which have not been accessed in the last 30*24 hours
find /myfiles -atime +30 -exec rm {} ;

remove all the files in the present directory which have space in their name.
find . -name "* *" -exec rm -f {} \;

remove all the permissions for others to all the files in the current folder which have  read,write,execute access to users,group and others.
find * -perm 777 -exec chmod 770 {} \;

remove all the pdf files in the current folder and do not delete those in the sub folders
find . -name "*.pdf" -maxdepth 1 -print0 | xargs -0 rm

remove all the regular/normal files in the temp folder and do not delete in the sub folders
find /tmp -maxdepth 1 -type f -delete

Remove all the versioned-but-empty directories from a Subversion checkout under current directory
find . -name .svn -type d | while read ss; do dir=$(dirname "$ss"); test $(ls -a "$dir" | wc -l) == 3 && echo "svn rm \"$dir\""; done

Remove all tmp/*.mp3 files
find tmp -maxdepth 1 -name '*.mp3' -maxdepth 1 | xargs -n1 rm

Remove all tmp/*.mp3 files
find tmp -maxdepth 1 -name '*.mp3' -maxdepth 1 | xargs rm

Remove all tmp/*.mp3 files
find tmp -maxdepth 1 -name *.mp3 -print0 | xargs -0 rm

Removes all top-level *.pdf files in a current folder.
rm -f *.pdf

Removes all top-level empty folders within the current folder.
ls | xargs rmdir

Remove all vmware-*.log files/directories under current directory
find . -name vmware-*.log | xargs -i rm -rf {}

Remove all vmware-*.log files under current directory
find . -name "vmware-*.log" -exec rm '{}' \;

Remove all vmware-*.log files under current directory
find . -name vmware-*.log -delete

Remove all vmware-*.log files under current directory
find . -name vmware-*.log | xargs rm

Remove all vmware-*.log files under current directory ensuring white space safety in filename
find . -name vmware-*.log -print0 | xargs -0 rm

Remove all white space from "infile.txt" and wrap each line to 80 characters
cat infile.txt | tr -d "[:space:]" | fold -80

Remove adjascent duplicate lines from file 'input' comparing all but last space-separated fields
rev input | uniq -f1 | rev

Removes alias with 'sudo' name.
unalias sudo

Remove Mac OS X Desktop Services Store files
find . -name ".DS_Store" -exec rm {} \;

Removes strings with pattern from file 'filename'.
grep -v "pattern" filename > filename2; mv filename2 filename

Remove characters in columns 34 through 39 in the output of "finger"
finger | colrm 34 39

remote copy all text files from one location to another
find .  -name '*.txt' -exec rsync -R {} path/to/dext \;

Remove containing directories and suffix ".wiki" from specified path, output the result.
basename /home/jsmith/base.wiki .wiki

Remove containing directories from variable 'path' ie. "/some/specific/directory" becomes "directory".
path=$(basename $path)

Remove directories in /media/1Tb/videos modified more than 7 days ago
find /media/1Tb/videos -maxdepth 1 -type d -mtime +7 -exec rm -rf {} \;

Remove duplicate phrases and keep the original order of lines in "$infile"
nl -w 8 "$infile" | sort -k2 -u | sort -n | cut -f2

Remove ESC key bind
bind -r '\e'

Remove each unique item listed on standard input and do nothing if empty
sort | uniq -u | xargs -r rm

Remove trailing spaces and tabs from all *.java files under current directory
find . -type f -name "*.java" -exec perl -p -i -e "s/[ \t]$//g" {} \;

Remove trailing spaces from all files under current directory
find . -type f -print0 | xargs -0 perl -pi -e 's/ +$//'

Remove trailing spaces from all files under current directory and keep backups of the originals
find . -type f -print0 | xargs -0 perl -pi.bak -e 's/ +$//'

Remove trailing spaces from the output of 'hg st -R "$path"' and save the result in variable "var"
var=`hg st -R "$path" | sed -e 's/  *$//'`

Remove trailing spaces, replace tabs with spaces, replace Windows CRLF with Unix LF  in all *.java, *.xml and *.css files under current directory excluding ./vendor directory and its contents
find . -path ./vendor -prune -o \( -name '*.java' -o -name '*.xml' -o -name '*.css' \)  -exec gsed -i -E 's/\t/    /' \{} \; -exec gsed -i -E 's/[[:space:]]*$//' \{} \; -exec gsed -i -E 's/\r\n/\n/' \{} \;

Remove trailing tabs in .java files from the current directory tree
find . -type f -name "*.java" -exec perl -p -i -e "s/[ \t]$//g" {} \;

Remove trailing whitespaces in .txt files from the current directory tree
find . -type f -name "*.txt" -exec sh -c 'for i;do sed 's/[[:space:]]*$//' "$i">/tmp/.$$ && cat /tmp/.$$ > "$i";done' arg0 {} +

Remove trailing whitespaces in .txt files from the current directory tree
find . -type f -name "*.txt" -exec sh -c 'for i;do sed 's/[[:space:]]*$//' "$i">/tmp/.$$ && mv /tmp/.$$ "$i";done' arg0 {} +

Remove trailing white spaces from all files under current directory ignoring *.jpg, *.png and *.ttf files
find . -not \( -name *.jpg -prune -o -name *.png -prune -o -name *.ttf -prune \) --type f -print0 | xargs -0 sed -i '' -E "s/[[:blank:]]+$//"

Remove empty directories
find -type d -exec rmdir --ignore-fail-on-non-empty {} + ;

Remove empty directories from directory tree /srv/abc
find /srv/abc/ -type d -empty -exec rmdir {} \;

Removes empty folder 'edi' and 'edw'.
rmdir edi edw

Removes empty folder 'symlink'.
rm -d symlink

Removes empty folder, and hides error message if one is not empty.
rmdir --ignore-fail-on-non-empty $newBaseDir/Data/NewDataCopy

Remove leading and trailing space from lines in file 'in.txt', interactively page through a hexdump of the result.
awk '{gsub(/^[ \t]+|[ \t]+$/,""); print;}' in.txt | hexdump -C | less

Remove leading and trailing spaces from the output of 'hg st -R "$path"' and save the result in variable "var"
var="$(hg st -R "$path" | sed "s/\(^ *\| *\$\)//g")"

Removes everything from current folder but '*ddl*' and '*docs*' files.
ls -1|grep -v -e ddl -e docs| xargs rm -rf

Remove everything in a current folder prompting user on each action.
rm -ri *

Remove everything in the current directory except files matching regular expression "exclude these"
find . -maxdepth 1 | grep -v "exclude these" | xargs rm -r

Removes files 'junk1', 'junk2', 'junk3'.
rm junk1 junk2 junk3

Remove files cart4, cart5, cart6 in directory ~/junk
find ~/junk  -name 'cart[4-6]' -exec rm {}  \;

Remove files from the file system that are owned by nobody
find / -nouser -exec rm {} +

Remove files from the file system that are owned by nobody
find / -nouser -exec rm {} \;

Remove files from the file system that are owned by nobody, asking the user before each removal
find / -nouser -ok rm {} \;

Remove files erroneously named `-F'
find . -name "-F" -exec rm {} \;

Remove files in current directory according to the filenames found in ~/clang+llvm-3.3/bin/
find ~/clang+llvm-3.3/bin/ -type f -exec basename {} \; | xargs rm

Remove files in the current directory tree modified more than 31 days ago recursively
find . -type f -mtime +31 -print0 | xargs -0 -r rm -f

Remove files in the current directory tree whose names match pattern "file?"
find . -name "file?" -exec rm -vf {} \;

Remove files under /mnt/zip matching "*prets copy" with confirmation
find /mnt/zip -name "*prefs copy" -print0 | xargs -0 -p /bin/rm

Remove files under current directory that contains white space in their name
find . -name "* *" -exec rm -f {} \;

Remove files under current directory with inode number $inum
find . -inum $inum -exec rm {} \;

Remove files modified at least five days ago in directory trees /path/to/files*
find /path/to/files* -mtime +5 -exec rm {} \;

Remove files named "core" from the /work directory tree and write their names to /dev/stderr (the standard error
find /work \( -fprint /dev/stderr \) , \( -name 'core' -exec rm {} \; \)

Remove files that are greater than 1MB in size under current directory
find . -type f -size +1M -exec rm {} +

Remove files that are less than 1MB in size under current directory
find . -size -1M -exec rm {} \;

Remove files that are less than 1MB in size under current directory
find . -type f -size -1M -exec rm {} +

Removes files that are listed in file 'xaa'.
rm $(<xaa)

Remove files whose names match regular expression '^.*/[A-Za-z]+-[0-9]+x[0-9]+\.[A-Za-z]+$' from the current directory tree
find -regex '^.*/[A-Za-z]+-[0-9]+x[0-9]+\.[A-Za-z]+$' | xargs echo rm -f

Remove files whose names start with `Foo'
find . -type f -name "Foo*" -exec rm {} \;

Removes files ~/.android/adbkey and ~/.android/adbkey.pub without prompting.
rm -f ~/.android/adbkey ~/.android/adbkey.pub

Remove file with inode number 31246
find . -inum 31246 -exec rm [] ';'

Removes first and last parts of path $path and saves the result in 'finalName' variable.
finalName=$(basename -- "$(dirname -- "$path")")

Removes first and last parts of path $path and saves the result in 'finalName' variable.
finalName=$(dirname ${path#*/})

Removes first and last parts of path 'test/90_2a5/Windows' and prints the result.
echo 'test/90_2a5/Windows' | xargs dirname | xargs basename

Remove gitlab.site.org from root's known hosts file.
ssh-keygen -f "/root/.ssh/known_hosts" -R gitlab.site.org

Remove group write permission on all files output by "compaudit"
compaudit | xargs chmod g-w

removes last N lines from file.txt
head -$(gcalctool -s $(cat file | wc -l)-N) file.txt

removes last N lines from file.txt
head --lines=-N file.txt

Remove lines matching "kpt#" from "data.txt" and add left-justified line numbers
grep -v 'kpt#' data.txt | nl -nln

Remove filetype suffix (last dot and following characters if any) from filename
echo $filename | rev | cut -f 2- -d '.' | rev

Remove newline characters from "file.txt"
paste -sd "" file.txt

Remove newline characters from "yourfile.txt"
tr -d '\n' < yourfile.txt

Remove newlines from the output of "./series.bc" and pipe into "sed 's.\\..g'"
./series.bc | tr -d '\n' | sed 's.\\..g'

Remove any file containing string "GUI"
find / -type f -print0 | xargs -0 grep -liwZ GUI | xargs -0 rm -f

Remove recursively Emacs backup files in the current directory
find . -name '*~' -print0 | xargs -0 rm

Remove regular files changed more than 15 days ago from the /tmp directory tree
find /tmp/ -ctime +15 -type f -exec rm {} \;

Remove regular files in the current directory tree
find . -type f -print0 | xargs -0 -n1 echo rm | sh -x

Remove regular files whose names match Perl regular expression '\w+-\d+x\d+\.\w+$' from the current directory tree
find -type f |  grep -P '\w+-\d+x\d+\.\w+$' | xargs rm

Removes resursively all files and folders named ".DS_Store".
find . -name ".DS_Store" -print0 | xargs -0 rm -rf

Removes resursively all files and folders named "Thumbs.db", ignoring case distincts.
find . -iname "Thumbs.db" -print0 | xargs -0 rm -rf

Remove safely all *.bak and *.backup files that were accessed last time more than 30 days ago
find . -name '*.bak' -type f -atime +30 -exec csh -c 'test -s $1:r && rm $1' '{}' ';'

Removes shell alias with name 'python'.
unalias python

Remove spaces from output of "echo aa | wc -l"
echo aa | wc -l | tr -d ' '

Remove spaces recursively from all subdirectories under current directory
find /path/to/dir -type d | tac | while read LINE; do target=$(dirname "$LINE")/$(basename "$LINE" | tr -d ' '); echo mv "$LINE" "$target"; done

Remove symbolic links and get absolute path of "${the_stuff_you_test}" and save to variable "DIR_PATH"
DIR_PATH=`readlink -f "${the_stuff_you_test}"`

Removes symlinks for formula bash-completion from the Homebrew prefix.
brew unlink bash-completion

Remove the "123_" prefix from all filenames of .txt files in current directory.
find -name "123*.txt" -exec rename 's/^123_//' {} ";"

Remove the "123_" prefix from all filenames of .txt files in current directory.
rename 's/^123_//' *.txt

Remove the "^M" characters from all *.ext files under /home directory
find /home -type f -name "*.ext" -exec perl -pi -e 's/\r//g' {} \;

Remove the "^M" characters from all *.ext files under /home directory and save the results to new files with _new appended in their names
find /home -type f -name "*.ext" -print0 | while read -r -d "$(printf "\000")" -r path; do awk '{ sub("\r$", ""); print }' $path > $path"_new"; done

Remove the "^M" characters from all *.ext files under /home directory and save the results to new files with _new appended in their names
find /home -type f -name "*.ext" -print0 | while read -r -d "$(printf "\000")" -r path; do cat $path | tr -d '\r' > $path"_new"; done

Remove the "^M" characters from all *.ext files under /home directory and save the results to new files with _new appended in their names
find /home -type f -name "*.ext" -print0 | while read -r -d "$(printf "\000")" -r path; do dos2unix $path $path"_new"; done

Remove the .jpg files from the current directory whose names match regular expression ".+-[0-9]+x[0-9]+\.jpg"
find . -type f -regex ".+-[0-9]+x[0-9]+\.jpg" -exec rm -rf {} \;

Remove the .jpg files from the current directory whose names match regular expression ".+-[0-9]+x[0-9]+\.jpg"
find . -type f -regex ".+-[0-9]+x[0-9]+\.jpg" | xargs rm

Remove the files from the home directory tree that were last accessed more than 100 days ago, with confirmation
find ~/ -atime +100 -exec rm -i {} ;

Remove the files or directories 'bin/node', 'bin/node-waf', 'include/node', 'lib/node', 'lib/pkgconfig/nodejs.pc' and 'share/man/man1/node' with superuser privilege
sudo rm -rf bin/node bin/node-waf include/node lib/node lib/pkgconfig/nodejs.pc share/man/man1/node

Remove the files or directories 'bin/node', 'bin/node-waf', 'include/node', 'lib/node', 'lib/pkgconfig/nodejs.pc' and 'share/man/man1/node.1'
rm -r bin/node bin/node-waf include/node lib/node lib/pkgconfig/nodejs.pc share/man/man1/node.1

Remove the file with inode number 752010
find -inum 752010 -exec rm {} \;

Remove the first 13 characters of each ".txt" filename in the "/tmp" directory tree and number the output
find /tmp -type f \( -name '*.txt' \) |cut -c14- | nl

Remove the first 7 characters of every line in the output of "history"
history | cut -c 8-

Remove what follows the forth occurrence of the character ":" in any field which contains it
perl -pe 's/((:\S*){3}):\S*/$1/g' file | column -t

Remove the last 3 characters from 987654321, keeping only 987654
echo 987654321 | rev | cut -c 4- | rev

Remove the last line from "$file" without reading the whole file or rewriting anything
tail -n 1 "$file" | wc -c | xargs -I {} truncate "$file" -s -{}

Remove the passphrase from ~/.ssh/id_rsa.
ssh-keygen -f ~/.ssh/id_rsa -P ""

Remove the path $1 from the PATH environment variable
PATH=$(echo $PATH | tr ":" "\n" | grep -v $1 | tr "\n" ":")

Remove the regular files from the current directory that were last modified on November, 22
find -maxdepth 1 -type f -newermt "Nov 22" \! -newermt "Nov 23" -delete

Remove the regular files from the current directory tree that are newer than /tmp/date.start but not newer than /tmp/date.end
find ./ -type f -newer /tmp/date.start ! -newer /tmp/date.end -exec rm {} \;

Remove the regular files from the current directory tree that were last modified on November, 21
find -type f -newermt "Nov 21" ! -newermt "Nov 22" -delete

remove top-level domain (.com, .org) from URL's in urllist.txt
rev urllist.txt | cut -d. -f 2- | rev

Remove with prompting all files starting in /mydir that have not been accessed in over 100 days
find /mydir -atime +100 -ok rm {} \;

Remove with prompting all files that have not been accessed in over 100 days
find /mydir -atime +100 -ok rm {} \;

Remount "/" with read and write permission
mount / -o remount,rw

Remount "/" without writing in "/etc/mtab"
mount -n -o remount /

Remount "/dev/block/mtdblock3" on "/system" with read and write permission
mount -o remount,rw -t yaffs2 /dev/block/mtdblock3 /system

Remount "/dev/block/mtdblock3" on "/system" with read only permission
mount -o remount,ro -t yaffs2 /dev/block/mtdblock3 /system

Remount "/dev/sda7" partition as executable
sudo mount -o remount -o exec /dev/sda7

Remount "/dev/shm" with a maximum size of "40G"
mount -o remount,size=40G /dev/shm

Remount "/dev/stl12" on "/system" as read and write
mount -o rw,remount /dev/stl12 /system

Remount "/dev/stl12" on "/system" as read only
mount -o ro,remount /dev/stl12 /system

Remount "/media/Working/" with a umask of 000
mount /media/Working/ -oremount,umask=000

Remount "/mnt/mountpoint" as read only
mount /mnt/mountpoint -oremount,ro

Remount "/mnt/mountpoint" with read and write permission
mount /mnt/mountpoint -oremount,rw

Remount "/path/to/chroot/jail/usr/bin" as read only
mount -o remount,ro /path/to/chroot/jail/usr/bin

Remount "/system" as read only
mount -o remount,ro /system

Remount "/system" with read and write permission
mount -o remount,rw /system

Remount "/system" with read and write permission
mount -o rw,remount /system

Remount "/system" with read only permission
mount -o remount,ro /system

Remount "extX" filesystem "/dev/hdaX" on "/" without writing in "/etc/mtab"
mount -n -o remount -t extX /dev/hdaX /

Remount "point" subtree to "mnt" as a bind mount
mount --bind point mnt

Remount "rfs" filesystem "/dev/stl12" on "/system" with read and write permission
mount -o rw,remount -t rfs /dev/stl12 /system

Remount "yaffs2" filesystem "/dev/block/mtdblk4" to "/system" as read and write only
mount -o rw,remount -t yaffs2 /dev/block/mtdblk4 /system

Remount "yaffs2" filesystem "/dev/block/mtdblk4" to "/system" as read only
mount -o ro,remount -t yaffs2 /dev/block/mtdblk4 /system

Remount root filesystem "/"
mount -oremount /

Remount part of the file hierarchy from "olddir" to "newdir"
mount --bind olddir newdir

Rename "/usr/bin/php" to "/usr/bin/~php"
sudo mv /usr/bin/php /usr/bin/~php

Rename "Tux.png" to ".Tux.png"
mv Tux.png .Tux.png

Rename "blah1" to "blah1-new"
mv blah1 blah1-new

Rename "blah2" to "blah2-new"
mv blah2 blah2-new

Rename "fghfilea" to "jklfilea"
mv fghfilea jklfilea

Rename "file.txt" in directories "v_1", "v_2", and "v_3" each to "v_1.txt", "v_2.txt", and "v_3.txt" respectively and print the conversion
rename -v 's#/file##' v_{1,2,3}/file.txt

Rename "file0001.txt" to "1.txt"
mv file0001.txt 1.txt

Rename "file001abc.txt" to "abc1.txt"
mv file001abc.txt abc1.txt

Rename "new" to "old" and backup to "old.old" if "old" exists
mv new old -b -S .old

Rename "new" to "old" and make a backup if "old" exists
mv new old -b

Rename "old" to "tmp"
mv old tmp

Rename "svnlog.py" to "svnlog"
mv svnlog.py svnlog

Rename "www_new" to "www" even if "www" directory exists
mv -T www_new www

Rename $file file, preserving only part of name before '-' symbol, and appending '.pkg' suffix to the end
mv $file $(echo $file | rev | cut -f2- -d- | rev).pkg

Rename '.mkv' extension to '.avi' for all files/directories under '/volume1/uploads' directory tree
find /volume1/uploads -name "*.mkv" -exec rename 's/\.mkv$/.avi/' \{\} \;

Rename .jpg files to .jpeg in all level 2 subdirectories of the current directory
find -maxdepth 3 -mindepth 3 -type f -iname '*.jpg' -exec rename -n 's/jpg$/jpeg/i' {} +

Rename .jpg files to .jpeg in all subdirectories of the current directory
find . -maxdepth 2 -mindepth 2 -name '*.jpg' -exec sh -c 'echo mv -- "$0" "${0%%.jpg}.jpeg"' {} \;

Rename absolute path of symbolic link "dirln" to "dir2"
mv "$(readlink -f dirln)" dir2

Rename all "thumbs" directories to "thumb" in the current directory tree
find . -type d -exec rename 's/^thumbs$/thumb/' {} ";"

Rename all *$lower1* files under current directory without descending into .git directory by replacing the first occurrence of $lower1 with $lower2 in their paths
find . -name .git -prune -o type f -name "*$lower1*" -exec mmv "*$lower1*" "#1$lower2#2" {} +

Rename all *.PNG files/directories to *48.png files/directories under current directory
find . -name '*.PNG' -exec bash -c 'git mv {} $(dirname {})/$(basename {} .PNG)48.png' \;

Renames all *.html files in a 'folder' directory to *.txt files.
ls folder/*.html | xargs -I {} sh -c 'mv $1 folder/`basename $1 .html`.txt' - {}

Renames all *.html files in a current directory to *.txt files.
ls *.html | xargs -I {} sh -c 'mv $1 `basename $1 .html`.txt' - {}

Rename all *.html files under and below the current directory to *.var
find -name '*.html' -print0 | xargs -0 rename 's/\.html$/.var/'

Rename all *.jpg files under current directory by appending parent directory name at the beginning of their names
find . -iname '*.jpg' | while read fn; do name=$(basename "$fn") ; dir=$(dirname "$fn") ; mv "$fn" "$dir/$(basename "$dir")-$name" ;done ./lib/bukovina/version.jpg ./lib/bukovina/bukovina-version.jpg

Rename all *.jpg files under current directory by appending parent directory name at the beginning of their names
find . -name '*.jpg' -exec bash -c 'd="${1%/*}"; mv "$1" "$d/$d-${1##*/}"' - '{}' \;

Rename all *.jpg files under current directory by appending parent directory name at the beginning of their names if the name doesn't already contain the parent directory name
find . -name '*.jpg' -execdir bash -c 'd="${PWD##*/}"; [[ "$1" != "$d-"* ]] && mv "$1" "./$d-$1"' - '{}' \;

Rename all *.jpg files to *.jpg$.jpg files under ../<dirname>  directory by appending the parent directory name at the beginning of their names
find ../<dirname> -name '*.jpg' -exec sh -c 'mv "$0" "$(basename $(dirname $0))-${0%.JPG}$.jpg"' {} \;

Rename all *.jpg files to *.jpg$.jpg files under current directory
find . -name '*.jpg' -exec sh -c 'mv "$0" "${0%.JPG}$.jpg"' {} \;

Rename all *.jpg files to *.jpg$.jpg files under current directory by appending the parent directory name at the beginning of their names
find . -name '*.jpg' -exec sh -c 'mv "$0" "$(basename $(dirname $0))-${0%.JPG}$.jpg"' {} \;

Rename all *.txt regular files in the current directory tree to *.abc
find . -type f -iname '*.txt' -print0 | xargs -0 rename .txt .abc

Rename all *company* files/directories under current directory to *nemcompany* files/directories
for f in `find -name '*company*'` ; do mv "$f" "`echo $f | sed s/company/nemcompany/`" ; done

Rename all .html files to .txt
rename 's/\.html$/\.txt/' *.html

Rename all .html files to .txt (change filetype suffix) in a portable way without requiring the "rename" perl script.
for file in *.html; do mv "$file" "${file%.html}.txt"; done

Rename all .jpg files to .jpeg under the current directory and below
find  | rename 's/\.jpg$/.jpeg/'

Rename all .png files, changing the string "_h.png" into "_half.png".
rename 's/_h.png/_half.png/' *.png

Rename all 2.jpg files under ../D44203 by appending present working directory name at the beginning of their names
find ../D44203 -iname '2.jpg' | while read fn; do name=$(basename "$fn") ; dir=$(dirname "$fn") ; mv "$fn" "$dir/$(basename $(pwd))-$name" ;done

Rename all directories under current directory by replacing all occurrences of 'Foo' (case insensitive) with 'Bar' in their names
find . -type d -iname '*foo*' -depth -exec rename 's@Foo@Bar@gi' {} +

Rename all files in current directory to lowerase.
rename 'y/A-Z/a-z/' *

Rename all files in current directory to lowerase, overwriting any existing files.
rename -f 'y/A-Z/a-z/' *

Rename all files in current directory whose name starts with 'F0000', trimming a zero from any sequence of four zeroes in the name.
rename s/0000/000/ F0000*

Rename all files in the current directory starting with "fgh" to start with "jkl"
for f in fgh*; do mv "$f" $(echo "$f" | sed 's/^fgh/jkl/g'); done

Rename all files under current directory by formatting the filenames with the sed scripts '\''s/^([^-]*)-\s*([^\.]*)/\L\1\E-\2/'\'', '\''s/ /_/g'\'' and '\''s/_-/-/g'\''
find ./ -type f -exec bash -c 'mv "$1" "$(echo "$1" | sed -re '\''s/^([^-]*)-\s*([^\.]*)/\L\1\E-\2/'\'' -e '\''s/ /_/g'\'' -e '\''s/_-/-/g'\'')"' - {} \;

Rename all files matching "access.log.<number>.gz" incrementing <number>.
find -name 'access.log.*.gz' | sort -Vr | rename 's/(\d+)/$1+1/ge'

Rename all regular files under current directory tree with inode number 31467125 to 'new_name.html'
find . -type f -inum 31467125 -exec mv {} new_name.html \;

rename all the text files  in the current folder to html files
find -name "*.txt" -exec mv {} `basename {} .htm`.html \;

rename all the spaces in mp3 files to underscore
find . -type f -iname “*.mp3″ -exec rename “s/ /_/g” {} \;

Rename files from the current directory tree to the ASCII standard
find . -type f -exec bash -c 'for f do d=${f%/*} b=${f##*/} nb=${b//[^A-Za-z0-9._-]/_}; [[ $b = "$nb" ]] || echo mv "$f" "$d/$nb"; done' _ {} +

rename file extensions for files with specific extension in the current folder
find . -name '*.andnav' -exec sh -c 'mv "$0" "${0%.andnav}.tile"' {} \;z

Rename file ~/junk/cart1 to ~/junk/A
find ~/junk  -name 'cart1' -exec mv {} ~/junk/A \;

Rename recursively all files in the current directory tree that are called "article.xml" to "001_article.xml"
find . -name "article.xml" -exec rename 's/article/001_article/;' '{}' \;

Rename the *.so files at level 2 of the current directory tree prepending their names with "lib"
find . -mindepth 2 -maxdepth 2 -name "*.so" -printf "mv '%h/%f' '%h/lib%f'\n" | sh

Rename the *.so files in the current directory tree prepending their names with "lib"
find . -name "*.so" -printf "mv '%h/%f' '%h/lib%f'\n" | bash

Rename uppercase file or folder name $1 to lower case name
mv $1 `echo $1 | tr '[:upper:]' '[:lower:]'`

Renumbers all windows in the session in sequential order.
tmux movew -r

Repeat "image.png" 10 times on a single line
echo $(yes image.png | head -n10)

Repeat "image.png" 10 times on a single line
yes image.png | head -n10 | xargs echo

Reports count of characters in the value of ${FOO_NO_LEAD_SPACE} variable as follows: "length(FOO_NO_LEAD_SPACE)==<counted number of characters>"
echo -e "length(FOO_NO_LEAD_SPACE)==$(echo -ne "${FOO_NO_LEAD_SPACE}" | wc -m)"

Reports count of characters in the value of ${FOO_NO_TRAIL_SPACE} variable as follows: "length(FOO_NO_TRAIL_SPACE)==<counted number of characters>"
echo -e "length(FOO_NO_TRAIL_SPACE)==$(echo -ne "${FOO_NO_TRAIL_SPACE}" | wc -m)"

Reports count of characters in the value of ${FOO_NO_WHITESPACE} variable as follows: "length(FOO_NO_WHITESPACE)==<counted number of characters>"
echo -e "length(FOO_NO_WHITESPACE)==$(echo -ne "${FOO_NO_WHITESPACE}" | wc -m)"

Reports count of characters in the value of ${FOO} variable as follows:  "length(FOO)==<counted number of characters>"
echo -e "length(FOO)==$(echo -ne "${FOO}" | wc -m)"

Reports count of processors in system.
grep "^core id" /proc/cpuinfo | sort -u | wc -l

Reports count of processors in system.
grep '^core id' /proc/cpuinfo |sort -u|wc -l

Reports time consumed by command 'sleep 1'.
time sleep 1

Reports time consumed by command 'sleep 1' to the file time.txt together with command error output.
{ time sleep 1 ; } 2> time.txt

replace "exp_to_find_for_replacement" with "exp_to_replace" for all the files in the current folder
find -name ‘*exp_to_find_in_folders*’ -exec rename “s/exp_to_find_for_replacement/exp_to_replace/” {} \;

Replace "inputfile" with a sorted unique list of its contents
sort inputfile | uniq | sort -o inputfile

replace a string in all the files in the current folder
find . | xargs perl -p -i.old -e 's/oldstring/newstring/g'

replace a word in all the regular/normal files in the current folder
find . -type f -exec perl -i -pe 's/something/another/g' {} \;

replace a word in all the regular/normal files in the current folder
find /path/to/start/from/ -type f | xargs perl -pi -e 's/applicationX/applicationY/g'

Replace all ' ' with '-' from standard input
tr  ' ' '-'

Replace all colons (':') with newlines in $list and search for the first match to the regex "^$removepat\$" where $removepat is a variable and save the result to variable 'removestr'
removestr=$(echo "$list" | tr ":" "\n" | grep -m 1 "^$removepat\$")

Replace all non-punctuation characters with newlines from standard input
tr -sc '[:punct:]' '\n'

Replace all occurrence of "subdomainA.example.com" with "subdomainB.example.com" in all files under /home/www and below
find /home/www/ -type f -exec perl -i.bak -pe 's/subdomainA\.example\.com/subdomainB.example.com/g' {} +

Replace all occurrence of "subdomainA.example.com" with "subdomainB.example.com" in all files under /home/www and below
find /home/www/ -type f|xargs perl -pi -e 's/subdomainA\.example\.com/subdomainB.example.com/g'

Replace all occurrence of "subdomainA.example.com" with "subdomainB.example.com" in all files under the current directory and below
find . -type f -print0 |   xargs -0 perl -i.bak -pe 's/subdomainA\.example\.com/subdomainB.example.com/g'

Replace all spaces with underscores in directory names under current directory.
find /tmp/ -depth -name "* *" -execdir rename 's/ /_/g' "{}" \;

Replace all spaces with underscores in file paths under current directory.
find -name "* *" -type f | rename 's/ /_/g'

Replace commas (',') with newlines in $MOUNT_OPTS and search for the regex '^acl$'
echo $MOUNT_OPTS | tr , \\\n | grep '^acl$' -q

Replace each newline in input "1\n2\n3\n4\n5" with a comma
echo "1\n2\n3\n4\n5" | paste -s -d, /dev/stdin

Replace each non-blank line in "YOURFILE" preceded with "pX=" where "X" is the line number
grep -v '^$' YOURFILE | nl -s= -w99 | tr -s ' ' p

Replace each new line in "INPUT.txt" with ":"
paste -sd: INPUT.txt

Replace newline with "_" in "file" then search for "_foo_" and output with "_" characters deleted
grep -o "_foo_" <(paste -sd_ file) | tr -d '_'

Replace any blank character from standard input with a tab
tr '[:blank:]' \\t

Replace any sequence of spaces in file 'text.txt' with single space and print 4th space separated field
cat text.txt | tr -s ' ' | cut -d ' ' -f 4

Replace sequential tabs with a single space in "thefile.txt" and write to "the_modified_copy.txt"
tr -s '\t' < thefile.txt | tr '\t' ' ' > the_modified_copy.txt

Replace spaces in directory names with underscores for all directories in the current directory tree
find -name "* *" -type d | rename 's/ /_/g'

Replace spaces in file names with underscores for all files in the current directory tree
find -name "* *" -type f | rename 's/ /_/g'

Replace spaces with underscores in the names of all files and directories in the "/tmp" directory tree
find /tmp/ -depth -name "* *" -execdir rename " " "_" "{}" ";"

Replace spaces with underscores in the names of all files and directories in the "/tmp" directory tree
find /tmp/ -depth -name "* *" -execdir rename 's/ /_/g' "{}" \;

Replace spaces with underscores in the names of all files and directories in the current directory tree
find . -depth -name '* *'  | while IFS= read -r f ; do mv -i "$f" "$(dirname "$f")/$(basename "$f"|tr ' ' _)" ; done

Replace the "openssl" command executable with a symbolic link to "/usr/local/ssl/bin/openssl"
sudo ln -sf /usr/local/ssl/bin/openssl `which openssl`

Replace the text 'Windows' with 'Linux' in all text files in the current directory and below
find -type f -name '*.txt' -print0 | xargs --null perl -pi -e 's/Windows/Linux/'

Replace the text 'Windows' with 'Linux' in all text files in the current directory and below
find . -name '*.txt' -print | xargs perl -pi -e's/Windows/Linux/ig' *.txt

replace the name php_admin_flag to #php_admin_flag in all the .htaccess files in the folder /home/nobody/public_html
find /home/nobody/public_html -type f -name .htaccess -exec replace "php_admin_flag" "#php_admin_flag" -- {} \;

Request A record from nameserver $ns for domain name $d, filter strings with domain name and exclude lines matching 'DIG'
dig @$ns $d A | grep $d | grep -v "DiG"

Request changing the passphrase of key file "private.key"
ssh-keygen -pf private.key

Request IP address for each domain name received on the command input
dig +short -f - | uniq

Request IP address of 'myip.opendns.com' from name server 'resolver1.opendns.com'
dig +short myip.opendns.com @resolver1.opendns.com

Request MX record of 'example.com' domain, and filter out all comment strings
dig mx example.com | grep -v '^;' | grep example.com

Request NS record for com. domain, receiving only authoritative answers
dig NS +aaonly com.

Request SSH to run "echo foo; sleep 5; echo bar" in the background
ssh -f user@host "echo foo; sleep 5; echo bar"

Request that the master ssh connection "officefirewall" exits
ssh -O exit officefirewall

Request that the master ssh connection "otherHosttunnel" exits
ssh -O exit otherHosttunnel

Resolve any symlinks in working directory, and go to resulting pathname.
cd "`pwd -P`"

Resolve symbolic link of file "/foo/bar/baz"
readlink -e /foo/bar/baz

Resolve symbolic link of file "FILE" even if the file does not exist
readlink -m FILE

Start "xeyes" in the background on the remote server and exit the SSH session
ssh user@server 'DISPLAY=:0 nohup xeyes < /dev/null > std.out 2> std.err &'

Start 'top' to monitor all processes with the default settings.
top

start 2 sleep processes in the background
sleep 100 | sleep 200 &

Start a VLC process with a dummy (headless) interface in the background, immune to SIGHUP (hangup) signals, to play all media files in mp3_directory from the user's home directory.
nohup vlc -I dummy --quiet ~/mp3_directory/* &

start from current directory, skip the directory src/emacs and all files and directories under it, and print the names of the other files found
find . -wholename './src/emacs' -prune -o -print

start from current directory, skip the directory src/emacs and print it then skip all files and directories under it, and print the names of the other files found
find . -wholename './src/emacs' -prune , -print

start from current directory, skip the directory src/emacs and print it then skip all files and directories under it, and print the names of the other files found
find . -wholename './src/emacs' -prune -print -o -print

Start bash in a completely empty environment, without parsing /etc/bashrc or ~/.bashrc
env -i bash --norc

Start MATLAB without the desktop
matlab -nodisplay

start new screen session or to take over the most recent detached one
screen -Rd

recursively change owner and group of the directory  /opt/antoniod/ to user and group antoniod
chown -R antoniod:antoniod /opt/antoniod/

recursively change owner and group of the directory /your/directory/to/fuel/ and all files into it to user and group nginx
chown nginx:nginx /your/directory/to/fuel/ -R

recursively change owner and group of the directory and all files into it to user "user" and group "www-data"
chown -R user:www-data yourprojectfoldername

recursively change owner and group of the directory and all files into it to user root and group root
chown -R root:root /var/lib/jenkins

recursively change owner and group of the directory and group of the directory and all files into it to user and group dev_user
chown "dev_user"."dev_user" -R ~/.ssh/

recursively change owner of directories $(npm config get prefix)/lib $(npm config get prefix)/node_modules $(npm config get prefix)/bin $(npm config get prefix)/share to the current user
sudo chown -R $(whoami) $(npm config get prefix)/{lib/node_modules,bin,share}

recursively change owner of the directory /Users/xxx/Library/Developer/Xcode/Templates and all files to user xxx
sudo chown -R xxx /Users/xxx/Library/Developer/Xcode/Templates

recursively change owner of the directory /usr/lib/node_modules/ to the current user
sudo chown -R $(whoami) /usr/lib/node_modules/

recursively change owner of the directory /usr/local/lib to the current user
sudo chown -R `whoami` /usr/local/lib

recursively change owner of the directory /usr/local/lib/node_modules/ to the current user
sudo chown -R $USER /usr/local/lib/node_modules

recursively change owner of the directory and all files into it to user  nobody
chown -R nobody upload_directory

recursively change owner of the directory testproject and all files into it to user ftpuser
chown ftpuser testproject/ -R

recursively change owner of the directory ~/.npm to the current user
sudo chown -R $(whoami) ~/.npm

recursively change user of the direct /home/test/ and all files into it to user test
sudo chown -R test /home/test

recursively change user of the direct public_html and all files into it to user owner
chown -R owner:owner public_html

recursively copy files by file extension, preserving directory structure
find -type f -name \*.txt -exec install -D {} /dest/path/{} \;

recursively convert all symlinks under the current working folder to its regular file
find . -type l | while read f; do /bin/cp -rf --remove-destination -f $(find . -name $(readlink "${f}")) "${f}";done;

recursively delete, without prompting, directories under /data/bin/test, that are older than 10 days and where the name starts with a number
find /data/bin/test -type d -mtime +10 -name "[0-9]*" -exec rm -rf {} \;

recursively delete, without prompting, directories under /data/bin/test, that are older than 10 days and where the name starts with a number
find /data/bin/test -type d -mtime +10 -name '[0-9]*' -print | xargs rm -rf ;

recursively finds all files newer than a date
find . -type f -newermt "$(date '+%Y-%m-%d %H:%M:%S' -d @1494500000)"

recursively look for files ending in either .py or .py.server
find . -type f -regex ".*\.\(py\|py\.server\)"

recursively look for files ending in either .py or .py.server
find . \( -name "*.py" -o -name "*.py.server" \)

Retrieve column number from column name "Target" in file "table"
head -1 table | tr -s ' ' '\n' | nl -nln |  grep "Target" | cut -f1

Retrieve only build number of current kernel, ie. #104
uname -v | grep -o '#[0-9]\+'

Returns 0 exit status despite of 'somecommand' execution result.
somecommand | true

Return 0 if at least one "abc" file in the current directory tree contains text "xyz"
find . -name 'abc' -type f -exec grep -q xyz {} +

Returns 0 if user $1 belongs to group $2.
groups $1 | grep -q "\b$2\b"

returns a list of  files create time is 1 minute ago under the root directory.
find / -newerct '1 minute ago' -print

returns a list of  files modification newer than poop
find . -mnewer poop

Return all of the .conf files in Pat's user folder and subdirectories
find /home/pat -iname "*.conf"

return every file that does not have bar somewhere in its full pathname
find . ! -path '*bar*' -print

Return the depth of the current directory tree
find . -type d -printf '%d:%p\n' | sort -n | tail -1

Return the files that are newer than file `myfile'
find / -newer myfile

returns the first 100 bytes in the file
head -c 100 file

Return the list of files named "filename" that are 50 megabytes or larger
find / -size +50M -iname "filename"

Returns the number of modified files in a git repository, whitespaces stripped.
MYVAR=`git ls-files -m|wc -l|tr -d ' '`

Returns the single most recent file in a directory
ls -ltq  <path>  | head -n 1

Returns the single most recent file in a directory
ls -t | head -n1

Returns the single most recent file in a directory and all subdirectories.
find $DIR -type f -exec stat --format '%Y :%y %n' "{}" \; | sort -nr | cut -d: -f2- | head -n 1

reverse a file with comma deliminators instead of newline deliminators
tac -s "," parse.txt > newparse.txt

Reversibly sorts content of the '${TMP}/${SCRIPT_NAME}.kb' file, comparing human readable numbers in file strings.
cat ${TMP}/${SCRIPT_NAME}.kb|sort -rh;

Reversibly sorts content of the '${TMP}/${SCRIPT_NAME}.name' file
cat ${TMP}/${SCRIPT_NAME}.name|sort -r;

Reversibly sorts content of the '${TMP}/${SCRIPT_NAME}.pid' file, comparing human readable numbers in file strings.
cat ${TMP}/${SCRIPT_NAME}.pid|sort -rh;

reverses order of lines in a.txt and saves them to b.txt
tac a.txt > b.txt

Reverse the space separated words in "35 53 102 342"
echo 35 53 102 342|tr ' ' '\n'|tac|tr '\n' ' '

Reverse the space separated words in "aaaa eeee bbbb ffff cccc"
echo "aaaa eeee bbbb ffff cccc"|tr ' ' '\n'|tac|tr '\n' ' '

Reverse the text in $input by taking each 4 characters as each units and save the result in variable 'output'
output=$(echo $input | fold -w4 | tac | tr -d \\n)

Reverse the order of lines in "myfile.txt" using BSD "tail" command
tail -r myfile.txt

Write "127.0.0.1 ad.doubleclick.net" to the console and append to "/etc/hosts" as root
echo 127.0.0.1 ad.doubleclick.net | sudo tee -a /etc/hosts

Write "2-1" to standard output and to "/sys/bus/usb/drivers/usb/unbind"
echo '2-1' |sudo tee /sys/bus/usb/drivers/usb/unbind

Write "2-1.1.1" to standard output and to file "/sys/bus/usb/drivers/usb/unbind"
echo '2-1.1.1'|sudo tee /sys/bus/usb/drivers/usb/unbind

Write "Hello, world" to standard output and to "/tmp/outfile"
echo "Hello, world" | tee /tmp/outfile

Write "Some console and log file message" to standard output and "/dev/fd/3"
echo "Some console and log file message" | tee /dev/fd/3

Write "\n/usr/local/boost_1_54_0/stage/lib" to standard output and append to "/etc/ld.so.conf"
echo -e "\n/usr/local/boost_1_54_0/stage/lib" | sudo tee -a /etc/ld.so.conf

Write "deb blah ... blah" to standard output and append to "/etc/apt/sources.list" as root
echo 'deb blah ... blah' | sudo tee --append /etc/apt/sources.list

Write "deb http://downloads-distro.mongodb.org/repo/ubuntu-upstart dist 10gen" to standard output and append to "/etc/apt/sources.list.d/10gen.list" as root
sudo echo "deb http://downloads-distro.mongodb.org/repo/ubuntu-upstart dist 10gen" | sudo tee -a /etc/apt/sources.list.d/10gen.list

Write "ee" to standard output and "/dev/stderr" as input to "foo"
echo 'ee' | tee /dev/stderr | foo

Write "ee" to standard output and as input to command "foo"
echo 'ee' | tee /dev/tty | foo

Write "ee" to standard output and as input to command "foo"
echo 'ee' | tee >(foo)

Write "ee" to standard output on "/dev/pty/2" and as input to command "foo"
echo ee | tee /dev/pty/2 | foo

Write "error" to both the log file "log" and standard error
echo "error" | tee -a log 1>&2

Write "error" to standard error and do not append to "log"
echo "error" 1>&2 | tee -a log

Write "error" to standard output
echo "error" | tee

Write "fifo forever" infinitely using the named pipe "fifo" by writing its contents to standard output and to "fifo"
echo "fifo forever" | cat - fifo | tee fifo

Write "foo" to the real path of the current command's standard input
echo foo | readlink /proc/self/fd/1

Write "foo" to the real path of the current command's standard output
echo foo | readlink /proc/self/fd/0

Write "hello world" to the console and print number of bytes, symbols and strings in provided input.
echo "hello world" | tee >(wc)

Write "hey hey, we're the monkees" to standard output and as input to "gzip --stdout > my_log.gz"
echo "hey hey, we're the monkees" | tee >(gzip --stdout > my_log.gz)

Write "hey hey, we're the monkees" to standard output and as input to to "gzip --stdout" saved to "my_log.gz"
echo "hey hey, we're the monkees" | tee /dev/tty | gzip --stdout > my_log.gz

Write "hey hey, we're the monkees" to standard output and as input to to "gzip --stdout" saved to "my_log.gz" without writing to disk
echo "hey hey, we're the monkees" | (exec 1>&3 && tee /proc/self/fd/3 | gzip --stdout > my_log.gz)

Write "some output" to standard output and to "/some/path/some_file" as user "some_user"
echo "some output" | sudo -u some_user tee /some/path/some_file

Write "suspend" to standard output and to file "/sys/bus/usb/devices/usb3/power/level"
echo suspend | sudo tee /sys/bus/usb/devices/usb3/power/level

Write '"myname="Test"' to the console and append to "$CONFIG" as root
echo "myname=\"Test\"" | sudo tee --append $CONFIG

Rewrite 'temp.txt' omitting any repeating lines
uniq temp.txt | perl -e 'undef $/; $_ = <>; open(OUT,">temp.txt"); print OUT;'

Write 10 lines of "y" to file "10lines.txt"
yes | head -n10 > 10lines.txt

Write a random list of numbers to /tmp/lst and stdout.
seq 1 10 | sort -R | tee /tmp/lst |cat <(cat /tmp/lst) <(echo '-------') **...**

Write contents of "/sys/kernel/debug/tracing/trace_pipe" to standard output and to "tracelog.txt" executing as a root user
sudo cat /sys/kernel/debug/tracing/trace_pipe | tee tracelog.txt

Write current directory listing to standard output and to "files.txt"
ls |& tee files.txt

Write differences between files "file1" and "file2" to "file3".
diff -u file1 file2 > file3

Write every two lines in "infile" on a single line separated by a comma
cat infile | paste -sd ',\n'

Write every two lines in "infile" on a single line separated by a space
cat infile | paste -sd '  \n'

Write out the entire directory hierarchy from the current directory
find .

Write out the entire directory hierarchy from the current directory
find . -print

Write list of missing files in Subversion repository to file removedProjs.
svn status | grep '\!' | cut -d' ' -f2- > removedProjs

Write lines 16224 through 16482 of "file.in" to "file.out"
head -16482 < file.in | tail -259 > file.out

Write output and error of "ant" to the console and to "build.log"
ant 2>&1|tee build.log

Write output and error of "bash myscript.sh" to standard output and to "output.log"
bash myscript.sh 2>&1 | tee output.log

Write output and error of "command" to standard output and to "/path/to/logfile"
command 2>&1 | tee /path/to/logfile

Write output and error of "update-client" to standard output and to "my.log"
update-client 2>&1 | tee my.log

Write output of "command" to standard output and append to "/path/to/logfile"
command | tee -a /path/to/logfile

Write output of "command_that_writes_to_stdout" to standard output and as input to "command_that_reads_from_stdin"
command_that_writes_to_stdout | tee >(command_that_reads_from_stdin)

Write output of "foo" to standard output and to "output.file"
foo | tee output.file

Write output of "ls -a" to standard output and to "output.file"
ls -a | tee output.file

Write output of "ls -hal /root/" to standard output and to "/root/test.out"
ls -hal /root/ | sudo tee /root/test.out

Write output of "ls -lR /" to standard output and to "output.file"
ls -lR / | tee output.file

Write output of "sudo ls -hal /root/" to "/root/test.out"
sudo ls -hal /root/ | sudo tee /root/test.out > /dev/null

Write output of "whatever" to standard output and to "logfile.txt"
whatever | tee logfile.txt

Write output of "yourcommand" to standard output and to "output.txt"
yourcommand | tee output.txt

Write standard input to standard output and file "/tmp/arjhaiX4"
tee /tmp/arjhaiX4

Write standard output of "command" to console and append to "stdout.log", and write standard error of "command" to console and append to "stderr.log"
command > >(tee -a stdout.log) 2> >(tee -a stderr.log >&2)

Write summary of files present only in dir1, and which files differ between dir1 and dir2 to file 'difference1.txt'
diff -r dir1 dir2 | grep dir1 | awk '{print $4}' > difference1.txt

Write the common third space separated fields in "file1.sorted" and "file2.sorted" to "common_values.field"
comm -12 <(cut -d " " -f 3 file1.sorted | uniq) <(cut -d " " -f 3 file2.sorted | uniq) > common_values.field

Write the current date and time followed by " 1" to the console and append to "log.csv"
echo $(date) "1" | tee -a log.csv

Write the last line of "$file" to standard output and remove it from "$file"
tail -n 1 "$file" | tee >(wc -c | xargs -I {} truncate "$file" -s -{})

Write the list of regular files in the current directory tree to files /tmp/grep1 and /tmp/grep2
find ./ -type f | tee /tmp/grep1 /tmp/grep2 >/dev/null

Write the lines appended to "xxxx" as it appears to the console and append to "yyyy" in the background
tail -F xxxx | tee -a yyyy &

Write the output of "input_prog" to standard output and error on console and as input to command "my_editor"
input_prog 2>&1 | tee /dev/tty | my_editor

Write the output of "proc1" to standard output and to all commands from "proc2" to "procN"
proc1 | tee >(proc2) ... >(procN-1) | procN

Write the output of "someCommand" to standard output and "someFile"
someCommand | tee someFile

Write the output of command "mongo" to the screen and to file "somefile"
mongo | tee somefile

Write the standard output and error of "ls" to standard output and "/tmp/ls.txt"
ls 2>&1 | tee /tmp/ls.txt

Write the standard output and error of "ls" to the console and append it to "/tmp/ls.txt"
ls 2>&1 | tee --append /tmp/ls.txt

Write the standard output and error of "ls" to the console and append it to "/tmp/ls.txt"
ls 2>&1 | tee -a /tmp/ls.txt

Write the standard output and error of "someCommand" to the console and "someFile"
someCommand 2>&1 | tee someFile

Write the standard output and error of "someCommand" to the console and append it to "someFile"
someCommand 2>&1 | tee -a someFile

Write unbuffered output of "python -u client.py" to standard output and to "logfile"
python -u client.py | tee logfile

Running /path/to/my/script outputs the name of a directory, go into that directory.
cd `/path/to/my/script`

Running javascript program "app" with node outputs the name of a directory, go into that directory.
cd "$(node app)"

same as above example with -exec , in this example with -OK it should ask for confirmation before executing the rm command . that is called user intractive command
find . -name core -ok rm {} \;

Save "1 4 6 9 11 17 22" as a bash array "arr"
read -a arr <<< "1 4 6 9 11 17 22"

Save "XXX-" followed by a random 4 byte unsigned integer to variable "tempfile"
tempfile=XXX-$(od -N4 -tu /dev/random | awk 'NR==1 {print $2} {}')

Save "something" into variable "param" in ksh
echo something | read param

Save $line line in history
history -s "$line"

Save 'echo whatever you "want your" command to be' in history
history -s 'echo whatever you "want your" command to be'

Save 'foo' into variable 'bar' in ksh
echo foo | read bar

Saves 'ls' output to 'ls_results' file and time report to 'time_results' file.
(time ls) > ls_results 2> time_results

Saves 'ls' output together with time report to a file 'time.txt'.
{ time ls; } 2>&1 |  cat > time.txt

Save a comma separated list of all $MY_DIRECTORY/*/ directories to variable 'FOLDER'
FOLDERS=`ls -dm $MY_DIRECTORY/*/ | tr -d ' '`

Save a comma separated list of all directories under current directory tree to variable 'FOLDER'
FOLDERS=$(find . -type d -print0 | tr '\0' ',')

Save a list of all 755 permission files/directories under $dir directory tree to the variable 'files'
files="$(find $dir -perm 755)"

Save a list of all the files/directories under current directory tree to a file named 'foo'
find . -fprint foo

Save a line of 100 random characters either "." or " " in variable "foo"
foo=$(cat /dev/urandom | tr -dc '. ' | fold -w 100 | head -1)

Save a nginx link to "/path/to/file" with the current user and system FQDN host name in variable "path"
path="http://$(whoami).$(hostname -f)/path/to/file"

Save a space separated list of process ids of currently running jobs to variable 'bgxjobs'
bgxjobs=" $(jobs -pr | tr '\n' ' ')"

Save a unique list of the currently logged in usernames to variable "line"
line=$(who | cut -d' ' -f1 | sort -u)

Save absolute path of "$path" that may not exist to variable "abspath"
abspath=$(readlink -m $path)

Save absolute path of "$path" that must exist along with all parents to variable "abspath"
abspath=$(readlink -e $path)

Save absolute path of "$path" whose parents exist to variable "abspath"
abspath=$(readlink -f $path)

Save absolute path of "/home/nohsib/dvc/../bop" in variable "absolute_path"
absolute_path=$(readlink -m /home/nohsib/dvc/../bop)

Save absolute path of java home to variable "JAVA_HOME"
export JAVA_HOME=$(readlink -f /usr/bin/java | sed "s:bin/java::")

Save absolute path of the script filename in variable "MY_PATH"
MY_PATH=$(readlink -f "$0")

Save absolute path of the script filename in variable "SCRIPT"
SCRIPT="$(readlink --canonicalize-existing "$0")"

Save absolute path of the script filename in variable "SCRIPT"
SCRIPT=$( readlink -m $( type -p $0 ))

Save actual working directory in variable "target_PWD"
target_PWD=$(readlink -f .)

save all aliases to the variable $oldalias
oldalias=$(alias my_command|sed "s/^[^']*'//; s/'$//");

Save all directories under the current directory as a comma separated list in variable "FOLDERS"
FOLDERS=$(find $PWD -type d | paste -d, -s)

Save all directories under the current directory as a comma separated list in variable "FOLDERS"
FOLDERS=$(find . -type d | paste -d, -s)

Save all entries that are wrapped around with opening and closing square brackets in file 'FILENAME' to variable 'var'
var=`egrep -o '\[.*\]' FILENAME | tr -d ][`

Save long listing of all files listed in file 'filenames.txt' to 'listing' variable
listing=$(ls -l $(cat filenames.txt))

Save long listing of all running processes in the 'log' file, and save number of process strings that contain 'cntps' in the 'cnt' variable.
cnt=`ps -ef| tee log | grep "cntps"|grep -v "grep" | wc -l`

Saves bytes count of the value of '$each' variable.
a=$(echo $each | wc -c)

Saves byte size of $myvar variable value in the 'var2' variable.
var2=$(echo $myvar | wc -c)

Saves calendar of $month, $year in the 'cal' variable.
cal=$(echo $(cal "$month" "$year"))

Saves command execution output to a file 'outfile' together with time report.
(time ls) > outfile 2>&1

Save count of lines from file $file matching with pattern $filter and not matching with pattern $nfilter in variable 'totalLineCnt'
totalLineCnt=$(cat "$file" | grep "$filter" | grep -v "$nfilter" | wc -l | grep -o '^[0-9]\+');

Save directory "../../lib" relative to the executable "gcc" to variable "libdir"
libdir=$(dirname $(dirname $(which gcc)))/lib

Save first one of space separated parts of each line in $LOCKFILE file to the 'CURRENT_PID_FROM_LOCKFILE' variable
CURRENT_PID_FROM_LOCKFILE=`cat $LOCKFILE | cut -f 1 -d " "`

Saves folder path where target of symbolic link $file file is located in 'base' variable.
base=$(dirname $(readlink $file))

Save full path of command "cat" to variable "CAT"
CAT=`which cat`

Save full path of command "mktemp" to variable "MKTEMP"
MKTEMP=`which mktemp`

Save full path of command "rm" to variable "RM"
RM=`which rm`

Save full path of command "tr" to variable "TR"
TR=`which tr`

Saves index number of file 'script.sh' in the 'inode' variable.
inode=`ls -i ./script.sh | cut -d" " -f1`

Saves invoked command 'check_script_call=$(history |tail -1|grep myscript.sh )' in variable 'check_script_call', preceeding by its number in history.
check_script_call=$(history |tail -1|grep myscript.sh )

Save IP addresses of the host name in variable "ip"
ip=$(hostname -I)

Save list of groups which user $line belongs to and not matching pattern "_unknown|sciences|everyone|netaccounts" in 'results' variable
results=$(groups "$line" | tr ' ' '\n' | egrep -v "_unknown|sciences|everyone|netaccounts")

Saves list of logged in users in system together with 'USER' header in the 'a' variable.
a=`w|cut -d' ' -f1`;

Saves list of logged in users in system together with 'USER' header in the 'b' variable.
b=`w|cut -d' ' -f1`;

Saves listing of a current folder in 'OUTPUT' variable.
OUTPUT="$(ls -1)"

Saves listing of a current folder in 'var' variable.
var=$(ls -l)

Saves location of file $1 in 'dir' variable.
dir=$(dirname -- "$1")

Saves location of file $1 in 'dir_context' variable.
dir_context=$(dirname -- "$1")

Save host name in variable "thisHOSTNAME"
thisHOSTNAME=`hostname`

Save Maven project version to variable "version"
version=$(mvn org.apache.maven.plugins:maven-help-plugin:2.1.1:evaluate -Dexpression=project.version | egrep -v '^\[|Downloading:' | tr -d ' \n' | sed -E 's/\[.*\]//g')

Save Maven project version to variable "version"
version=$(mvn org.apache.maven.plugins:maven-help-plugin:2.1.1:evaluate -Dexpression=project.version | egrep -v '^\[|Downloading:' | tr -d ' \n')

Saves number of lines of current directory listing in 'n_max' variable.
n_max=`ls . | wc -l`

Save number of lines with any-cased 'merge' from $COMMIT_EDITMSG file in 'MERGE' variable
MERGE=$(cat $COMMIT_EDITMSG|grep -i 'merge'|wc -l)

Save number of processors in system to 'NP' variable
NP=`cat /proc/cpuinfo | grep processor | wc -l`

Save only the digits in "$filename" to variable "number"
number=$(echo $filename | tr -cd '[[:digit:]]')

Saves real path of the folder containing the current script
DIR=$(dirname "$(readlink -f \"$0\")")

Saves space separated content of $RAW_LOG_DIR in FILES variable
FILES=`cat $RAW_LOG_DIR | xargs -r`

Save small letter short day name of the week to variable 'DayOfWeek'
DayOfWeek=`date +%a |tr A-Z a-z`

Save standard input to variable "myVar"
myVar=$(tee)

Save standard input to variable 'stdin' until the first character encoded as '\004' is read
read -d "$(echo -e '\004')" stdin

Saves state of shell option 'nullglob' in an 'old_nullglob' variable.
local old_nullglob=$(shopt -p nullglob)

Save system information appended with the current date in 'filename' variable
filename="$(uname -a)$(date)"

Save the 10 ping results to "$gateway" in variable "pingResults"
local pingResults=$(LANG=C ping -q -c10 "$gateway")

Save the absolute path of "$path" to variable "full_path"
full_path=`readlink -fn -- $path`

Save the absolute path of the current script to variable "SELF"
SELF=$(readlink /proc/$$/fd/255)

Save the absolute path of the current script to variable "SELF"
SELF=`readlink /proc/$$/fd/255`

Save the absolute path of the current script to variable "SELF"
actual_path=$(readlink -f "${BASH_SOURCE[0]}")

Save the absolute path of the current script to variable "SELF"
script="`readlink -f "${BASH_SOURCE[0]}"`"

Save the absolute path of the directory of the current script to variable "DIR"
DIR=$(dirname "$(readlink -f \"$0\")")

Save the canonical filename of "$BASH_SOURCE" in variable "me"
me=$(readlink --canonicalize --no-newline $BASH_SOURCE)

Save the canonical filename of the script in variable "me"
me=$(readlink --canonicalize --no-newline $0)

Save the canonical path of "$dir/$file" in variable "path"
path=`readlink --canonicalize "$dir/$file"`

Save the contents of "file" in the clipboard
cat file | xclip

Save the contents of "file" in the clipboard
cat file | xclip -selection clipboard

Save the contents of "~/.bashrc" to the clipboard on OSX
cat ~/.bashrc | pbcopy

Save the current user name and inode number of "/home" into bash array variable "var"
var=( $(whoami && stat -c %i "/home") )

Save the current user name in variable "myvariable"
myvariable=$(whoami)

Save the current working directory and the directory name of the current script to variable "DIR"
DIR=`pwd`/`dirname $0`

Save the current working directory to variable "CURRENT"
CURRENT=`pwd`

Save the current working directory with resolved symbolic links to variable "real1"
real1=$(pwd -P)

Save the current time formatted according to the format string "%Y-%m-%d %H:%M:%S" to the variable 'CDATE'
CDATE=$(date "+%Y-%m-%d %H:%M:%S")

Save the UTC date represented by time string $sting2 as the seconds since epoch to variable 'FinalDate'
FinalDate=$(date -u -d "$string2" +"%s")

Save the date 222 days before today to the variable 'date_222days_before_TodayDay'
date_222days_before_TodayDay=$(date --date="222 days ago" +"%d")

Save the directory name of the canonical path to the current script in variable "MY_DIR"
MY_DIR=$(dirname $(readlink -f $0))

Save the directory name of the current bash script to variable "path" if it is found in one of the directories specified by PATH.
path="$( dirname "$( which "$0" )" )"

Save the directory of the full path to the current script in variable "dir"
dir=$(dirname $(readlink -m $BASH_SOURCE))

Save the directory of the full path to the current script in variable "dir"
dir=$(dirname $(readlink /proc/$$/fd/255))

Save the filename and hash of the md5 sum of "file" to bash array "md5"
md5=($(md5sum file))

Save the FQDN host name of the system in variable "fhost"
fhost=`hostname -f`

Save the FQDN host name of the system in variable "hnd"
hnd=$(hostname -f)

Save the first "." separated field of the system host name to variable "HOSTZ"
HOSTZ=$( hostname | cut -d. -f1 )

Save the first line of "$j" into variable "k" in ksh
echo $j | read k

Save the first line of "foo.txt" to variable "bar"
bar=$(cat foo.txt | { read bat;echo $bat;})

Save the first three octets of the host name's IP address to variable "subnet"
subnet=$(hostname -i | cut -d. -f1,2,3)

Save the first two letters of the system host name to variable "DC"
DC=`hostname | cut -b1,2`

Save the first word of the first difference in ".dir_list_2" compared to ".dir_list_1" into variable "extract_dir"
extract_dir=$(diff .dir_list_1 .dir_list_2 | grep '>' | head -1 | cut -d' ' -f2)

Save the full path of command "f" to variable "full_f"
full_f="$(which f)"

Save the full path of command "~/f" to variable "foo"
foo=`which ~/f`

Save the full path of the current script into variable "THIS"
THIS=`readlink -f "${BASH_SOURCE[0]}" 2>/dev/null||echo $0`

Save the greater version number of "$1" and "$2" into variable "ver"
ver=`echo -ne "$1\n$2" |sort -Vr |head -n1`

Save the latest modification time (in format "%T@ %t" of any file under "./$dir" to variable "timestamp"
timestamp=$(find ./$dir -type f -printf "%T@ %t\\n" | sort -nr -k 1,2 | head -n 1)

Save the last modified time of file 'file_name' to variable 'STAMP'
STAMP=`date -r file_name`

Save the list of *.au files in the current directory tree to file `names.txt'
find -type f -name '*.au' > names.txt

Save the list of .log files in the current directory tree to sas_log_list.txt
find `pwd` -name "*.log" > sas_log_list.txt

Save the list of all .py files under and below the current directory to output.txt
find . -name "*.py" -type f > output.txt

Save the list of all regular files accessed less than 10 days ago as `March.files'
find / -type f -atime -10 > March.files

Save the list of all subdirectories of the current directory as "dirs_to_remove"
find . -maxdepth 1 -type d > dirs_to_remove

save the list of all the core files in the entire file system which belong to the group mycomp to the file "mycompcore" and delete them
find / -name core -group mycomp -print -exec rm -f {} \; >> mycompcore

Save the list of files containing string `ExtJSLogin' to files.txt excluding change-app-name.sh
find . -type f -exec grep -l 'ExtJSLogin' {} \; | grep -v 'change-app-name.sh' > files.txt

Save the list of files in the current directory hierarchy separting file names with zeroes
find . -print0 > mypipe

Save the list of files in the current directory tree whose names contain "2011" to /tmp/allfiles
find . -name '*2011*' -print0 > /tmp/allfiles

Save the list of files in the home directory tree whose names begin with "Foto" to `results.txt'
find ~ -name 'Foto*' > results.txt

Save the list of files modified within a fortnight ago to `deploy.txt'
find . -type f -mtime -14 > deploy.txt

Save the list of files modified within a fortnight ago to `deploy.txt' removing the leading ./ from the file names
find . -type f -mtime -14 | sed 's|./||' >deploy.txt

Save the list of files modified within a fortnight ago to `deploy.txt' stripping the file names of any leading directories
find . -type f -mtime -14 -printf '%f\n' > deploy.txt

Save the logical current working directory to variable "basedir"
basedir=$(pwd -L)

Save the md5 sum hash of "$my_iso_file" to variable "md5"
md5=$(md5sum "$my_iso_file" | cut -d ' ' -f 1)

Save the name and first line of each .txt file found in the home directory tree to `report.txt'
find $HOME/. -name *.txt -exec head -n 1 -v {} \; > report.txt

Save the network node hostname append with '-', the current date and '.txt' into variable 'filename'
filename="$(uname -n)-$(date +%F).txt"

Save the number of bytes in "$file" after decompression into variable "size"
size="$(zcat "$file" | wc -c)"

Save the number of matching executables for "$cmd" in $PATH to variable "candidates"
candidates=$(which -a $cmd | wc -l)

Save the number of modified files in a git repository in variable "MYVAR"
MYVAR=`git ls-files -m|wc -l|tr -d ' '`

Save the numerically greater value of "$kf" and "$mp" into variable "gv"
gv=$(echo -e $kf'\n'$mp | sort -t'.' -g | tail -n 1)

Save the percentage of packets lost of the 5 packets sent to "$host" in variable "packet_loss"
packet_loss=$(ping -c 5 -q $host | grep -oP '\d+(?=% packet loss)')

Save the physical current working directory to variable "END_ABS"
END_ABS=`pwd -P`

Save the short host name appended with ".mysqldb" in variable "DBPREFIX"
DBPREFIX="$(hostname -s).mysqldb"

Save the short DNS lookup output of $WORKSTATION to 'WORKSTATION_IP' variable
WORKSTATION_IP=`dig +short $WORKSTATION`

Save the short system host name to variable "hostname"
hostname=`hostname -s`

Save the system load average for the past 1 minute of the currently logged in user to variable 'proc_load_average'
proc_load_average=$(w | head -1 | cut -d" " -f12 | cut -d"," -f1-2 | tr ',' '.')

Save the system host name in variable "HOSTNAME"
HOSTNAME="`hostname`"

Save the system host name in variable "HOSTNAME"
HOSTNAME=$(hostname)

Save the system host name into variable "HOST"
HOST=$(hostname)

Save the user name in all capitals of the current user to variable "v"
v=$(whoami | perl -e 'print uc <>')

Save the user name in upper case of the current user in variable "v"
v=$(whoami | tr 'a-z' 'A-Z')

Save the user name in upper case of the current user in variable "v"
v=$(whoami | tr [:lower:] [:upper:])

Save the user name of the current user to variable "me"
me="$(whoami)"

Save the user name of the current user to variable "me"
me=$(whoami)

Save the user name of the current user to variable "whoami"
whoami=$(whoami)

Save the user name of the current user to variable "x"
x=$(whoami)

Save to report.txt the first line of every text file in the home directory
find $HOME/. -name *.txt -exec head -n 1 -v {} \; > report.txt

Save yesterday's date into variable "dt" using perl
perl -e '@T=localtime(time-86400);printf("%02d/%02d/%04d",$T[3],$T[4]+1,$T[5]+1900)' | read dt

Strips two last sections from the path $pathname, and prints basename of the rest part.
echo $(basename $(dirname $(dirname $pathname)))

Searches available packages by word 'zsh'.
yum search zsh

Searches available packages with 'mysql' and 'client' in name.
yum search mysql | grep client

Searches for 'something' in a large file and prints the matching line
grep -n 'something' HUGEFILE | head -n 1

searching for all files with the extension mp3
find / -name *.mp3

Searches manual pages which descriptions contain 'postscript', and prints name and description of only ones that contain any-cased 'png' pattern.
apropos postscript | grep -i png

Searche JSP's for "TODO" lines and append them all to a file with a header showing what file they came from
for f in `find -name \*.jsp` ; do echo "==> $f" >> out.txt ; grep "TODO" $f >> out.txt ; done

Searches the manual page names and descriptions by 'disk' keyword.
apropos disk

Searches the manual pages with descriptions in section 3, that name begins with lowercase letter.
apropos -s 3 . | grep ^[a-z]

searches through the /usr/local directory for files that end with the extension .html
find /usr/local -name "*.html" -type f

Searches through the htdocs and cgi-bin directories for files that end with the extension .cgi. When these files are found, their permission is changed to mode 755 (rwxr-xr-x).
find htdocs cgi-bin -name "*.cgi" -type f -exec chmod 755 {} \;

searches through the root filesystem ("/") for the file named Chapter1.
find / -name Chapter1 -type f

searches through the root filesystem ("/") for the file named Chapter1.
find / -name Chapter1 -type f -print

searches through the root filesystem ("/") for the file named Chapter1, and prints the location
find / -name Chapter1 -type f

searches through the root filesystem ("/") for the file named Chapter1, and prints the location
find / -name Chapter1 -type f -print

Selects a job from list and get it back to the foreground (iselect package is required).
fg `jobs | iselect -a | grep -o [0-9]*`

Selects a job from zenity dialog list and gets it back to the foreground.
fg `jobs | tr '[]' ' \n' | zenity  --list --column '' --column ''`

Select everything selected by * without descending into any directories
find * -maxdepth 0

Sets 'extglob' shell option.
shopt -s extglob

Sets 'extglob' shell variable.
shopt -s extglob

Setup a local SSH tunnel from port 1234 to "remote2" port 22 via connection to "remote1" as "user1" on port 45678
ssh -L 1234:remote2:22 -p 45678 user1@remote1

Sets shell option 'dotglob'.
shopt -s dotglob

Sets shell option 'extglob'.
shopt -s extglob

Sets shell options 'globstar', 'dotglob' and 'nullglob'.
shopt -s globstar nullglob dotglob

Sets shell options 'globstar' and 'nullglob'.
shopt -s globstar nullglob

Sets shell option 'nounset'.
shopt -s -o nounset

Sets shell option 'nullglob'.
shopt -s nullglob

Sets the shell prompt to "[USER@HOST]" where USER is the current user and HOST is the short host name
set prompt=\[`id -nu`@`hostname -s`\]\#\

Shifts all positional arguments but last one, keeping it in $1 variable.
shift $(($#-1))

Shifts all positional arguments but last one, keeping it in $1 variable.
shift `expr $# - 1`

Shifts the positional parameters to the left by 1.
shift

Shifts the positional parameters to the left by n.
shift [n]

Show a long listing of the latest file or directory under current directory
ls -lrt | tail -n1

show a count of the number of filenames ending in .txt in the current directory, without descending into sub-directories
find . -maxdepth 1 -name \*.txt -print0 | grep -cz .

show all directories in the current folder excluding those that are present in the sub directories of media, images and backups
find . -type d \( -name media -o -name images -o -name backups \) -prune -o -print

show all directories in the current folder excluding those that are present only in the paths ./media, ./images and ./backups
find . -path './media' -prune -o -path './images' -prune -o -path './backups' -prune -o -print

Show all files in /etc that are owned by root have been modified within the last minute
find /etc/ -user root -mtime 1

Show all files in user's home directory that have read, write and execute permissions set for user, group and others.
find ~ -perm 777

Show all files that have not been accessed in the $HOME directory for 30 days or more
find $HOME -atime +30

show all files in the current directory and all subdirectories
find .

show all files in the current directory and all subdirectories
find . -print

show all files in the entire file system
find / -print0 | perl -ln0e 'print "found $_" if -p'

Show all processes that have a tty in format "%p %r %y %x %c "
ps x -o  "%p %r %y %x %c "

show all regular/normal the files in the current folder whose size is bigger than 0 bytes excluding everything
find * -prune -type f -size +0c -print

Show all running processes with a name matching "postgres"
ps -ef | grep postgres

Show all running processes with name matching "postgres"
ps aux | grep postgres

show all the ".acc" files in the folder /home
find /home -type f -name '*.aac'

show all the ".flac" files in the current folder and do not search in the sub directories
find . -maxdepth 1 -type f -name '*.flac'

show all the files in the current folder excluding those from the directories whose name starts with "git"
find . -type d -name '.git*' -prune -o -type f -print

show all the files in the current folder which has the word "ITM"
find . -name ‘*ITM*’

show all the files in the entire file system which are bigger than 1.1GB
find / -size +1.1G

show all the files in the entire file system which are bigger than 100MB
find / -size +100M

show all the files in the folder /etc which have been modified in the last 24 hours
find /etc -mtime -1

show all the mp3 files in the folder /home
find /home -type f -name '*.mp3'

show all the regular/normal files in the folder /home/user/demo
find /home/user/demo -type f -print

Show all values (without the names) of variables whose name or value contains "VARIABLE_NAME"
myVariable=$(env  | grep VARIABLE_NAME | grep -oe '[^=]*$');

Show all variables whose name or value contains "PATH", sorted in reverse alphabetical order.
env | uniq | sort -r | grep PATH

Show long listing of current directory by deleting all digits from the output
ls -lt | tr -d 0-9

Shows MAC address of network interface eth0.
ifconfig eth0 | grep HWaddr |cut -dH -f2|cut -d\  -f2

Shows strings that NOT match regex '^($|\s*#|\s*[[:alnum:]_]+=)'
echo "${line}" | egrep --invert-match '^($|\s*#|\s*[[:alnum:]_]+=)'

Show IPC information owned by the current user
ipcs -a | grep `whoami`

Show current date in "%Y-%m-%d" format
date "+%Y-%m-%d"

Show directory sizes in KB and sort to give the largest at the end
du -sk $(find . -type d) | sort -n -k 1

Show directory sizes in KB and sort to give the largest at the end
find . -type d -exec du -sk {} \; |  sort -n -k 1

Show files in /home owned by group `test'
find /home -group test

Show filename and filetype description of all PHP files in all directories contained in current directory whose name or filetype description includes "UTF"
file */*.php | grep UTF

Show filename and filetype description of all PHP files in current directory whose name or filetype description includes "UTF"
file *.php | grep UTF

Show find's version
find --version

Show file type information for all regular files under '/home' directory tree
find /home -type f -exec file {} \;

Show file type information for files in /usr/bin
find /usr/bin | xargs file

Show human-readable file type description of file "/mnt/c/BOOT.INI"
file /mnt/c/BOOT.INI

Show who is logged on
who

Show logged in users with idle time of each one
w | tr -s " " | cut -d" " -f1,5 | tail -n+3

Show manual for the find command
man find

Show manual of the find command
man find

Show manual of the find utility
man find

Show manual page for the find utility
man find

Show manual page of find
man find

Show mv commands to move all *.pdf.marker files and their corresponding *.pdf files under ${INPUT_LOCATION} to ${OUTPUT_LOCATION}
find ${INPUT_LOCATION} -name '*.pdf.marker' -exec sh -c 'echo mv $0 `dirname $0`/`basename $0 .marker` $1' {} ${OUTPUT_LOCATION} \;

(Mac OSX specific) Show the internal memory size used by process whose PID is specified by variable PID.
top -l 1 -s 0 -stats mem -pid $PID

Shows only IP4, not IP6 address of network interface eth0.
/usr/bin/ifconfig eth0 | grep --word-regexp inet | awk '{print $2}'

(Mac OSX specific) Show the private address space used by process whose PID is specified by variable PID.
top -l 1 -s 0 -i 1 -stats vprvt -pid $PID

Shows only process trees rooted at processes of this user.
pstree user

Show process tree with command-line arguments of a process that has id 20238.
pstree -a -p 20238

show processes for all users, their user/owner, and those not attached to a terminal
ps aux

Shows size of compressed file in .bz2 archive.
bunzip2 -c bigFile.bz2 | wc -c

Shows status of a shell option 'compat31'.
shopt compat31

Shows status of a shell option 'dotglob'.
shopt dotglob

Shows status of a shell option 'nullglob'.
shopt nullglob

Shows state of shell option 'extglob'.
shopt extglob

Show system information: kernel name, hostname, kernel release and version, machine architecture, processor type, hardware platform, and operating system type.
uname -a

Show what content owned by root has been modified within the last day
find /etc/ -user root -mtime 1

Show the current UTC date in '%Y-%m-%dT%k:%M:%S%z' format
date -u '+%Y-%m-%dT%k:%M:%S%z'

Show the date in default format for tomorrow + 2 days + 10 minutes
date -d tomorrow+2days-10minutes

show the disk use of all the regular/normal files in the current folder which are bigger than 50MB
find . -type f -size +50000k | xargs du -sh

show the disk use of all the regular/normal files in the file system which are bigger than 100MB
find / -type f -size +100M | xargs du -sh

Show the epoch in default date/time format
date -ud@0

Show the explanation of find's debugging options
find -D help

Show the files or directories in the current directory whose names are not "MyCProgram.c"
find -maxdepth 1 -not -iname "MyCProgram.c"

Show the last 10 .conf files found by `find' in the /etc directory
find /etc -maxdepth 1 -name "*.conf" | tail

Show the last 10 .conf files found by `find' in the /etc directory and 1 level below
find /etc -maxdepth 2 -name "*.conf" | tail

Show the list of all files on the system whose names do not end in ".c"
find / \! -name "*.c" -print

show the list of all the files in the current folder which have been modified within the 24 hours
find . -mtime 0 -print

Show the list of directories in the /mnt/raid directory tree
find /mnt/raid -type d -print

Show the list of files larger than 100 MB
find / -size +100M -print

Show the list of files modified more than 31 days ago
find / -mtime +31 -print

Show the list of files that are owned by user wnj or are newer than file `ttt'
find / \( -newer ttt -or -user wnj \) -print

Show the list of files that are not owned by user wnj or are not newer than file `ttt'
find / \! \( -newer ttt -user wnj \) -print

Show the list of user wnj's files that are newer than file `ttt'
find / -newer ttt -user wnj -print

Show the number of lines for each .php and .phtml file in the current directory tree
find . -type f \( -name "*.php" -o -name "*.phtml" \) -exec wc -l {} +;

Show the number of regular files in the current directory tree
find . -type f | wc -l

Show the subdirectories of the current directory
find . -maxdepth 1 -type d -print | parallel -X echo Directories:

Show the subdirectories of the current directory
find . -maxdepth 1 -type d -print | parallel echo Directory: {}

Show the subdirectories of the current directory
find . -maxdepth 1 -type d -print | xargs -I {} echo Directory: {}

Show the subdirectories of the current directory
find . -maxdepth 1 -type d -print | xargs echo Directories:

Show the value of variable "list", discarding consecutive duplicates and adding number of occurrences at the beginning of each line.
echo "$list" | uniq -c

Show total memory used by processes in MB
ps -eo size,pid,user,command --sort -size | awk '{ hr=$1/1024 ; printf("%13.2f Mb ",hr) } { for ( x=4 ; x<=NF ; x++ ) { printf("%s ",$x) } print "" }' | awk '{total=total + $1} END {print total}'

Show version information of the find utility
find -version

Silently and recursively change the ownership of all files in the current directory to "www-data"
sudo chown -Rf www-data *

Silently download contents from https://raw.github.com/Homebrew/homebrew/go/install and show an error if failed, execute with ruby after the download is completed
ruby -e "$(curl -fsSL https://raw.github.com/Homebrew/homebrew/go/install)"

Silently read a line into variable "passwd" with prompt "Enter your password: "
read -s -p "Enter your password: " passwd

Silently read a single character from standard input into variable "key" without backslash escapes and using the prompt $'Press any key to continue...\n'
read -rsp $'Press any key to continue...\n' -n 1 key

Silently read a single character into variable "REPLY"
read -n1 -s

Silently read exactly 1 character ignoring any delimiters  into variable "SELECT"
read -s -N 1 SELECT

Silently read standard input until the escape key is pressed ignoring backslash escapes and using the prompt $'Press escape to continue...\n'
read -rsp $'Press escape to continue...\n' -d $'\e'

simulate a full login of user builder
su -l builder

simulate a full login of user root
su -

File "files.txt" contains a list of files, copy all files listed to host "remote", connecting as ssh user "user", and copying the files to this user's home directory - this will not work with files/directory names containing spaces.
cat files.txt | xargs scp user@remote:

File 'save_pid.txt' contains a process ID, instantly kill this process with SIGKILL signal.
kill -9 `cat save_pid.txt`

Pipe 3 newlines to sshe-keygen, answering prompts automatically.
echo -e "\n\n\n" | ssh-keygen -t rsa

Give a long listing of all the  *.pl files (Perl files) beneath the current directory.
find . -name "*.pl" -exec ls -ld {} \;

Give all directories in the /path/to/base/dir tree read and execute privileges
find /path/to/base/dir -type d -exec chmod 755 {} +

Give all directories in the /path/to/base/dir tree read and execute privileges
find /path/to/base/dir -type d -print0 | xargs -0 chmod 755

Give all files in the /path/to/base/dir tree read privileges
find /path/to/base/dir -type f -exec chmod 644 {} +

Give all files in the /path/to/base/dir tree read privileges
find /path/to/base/dir -type f -print0 | xargs -0 chmod 644

resize all the jpg images in the current folder to the size 300x300
find . -iname '*.jpg' -print0 | xargs -I{} -0 -r convert -resize 300x300 {} $outdir/{}

Pipe an empty line to ssh-keygen.
printf "" | ssh-keygen -b 1024 -f ball -t dsa

Give rwx permissions to the user and group of the directory named "files" leaving others without any privileges
find . -type d -name files -exec chmod ug=rwx,o= '{}' \;

Give the location of every hard link to file1 in the /home directory tree
find /home -xdev -samefile file1 | xargs ls -l

Pipe the output of "program1" to both "program2" and "program3"
program1 | tee >(program2) >(program3)

Pipe the output of ls into "read var" in its separate process
ls | read var

sleep for 1 second
sleep 1

sleep for 10 seconds
sleep 10

sleep for 10 seconds
sleep `10`

sleep for 5 seconds
sleep 5

sleep for 500 seconds
sleep 500

Sleep until tomorrow at 21:30
sleep $(($(date -f - +%s- <<< $'tomorrow 21:30\nnow')0))

Sources a script ./etc/grc.bashrc that is located in a Homebrew folder.
source "`brew --prefix`/etc/grc.bashrc"

Spawn a background screen session running myCommand
screen -d -m sh -c "while :; do ./myCommand; done;"

Scan every file in /etc for IPV4 addresses.
find /etc -exec grep '[0-9][0-9]*[.][0-9][0-9]*[.][0-9][0-9]*[.][0-9][0-9]*' {} \;

Scan every file in /etc for IPV4 addresses while trying to elminate false positives.
find /etc -type f -exec cat '{}' \; | tr -c '.[:digit:]' '\n' | grep '^[^.][^.]*\.[^.][^.]*\.[^.][^.]*\.[^.][^.]*$'

Split "$1" into files of at most "$2" or default 10000 using a numeric suffix of length 6 and suffix "${tdir}/x"
split -l ${2:-10000} -d -a 6 "$1" "${tdir}/x"

Split "$FILENAME" into files with at most 20 lines each with a prefix "xyz"
split -l 20 $FILENAME xyz

Split "$INFILE" into files of at most "$SPLITLIMT" with a numeric suffix and a prefix "x_"
split -d -l $SPLITLIMT $INFILE x_

Split "$ORIGINAL_FILE" into files of at most "$MAX_LINES_PER_CHUNK" lines each with a prefix "$CHUNK_FILE_PREFIX"
split -l $MAX_LINES_PER_CHUNK $ORIGINAL_FILE $CHUNK_FILE_PREFIX

Split "$SOURCE_FILE" into files of at most 100 lines each
split -l 100 "$SOURCE_FILE"

Split "$file" into files with at most 1000 lines each and use a prefix length of 5
split -a 5 $file

Split "${fspec}" into 6 files with about equal number of lines each and use prefix "xyzzy."
split --number=l/6 ${fspec} xyzzy.

Split "/etc/gconf/schemas/gnome-terminal.schemas" into 1000000 files of about equal size
split -n 1000000 /etc/gconf/schemas/gnome-terminal.schemas

Split "/path/to/large/file" into files with at most 50000 lines and use prefix "/path/to/output/file/prefix"
split --lines=50000 /path/to/large/file /path/to/output/file/prefix

Split "/tmp/files" into files of at most 1000 lines each
split /tmp/files

Split "/usr/bin/cat" into 10000 files of about equal size
split -n 10000 /usr/bin/cat

Split "/usr/bin/firefox" into 1000 files of about equal size
split -n 1000 /usr/bin/firefox

Split "/usr/bin/gcc" into 100000 files of about equal size
split -n 100000 /usr/bin/gcc

Split "<file_name>" into files of at most 1024 KiB in size
split -b 1024k <file_name>

Split "<file_name>" into files of at most 1024 MiB in size
split -b 1024m <file_name>

Split "ADDRESSS_FILE" into files containing at most 20 lines and prefix "temp_file_"
split -l20 ADDRESSS_FILE temp_file_

Split "INPUT_FILE_NAME" into files of at most 500 MiB each with a numeric suffix of length 4 and prefix "input.part."
split -b 500M -d -a 4 INPUT_FILE_NAME input.part.

Split "abc.txt" into files with at most 1500000000 bytes each and use prefix "abc"
split --bytes=1500000000 abc.txt abc

Split "bigfile" into files of at most 1000 lines each with prefix "/lots/of/little/files/here"
split bigfile /lots/of/little/files/here

Split "biglogfile.gz" into chunks of 500000 line gzipped compressed files
zcat biglogfile.gz | split -l500000 --filter='gzip > $FILE.gz'

Split "complete.out" into files with at most "$lines_per_file" lines each
split --lines $lines_per_file complete.out

Split "data.csv" into files with at most 100 lines each and using a prefix "data_" and numeric suffixes starting with 1 and ending with ".csv"
split --numeric-suffixes=1 --additional-suffix=.csv -l100 data.csv data_

Split "data.tsv" into files of at most 100 MiB preserving lines and use a prefix of "data.tsv." and numeric suffixes
split -C 100m -d data.tsv data.tsv.

Split "data.tsv" into files of at most 5000000 lines each with prefix "_tmp"
split -l5000000 data.tsv '_tmp';

Split "database.sql" into files of at most 100000 lines each with prefix "database-"
split -l 100000 database.sql database-

Split "date.csv" into files with at most 100 lines each
split -l 100 date.csv

Split "domains.xml" into files of at most 50000 lines each with a numeric suffix of length 4 and prefix of "domains_"
split -a 4 -d -l 50000 domains.xml domains_

Split "file" into 10 files of about equal size without splitting lines
split -n l/10 file

Split "file.tar.gz" into files of size 1024 MB
split -b 1024m file.tar.gz

Split "file.tar.gz" into files of size 1024 MB with a prefix of "file.tar.gz.part-"
split -b 1024m "file.tar.gz" "file.tar.gz.part-"

Split "file.txt" excluding the first line into files of at most 4 lines each and with a prefix "split_"
tail -n +2 file.txt | split -l 4 - split_

Split "file.txt" excluding the first line into files with at most 20 lines each and a prefix "split_"
tail -n +2 file.txt | split -l 20 - split_

Split "file.txt" into files of at most 1 MiB in size with a numeric suffix and prefix "file"
split -b 1M -d  file.txt file

Split "file.txt" into files of at most 1 MiB in size with a numeric suffix, prefix "file", and additional suffix ".txt"
split -b 1M -d  file.txt file --additional-suffix=.txt

Split "file.txt" into files of at most 20 lines each with a prefix "new"
split -l 20 file.txt new

Split "filename" into files of at most 200000 lines each
split -l 200000 filename

Split "foo.txt" into files with 1 line each and use a suffix length of 5
split --suffix-length=5 --lines=1 foo.txt

Split "hugefile.txt" into files with 100000 lines each starting with "part." and using numeric suffixes
split -a4 -d -l100000 hugefile.txt part.

Split "infile" into 2 files of about equal size
split -n2 infile

Split "input.txt" into files of at most 10 bytes each with prefix "xxx/split-file"
split -b 10 input.txt xxx/split-file

Split "input.txt" into files with 1 line each and use a prefix "output." and a suffix length of 5
split --lines=1 --suffix-length=5 input.txt output.

Split "input_file" into files of at most 100 lines each with prefix "output_file"
split -l 100 input_file output_file

Split "list.txt" into files with at most 600 lines each
split -l 600 list.txt

Split "mybigfile.txt" into files of at most 200000 lines each
split -l 200000 mybigfile.txt

Split "randn20M.csv" into files of at most 5000000 lines each with prefix "_tmp"
split -l5000000 randn20M.csv '_tmp';

Split "system.log" into files of at most 10 MiB in size with a numeric suffix and prefix "system_split.log"
split -b 10M -d  system.log system_split.log

Split "t.txt" into files with at most 30000000 lines each and use a prefix "t" and numeric suffixes of length 2
split --lines=30000000 --numeric-suffixes --suffix-length=2 t.txt t

split $SOURCE_FILE" into pieces per 100 lines
split -l 100 "$SOURCE_FILE"

split a file "list.txt" into pieces per 600 lines
split -l 600 list.txt

Split a file "file.tar.gz" into pieces with size 1024 MB
split -b 1024m file.tar.gz

Split all files in the directory tree "/dev/shm/split/" into files of at most 1000 lines each and use the filename as the prefix
find /dev/shm/split/ -type f -exec split -l 1000 {} {} \;

split all files in directory "/dev/shm/split/" into pieces per 1000 lines
find /dev/shm/split/ -type f -exec split -l 1000 {} {} \;

split all files in directory "posns " into pieces per 10000 lines
find posns -type f -exec split -l 10000 {} \;

split compressed content of the directory /home into pieces per 4000 mb named as  "/media/DRIVENAME/BACKUPNAME.tgz.NNN"
tar --one-file-system -czv /home | split -b 4000m - /media/DRIVENAME/BACKUPNAME.tgz

split compressed content of the file www into pieces per 1073741824 bytes named as "backup.tar.NNN"
tar czf - www|split -b 1073741824 - www-backup.tar.

split content all files file1..40000 into pieces per 1445 lines named as outputprefixNNN as digital prefix
cat file1 file2 ... file40000 | split -n r/1445 -d - outputprefix

split content of the files *.txt beginning with 1001st line into pieces per 1000 lines
cat *.txt | tail -n +1001 | split --lines=1000

split content of the file file.txt started from second line into pieces per 4 lines named as split_NNN
tail -n +2 file.txt | split -l 4 - split_

split content of the file inputfile except lines started with "^t:" into pieces per 200 lines
cat inputfile | grep "^t\:" | split -l 200

split file "${fspec} into pieces named as "xyzzyNNN" with numeric prefix from 1 to 6
split --number=l/6 ${fspec} xyzzy.

split file "$file into pieces named with 5 character suffix
split -a 5 $file

split file /etc/gconf/schemas/gnome-terminal.schemas into pieces per 1000000 lines
split -n 1000000 /etc/gconf/schemas/gnome-terminal.schemas

split file /usr/bin/firefox into pieces per 1000 lines
split -n 1000 /usr/bin/firefox

split file /usr/bin/gcc into pieces per 100000 lines
split -n 100000 /usr/bin/gcc

split file abc.txt into pieces per 1500000000 bytes named as "abc.NNN"
split --bytes=1500000000 abc.txt abc

split file data.csv into pieces per 100 lines
split -l 100 date.csv

split file data.csv into pieces per 100 lines named with additional suffix ".csv"
split --numeric-suffixes=1 --additional-suffix=.csv -l100 data.csv data_

split file input.txt into pieces per 1 line named output.NNNNN
split --lines=1 --suffix-length=5 input.txt output.

split file t.txt into pieces per 30000000 lines named as "t.NN" with numeric suffix
split --lines=30000000 --numeric-suffixes --suffix-length=2 t.txt t

Split file 'afile' into parts as of two lines per each and compress each part with 'bzip2'
cat afile | split -l 2 --filter='bzip2 > "$FILE.bz2"'

split listing of the current directory into pieces per 500 lines named "outputXYZNNN"
ls | split -l 500 - outputXYZ.

split result of the command "tar [your params]" into pieces per 500 mb named as "output_prefixNNN"
tar [your params] |split -b 500m - output_prefix

Split standard input into files of at most 1000 lines each
split

Split standard input into files of at most 3400000 lines each
split -l 3400000

Split standard input into files with at most 75 lines each
split --lines=75

Split the contents of "file1 file2 ... file40000" into 1445 files in a round robin fashion with prefix "outputprefix" and numeric suffixes
cat file1 file2 ... file40000 | split -n r/1445 -d - outputprefix

split the file "/path/to/large/file" into pieces per 50000 lines named as /path/to/output/file/prefixNNN
split --lines=50000 /path/to/large/file /path/to/output/file/prefix

split the file "file" into pieces per 2 lines
split -n2 infile

split the file 2011.psv into pieces per 50000000 lines processed with script "filter.sh"
split -l 50000000 --filter=./filter.sh 2011.psv

split the file data.csv into pieces per 100 mb named as data.tsv.NNN with digital prefixes
split -C 100m -d data.tsv data.tsv.

split the file hugefile.txt into pieces per 100000 lines named as partNNN with digital prefixes
split -a4 -d -l100000 hugefile.txt part.

Split the output of "ls" into files of at most 500 lines each with prefix "outputXYZ."
ls | split -l 500 - outputXYZ.

Split the output of "my_program" into files of at most 100000 bytes each and use numeric suffixes
my_program | split -d -b 100000 -

Split the output of "tar [your params]" into files of at most 500 MiB in size and use prefix "output_prefix"
tar [your params] |split -b 500m - output_prefix

split the result of command "ping -c 25 google.com | tee " into pieces per 100000 bytes named as "/home/user/myLogFile.logNNN"
ping -c 25 google.com | tee >(split -d -b 100000 - /home/user/myLogFile.log)

Split the sorted and unique lines in files "emails_*.txt" into files with at most 200 lines each with numeric suffixes of length 4
sort --unique emails_*.txt | split --numeric-suffixes --lines=200 --suffix-length=4 --verbose

split uncompressed content of the file biglogfile.gz into pieces per 500000 lines
zcat biglogfile.gz | split -l500000 --filter='gzip > $FILE.gz'

SSH in server 'server' as user 'user' with X11 forwarding disabled
ssh -x user@server

SSH into "111.222.333.444" as user "tunneluser" without a pseudo-terminal and without interpreting bash variables locally
ssh -T tunneluser@111.222.333.444 <<'EOI'

SSH into "111.222.333.444" as user "tunneluser" without interpreting bash variables locally
ssh tunneluser@111.222.333.444 <<\EOI

SSH into "hostname" on port 22 as user "myName"
ssh -l myName -p 22 hostname

SSH into "hostname" on port 22 as user "myName"
ssh -p 22 myName@hostname

SSH into "localhost" with forced pseudo-terminal allocation, execute "$heredoc", and save the output to variable "REL_DIR"
REL_DIR="$(ssh -t localhost "$heredoc")"

SSH into "myhost.com" as user "myname" with a check every 60 seconds that the server is still alive
ssh -o ServerAliveInterval=60 myname@myhost.com

SSH into "server" as user "user" and interpret commands in "/bin/bash" until "EOT" is received
ssh user@server /bin/bash <<'EOT'

ssh into "ssh.myhost.net" as user "myusername" and run command "mkdir -p $2"
ssh myusername@ssh.myhost.net "mkdir -p $2"

SSH into $1 with login name 'pete'
ssh "$1" -l pete

ssh into default vagrant host without running "vagrant ssh"
ssh $(vagrant ssh-config | awk 'NR>1 {print " -o "$1"="$2}') localhost

ssh into default vagrant host without running "vagrant ssh"
ssh `vagrant ssh-config | tail -8 | perl -pe 's/^\s+/-o@/; s/\s/\=/;s/@/ /;s/\n/ /'` vagrant@localhost

ssh into default vagrant host without running "vagrant ssh" and without an interactive ssh shell
vagrant ssh-config --host default | ssh -F /dev/stdin default

ssh into default vagrant host without running "vagrant ssh" by passing the configuration parameters vagrant uses for ssh
ssh vagrant@127.0.0.1 -p 2222 -o Compression=yes -o DSAAuthentication=yes -o LogLevel=FATAL -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -o IdentitiesOnly=yes -i ~/.vagrant.d/less_insecure_private_key -o ForwardAgent=yes

ssh into localhost on port 4444
ssh -p 4444 localhost

SSH into host "server" as user "user"
ssh user@server

SSH into server "app1" as the current user
ssh app1

SSH into SERVER, execute "command," and start up a login shell when it completes
ssh -t SERVER 'command; bash -l'

SSH into user@server and run command ${SSH_COMMAND}
ssh user@server "${SSH_COMMAND}"

SSH login in 'middle.example.org' via port 2222 as user 'deviceuser' using a private key file './device_id.pem'
ssh -i ./device_id.pem deviceuser@middle.example.org:2222

Sum the total content size of the extracted files in "archive.tar.gz"
tar tzvf archive.tar.gz | sed 's/ \+/ /g' | cut -f3 -d' ' | sed '2,$s/^/+ /' | paste -sd' ' | bc

SSH with parameters specified in "$@" using key file "~/.ssh/gitkey_rsa"
ssh -i ~/.ssh/gitkey_rsa "$@"

SSH with trusted X11 forwarding into "user@remoteToRemote_IP" from SSH connection "user@remote_IP"
ssh -XY -t user@remote_IP 'ssh -XY -t user@remoteToRemote_IP'

Swap "new" and "old" files or directories
mv new old -b && mv old~ new

Starts 'chromium', storing user data in a newly created temporary folder.
(chromium --user-data-dir=$(mktemp -d) &)

Starts new detached tmux session 'vims' with new windows 'vim0' and opens file 'foo' within.
tmux new-session -s vims -n vim0 -d "vim foo"

Starts new detached tmux session and runs command $CMD within.
tmux new -d "bash -c '$CMD'"

Starts new detached tmux session and runs command $CMD within.
tmux new -d "bash -c \"$CMD\""

Starts new window named 'win0' in detached tmux session 'vims', opens file 'foo' within.
tmux new-window -t vims -d -n "win0" "vim foo"

Starts tmux session 'name', forcing tmux to assume the terminal supports 256 colours, and executes defined script within.
tmux -2 new-session -s name "another_script.sh $1"

Strip all '\' and newlines from $output and save the result to variable 'output'
output=$(echo "$output" | tr -d '\' | tr -d '\n')

store absolute path of executing script
ABSOLUTE_PATH="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)/$(basename "${BASH_SOURCE[0]}")"

store absolute path of executing script
DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"

Store content of uncompressed file "$file.fastq" in variable "reads"
reads=$(zcat $file.fastq)

Store info about all mounted file systems, printing all sizes in powers of 1000
a=$( df -H )

Store N symbols of input into variable 'buffer'
read -N $BUFSIZE buffer

Stores system load average number in the 'proc_load_average' variable.
proc_load_average=$(w | head -1 | cut -d" " -f13 | cut -d"," -f1-2 | tr ',' '.')

Stores system load average number in the 'proc_load_average' variable.
proc_load_average=`w | head -1 | cut -d" " -f13 | cut -d"," -f1-2 | tr ',' '.'`

Symlinks all of formula’s installed files into the Homebrew prefix.
brew link bash-completion

Symlinks all of package`s installed files into the Homebrew prefix with overwrite.
brew link --overwrite python

Synchronize "/home/user1/" to "wobgalaxy02:/home/user1/" including hidden files
rsync -av /home/user1/ wobgalaxy02:/home/user1/

Synchronize "/path/to/dir_a" with files in "/path/to/dir_b/" if the files are newer
rsync -rtuv /path/to/dir_b/* /path/to/dir_a

Synchronize "/path/to/dir_b" with files in "/path/to/dir_a/" if the files are newer
rsync -rtuv /path/to/dir_a/* /path/to/dir_b

Synchronize "dir_a" and "dir_b" to contain the latest files in both directories
rsync -ur dir_a dir_b && rsync -ur dir_b dir_a

Synchronize "dir_a" and "dir_b" to contain the latest files in both directories
rsync -urv --progress dir_a dir_b && rsync -urv  --progress dir_b dir_a

Synchronize "xxx-files" to "different-stuff/xxx-files" recursively preserving metadata with a bandwidth limit of 2000 KiB/s
rsync -pogtEtvr --progress --bwlimit=2000 xxx-files different-stuff

Synchronize via ssh "user@source-server:/somedirA/" to "somedirB/" with compressed data during transmission and display progress
rsync -avz -e ssh --progress user@source-server:/somedirA/ somedirB/

Take a file path from standard input and remove it.
xargs -I '{}' rm '{}'

Take a file path from standard input and remove it.
xargs -i rm '{}'

take all files in the directory " /path/to/files" and provide them as input to the script file truncate.sh
find /path/to/files -exec truncate.sh {} \;

take all the files in the current folder and pass them as argument to a program
find . -exec program {} +

Take first text field from file 'file.txt' as a domain name and get short A record for this one.
cut -d' ' -f1 file.txt | xargs dig +short

Take the last slash-separated section of variable "FILE" and copy it to variable "NAME".
NAME=`basename "$FILE"`

Take the section of variable "FILE" between the last slash and the following dot, if any, and store that section in variable "NAME".
NAME=`basename "$FILE" | cut -d'.' -f-1`

The  command runs all the directories (-type d) found in the $LOGDIR directory wherein a file's data has been modified within the last 24 hours (-mtime +0) and compresses them (compress -r {}) to save disk space.
find $LOGDIR -type d -mtime +0 -exec compress -r {} \;

The file "files_to_find.txt" contains a list of filenames, create each file or update its timestamp if it exists.
touch `cat files_to_find.txt`

The cpio command is a copy command designed to copy files into and out of a cpio or tar archive, automatically preserving permissions, times, and ownership of files and subdirectories.
find . | cpio -pdumv /path/to/destination/dirrectory

Traverse the filesystem just once, listing setuid files and directories into /root/suid.txt and large files into /root/big.txt.
find /       \( -perm -4000 -fprintf /root/suid.txt '%#m %u %p\n' \) , \              \( -size +100M -fprintf /root/big.txt  '%-10s %p\n' \)

Traverse the filesystem just once, listing setuid files and directories into /root/suid.txt and large files into /root/big.txt.
find /       \( -perm -4000 -fprintf /root/suid.txt '%#m %u %p\n' \) , \( -size +100M -fprintf /root/big.txt  '%-10s %p\n' \)

Truncate all non-empty regular files under the current directory
find . -type f -maxdepth 1 -not -empty -print0 | xargs -0i cp /dev/null {}

Truncate all non-empty regular files under the current directory
find . -type f -maxdepth 1 -not -empty -print0 | xargs -0i sh -c "cat /dev/null > \"{}\""

Truncate all regular files under the current directory
find . -type f -maxdepth 1 -exec sh -c 'cat /dev/null > {}' \;

Truncate all regular files under the current directory
find . -type f -maxdepth 1 -print0 | xargs -0i sh -c "cat /dev/null > \"{}\""

Truncates file $file, removing last line from it and prints this file on stdout.
tail -n 1 "$file" | tee >(wc -c | xargs -I {} truncate "$file" -s -{})

Run "./configure" with a new environment variable CC set to the full path of the command 'cc'
CC=$(which cc) ./configure

Run "./configure" with a new environment variable CC set to the full path of the command 'gcc'
CC=$(which gcc) ./configure

Run "command" on server "host" as user "user"
echo "command" | ssh user@host

Run "myprogram" in the current directory, pausing for user input at each page.
./myprogram | more

Run "myprogram", pausing for user input at each page.
myprogram|more

Run "ps -elfc" followed by "ls" on host "example.com"
ssh example.com "ps -elfc; ls"

run "tar -xzvf ..." as user $username
su $username -c tar xzvf ..

run "your_command", letting the user page through the output and move around with the arrow keys - the Q key terminates and returns to the shell prompt.
"your_command" | less

Run 'chmod 0644' on all files in the current directory tree
find . -type f -exec chmod 0644 {} \;

Run 'chmod 0755' on all directories in the current directory tree
find . -type d -exec chmod 0755 {} \;

Run `command' passing the files from the current directory tree as arguments
find . -exec command {} +

Run `command' passing the files from the current directory tree as arguments
find . -print0|xargs -0 command

Run `command' passing the files from the current directory tree as arguments
find . -print|xargs command

Run `command' on each file from the current directory tree
find . -exec command {} \;

Run 'command', pausing and waiting for user interaction after each page of output.
command | more

Run `fastqc' on all the fastqc files in the current directory tree
find . -name "*.fq"  -exec cat '{}' ';' | fastqc  /dev/stdin

Run `fastqc' on all the fastqc files in the current directory tree
find . -name "*.fq" -print0 | xargs -0 -n 1 fastqc

Run `fastqc' on all the fastqc files in the current directory tree
find . -name "*.fq" | xargs -n 1 fastqc

Run `fastqc' on all the fastqc files in the current directory tree
find . -name "*.fq.gz"  -exec gunzip -c  '{}' ';' | fastqc  /dev/stdin

Run 'git pull' and, if successful, 'git status' in every git repository in the current directory
find . -type d -name .git -exec sh -c "cd \"{}\"/../ && pwd && git pull && git status" \;

Run 'git pull' in every git repository in the current directory
find . -name ".git" -type d | sed 's/\/.git//' |  xargs -P10 -I{} git -C {} pull

Run 'git pull' in every git repository in the current directory
find . -type d -name .git -exec sh -c "cd \"{}\"/../ && pwd && git pull" \;

Run 'join' on file1 and file2, using a literal tab character as field separator.
join -t $'\t' file1 file2

Run 'join' with the number-sorted output of file1 and file2, without modifying file1 or file2: for each line with a common first field in file1 and file2, output the common field followed by the extra fields in both files.
join <(sort -n file1) <(sort -n file2)

Run 'make -e' with an environment variable 'HOSTNAME' set to the system hostname
HOSTNAME=$(hostname) make -e

Run 'make' with parameter K_VERSION set to current kernel release.
make K_VERSION=`uname -r`

Run 'otherscript.sh' script with all environment variables specified in the file 'xxxx'
env `cat xxxx` otherscript.sh

Run 'somecommand' in an environment without the FOO variable.
env -u FOO somecommand

Run 'top' in batch mode (don't accept user input) with delay of 1 second between updates, and duplicate the standard output to file 'output.log' in current directory.
top -b -d 1 | grep myprocess.exe | tee output.log

Run ./yourProgram without address space randomization, reporting actual machine type.
setarch `uname -m` -R ./yourProgram

Run /bin/true with 1 to 100000 as arguments
/bin/sh -c "/bin/true $(seq 1 100000)"

Run /bin/true with 1 to 99999 as arguments
/bin/sh -c "/bin/true $(seq 1 99999)"

Run 10 bash processes at most 4 at a time of "echo start N; sleep 3; echo done N" for N ranging from 1 to 10
seq 10 | xargs -i --max-procs=4 bash -c "echo start {}; sleep 3; echo done {}"

run a command "dbca -silent -createDatabase -templateName General_Purpose.dbc -gdbName qualidade -sysPassword password -systemPassword password -scriptDest /u01/app/oracle/oradata/qualidade -characterSet WE8ISO8859P1" with bash shell as user oracle
su -c "dbca -silent -createDatabase -templateName General_Purpose.dbc -gdbName qualidade -sysPassword password -systemPassword password -scriptDest /u01/app/oracle/oradata/qualidade -characterSet WE8ISO8859P1" -s /bin/sh oracle

Run a program in a named screen session
screen -dmS title executable

run a shell as user jenkins
su - jenkins -s /bin/bash

Run a shell in a named screen session
screen -x title

Run a shell with all environment variables specified in the file 'cronenv' in the user's home directory.
env - `cat ~/cronenv` /bin/sh

Run cmd1 and cmd2 on each file/directory under current directory with the file/directory path as a positional argument to those commands
for i in `find . -exec echo {} \;`; do cmd1 $i; cmd2 $i; done

run command "$WEB --quiet" in backgrounf as user  named as the value of the variable $USER
su $USER -c "$WEB --quiet" &

run command "${OBJECTDB_HOME}/bin/objectdb.sh start" $JAVA_USER" as user $JAVA_USER
su --session-command="${OBJECTDB_HOME}/bin/objectdb.sh start" $JAVA_USER

run command "/path/to/my_daemon & echo \$! > /tmp/su.joe.$$" as user joe
su - joe -c "/path/to/my_daemon & echo \$! > /tmp/su.joe.$$"

run command "/path/to/my_daemon" as user joe and redirect the output to file /some/output/file
su - joe -c "/path/to/my_daemon > /some/output/file" &

run command "/usr/bin/psql database -c \"SELECT 'DROP TABLE ' || .... " as user postgres
su - postgres -c "/usr/bin/psql database -c \"SELECT 'DROP TABLE ' || .... "

run command "cd /home/$USERNAME/$PROJECT ; svn update" as user named as value of the variable $USERNAME
su -c "cd /home/$USERNAME/$PROJECT ; svn update" -m "$USERNAME"

run command "command" as user username with a full login simulation
su - username command

run command "createdb $DBNAME" as user postgres
su --login postgres --command "createdb $DBNAME"

Run commands "df -k;uname -a" on server "192.168.79.134"
echo "df -k;uname -a" | ssh 192.168.79.134

run command "exec > >( logger -t $PRG ) 2>&1 ; cd $WKD; { $BIN $ARG & }; echo \$! > $PID " as user $USR
su -l $USR -s /bin/bash -c "exec > >( logger -t $PRG ) 2>&1 ; cd $WKD; { $BIN $ARG & }; echo \$! > $PID "

run command "sh runProgram.sh" as user jetty
su - jetty -c sh runProgram.sh

run command "ssh user1@192.168.1.2 \"awk '\\\$5==1{print \\\$3}' filename.log\"" as user1 and unify the result
su user1 -c "ssh user1@192.168.1.2 \"awk '\\\$5==1{print \\\$3}' filename.log\"" | uniq -c

run command './bin/elasticsearch -d --default.path.conf=/etc/elasticsearch' as user elasticsearch
sudo su elasticsearch -c './bin/elasticsearch -d --default.path.conf=/etc/elasticsearch'

run command 'bash --rcfile <(echo "source ~/.bashrc; source myfile")' as user root with a bash shell
su -s /bin/bash -c 'bash --rcfile <(echo "source ~/.bashrc; source myfile")'

run command 'bash --rcfile myfile' as user root
su -c 'bash --rcfile myfile'

run command 'source myfile; bash' as user root
su -c 'source myfile; bash'

Run mycommand in /tmp without changing the current shell's working directory
( cd /tmp; mycommand )

Run command specified by $line, replace space (' ') with newline and save the output to variable 'arr'
arr=$( $line | tr " " "\n")

run bash in screen and source a file before printing the prompt
screen bash --rcfile yourfile.rc

Run svn checkout in every directory named 'needed_dir' under repository_dir/$f
find repository_dir/$f -type d -name needed_dir | xargs -r svn checkout

run ls command on *.pl files
find . -name "*.pl" -exec ls -ld {} \;

Turns on network interface eth0.
ifconfig eth0 up

run programm "/home/oracle/database/runInstaller" as user oracle in background
su oracle -c "/home/oracle/database/runInstaller" &

Run rsync with options specified by variable OPTS, copying directory(ies) specified by variable FIND, and to destination specified by variable BACKUPDIR.
rsync $OPTS $FIND $BACKUPDIR

run script  "runProgram.sh" as user jetty
su - jetty sh ./runprogram.sh

run script "runProgram.sh" as user jetty
su - jetty ./runprogram.sh

Run script `deslash.sh' on all thumb.png files in the current directory tree
find -type f -name thumb.png -exec ./deslash.sh {} ";"

Run script `fixname.sh' for each regular file from the current directory tree
find . -type f -exec sh fixname.sh {} \;

run script /PATH/TO/MY_APP as user USER_FOOBAR in background
su - USER_FOOBAR -c /PATH/TO/MY_APP &

run script filename.sh as root with preserved user environment
su -cp filename.sh

run somebashstatement with the filename as argument, for files recursively in /path that match 'pattern'
find /path -name 'pattern' -exec bash -c 'somebashstatement "$1"' -- {} \;

run somecommand with as many arguments as fit on the command line at once for files recursively in /path that match 'pattern'
find /path -name 'pattern' -exec somecommand {} +

run somecommand with one argument for each file recursively in /path that matches 'pattern'
find /path -name 'pattern' -exec somecommand {} \;

Run perl -V (displays informations about perl's setup) in an empty environment.
env -i perl -V

run ksh shell as user apache
su apache -s /bin/ksh

Run the command 'true' with an empty environment variable doFirst
doFirst= true

Run the command 'true' with an empty environment variable doFirst
doFirst="" true

Run the java archive 'start.jar' in a xterm window, immune to SIGHUP (hangup signals) sent to it. The xterm is sent to background, so control returns immediately to the prompt on the original terminal screen/window.
nohup xterm -e java -jar start.jar &

Run the file command on every regular file under current directory
find . -type f -exec file '{}' \;

Run the find command with all positional parameters
find "$@

Run the find command with all shell positional arguments
`which find` "$@" -print0;

Run the node expression "JSON.parse(process.argv[1]).foo" on the contents of "foobar.json"
node -pe 'JSON.parse(process.argv[1]).foo' "$(cat foobar.json)"

Run the PHP script "newEmptyPHP" redirecting the output to "nohup.out" in the current directory, or in the home directory if that is not possible. The process will not receive or respond to SIGHUP (signal 1) which are sent to it.
nohup php newEmptyPHP.php &

Run the sh "for" construct in a subshell (runs ./myscript.sh for each file whose name ends with .fasta in mydir) - the subshell is immune to SIGHUP signals sent to it, and the output is redirected to "output.txt".
nohup sh -c 'for i in mydir/*.fasta; do ./myscript.sh "$i"; done >output.txt' &

Run the specified git command, paging through the output with raw characters written to the terminal, without initializing the terminal capabilities, and automatically exiting when the end of the output is reached.
git -c color.status=always status | less -REX

Run two processes, cmd1 whose output is fed as input to cmd2: cmd1 is immune to all SIGHUP (hangup) signals sent to it, but cmd2 is not.
nohup cmd1 | cmd2 &

Run vi with all btree*.c files under current directory
vi $(find . -type f -name 'btree*.c')

Run your_command_here for each file found under /target/path with the file path as argument
find /target/path -type f -exec your_command_here \{\} \;

Run your_command_here with all the files under /target/path as arguments
find /target/path -type f -print0 | xargs -0 your_command_here

Tunnel VNC port 5900 over compressed SSH and X11 forwarded session to "remotehost"
ssh -X -C -L 5900:localhost:5900 remotehost x11vnc -localhost -display :0

Takes folder name of file $0, changes backslashes to forward ones and saves result in $basedir variable.
basedir=$(cygpath -am "$(dirname "$0")")

Takes folder name of file $0, changes backslashes to forward ones and saves result in $basedir variable.
basedir=$(cygpath -m "$(dirname "$0")")

Takes folder path from string '/path/to/copy/file/to/is/very/deep/there' and created it with all parents.
mkdir -p `dirname /path/to/copy/file/to/is/very/deep/there` \

Takes path list from '.exportfiles.text' file, cuts off first two path segments and last one.
cut -d / -f 4- .exportfiles.text | xargs -n 1 dirname

Type unique list of all directories contiaining each file named 'myfile' under the /home directory
find /home/ -name 'myfile' -type f | rev | cut -d "/" -f2- | rev | sort -u

Uninstalls and then installs git formula.
brew reinstall git

Unsets 'history' shell option.
shopt -u -o history

Unsets GIT_DIR variable.
unset GIT_DIR

Unsets all environment variables.
unset $(/usr/bin/env | /usr/bin/cut -d = -f 1 | /usr/bin/xargs)

Unsets all environment variables.
unset `env | awk -F= '/^\w/ {print $1}' | xargs`

Unsets all environment variables with 'G4' in name.
unset $(printenv |grep G4 |awk 'BEGIN{FS="=";}{print $1;}')

Unsets all environment variables with 'G4' in name.
unset `printenv |grep G4 |awk 'BEGIN{FS="=";}{printf("%s ",$1);}'`

Unsets all locale variables.
unset $(locale|cut -d= -f1)

Unsets DUALCASE variable.
unset DUALCASE

Unsets environment variable 'z'.
unset z

Unsets environment variable represented as var=value by $a.
unset $(echo "$a" | /usr/bin/cut -d = -f 1)

Unsets random one from first four array members.
unset array[$RANDOM%4]

Unsets random one from first four array members.
unset array[`shuf -i 0-3 -n1`]

Unsets random one from first five array members.
unset array[`shuf -i 0-4 -n1`];

Unsets shell functions 'ls' and '/bin/ls'.
unset -f ls /bin/ls

Unsets shell function 'z'.
unset -f z

Unsets shell option 'extglob'.
shopt -u extglob

Unpack all *.gz archives in the current directory tree
find . -name '*.gz' -print0 | xargs -0 gunzip

unsafed rm all file which name start with '#'
find / -name '#*' -atime +7 -print | xargs rm

Updates 'openssl' package, skipping packages with broken dependencies.
sudo yum update openssl --skip-broken

Updates 'openssl' packages without using of 'epel' repository.
sudo yum --disablerepo epel update openssl

Updates all installed software.
yum update

Updates all packages in system  answering 'yes' on all questions.
yum -y update

Updates all packages with 'rpmfusion' in name.
find-repos-of-install | grep rpmfusion | xargs yum update

Updates all packages with 'rpmfusion' in name.
yum update $(find-repos-of-install | grep rpmfusion)

Updates all software in a system, skipping packages that have a failed dependencies.
sudo yum update --skip-broken

Updates all software in system, prints update log on terminal and saves to 'mylogfile'.
yum update | tee mylogfile

Updates openssl package.
sudo yum update openssl

Update the archive '2009.tar' with the files from the data/ directory tree that match pattern 'filepattern-*2009*'
find data/ -name "filepattern-*2009*" | cpio -ov --format=ustar > 2009.tar

Update the archive '2009.tar' with the files from the data/ directory tree that match pattern 'filepattern-*2009*'
find data/ -name filepattern-*2009* -exec tar uf 2009.tar {} ;

Update the archive '2009.tar' with the files from the data/ directory tree that match pattern 'filepattern-*2009*'
find data/ -name filepattern-*2009* -print0 | xargs -0 tar uf 2009.tar

Update the archived copy of the home directory, "alldata.tar"
find ~/ -newer alldata.tar -exec tar uvf alldata.tar {} ;

Update the history file in the current session
history -w

update the permission of all the files in the folder /u/netinst to 500
find /u/netinst -print | xargs chmod 500

update the permissions of the directories in the folder folder_name to 775
find folder_name -type d -exec chmod 775 ‘{}’ \;

Update the timestamp of '/tmp/$$' to the current month and day
touch -t `date +%m%d0000` /tmp/$$

Update the timestamp of 'filename', or create an empty file if it doesn't exist.
touch filename

Update timestamps of all files and directories under directory /path/to/dir.
find /path/to/dir -print0 | xargs -0 touch

Update timestamps of all files in entire filesystem which are not newer than /tmp/timestamp
find / ! -newer /tmp/timestamp -exec touch {} \;

Update timestamps of all regular files (ie. excluding directories, symlinks, sockets, etc.) under /your/dir
find /your/dir -type f -exec touch {} +

Upgrades 'php-mbstring' package, enabling 'remi' repository.
yum --enablerepo=remi upgrade php-mbstring

using exec in find command to dispaly the searched files
find . ... -exec cat {} \; -exec echo \;

Use "$BYTES" amount of RAM for "$SECONDS" seconds with no output
cat <(yes | tr \\n x | head -c $BYTES) <(sleep $SECONDS) | grep n

Use "$BYTES" amount of RAM showing the current and total rate of consumption
yes | tr \\n x | head -c $BYTES | pv | grep n

Use "$BYTES" amount of RAM with no output
yes | tr \\n x | head -c $BYTES | grep n

Use "/var/log/wtmp" and print IPs and search for "^msw.*127.0.0.1"
who --ips /var/log/wtmp | grep '^msw.*127.0.0.1'

Use "composer validate" command on all composer.json files
find . -type f -name "composer.json" -exec composer validate {} \;

Use "vagrant-ssh" as the config file and ssh into "default" host
ssh -F vagrant-ssh default

(GNU specific) Use 'top' to monitor the newest instance of ProgramName.
top -p "$(pgrep --newest ProgramName)"

(GNU specific) Use 'top' to monitor the newest instance of ProgramName.
top -p "$(pgrep ProgramName | head -n 1)"

(GNU specific) Use 'top' to monitor the newest instance of ProgramName.
top -p $(ps aux | awk '/ProgramName/ && ! /awk/ { print $2; exit; }')

(GNU specific) Use 'top' to monitor the oldest instance of ProgramName.
top -p "$(pgrep --oldest ProgramName)"

(GNU specific) Use 'top' to monitor one process.
top –p $PID

(GNU specific) Use 'top' to monitor process 'a.out'
top -b -p `pidof a.out`

(GNU specific) Use 'top' to monitor process 'a.out', printing information 100 times.
top -b -p `pidof a.out` -n 100

Unset RBENV_VERSION variable from within tmux session.
tmux set-environment -u RBENV_VERSION

Unset RBENV_VERSION variable in global environment.
tmux set-environment -gu RBENV_VERSION

Unset RBENV_VERSION variable in tmux session 'sessname' environment.
tmux set-environment -t sessname -u RBENV_VERSION

Uses GNU tool 'time' to estimate time consumed by command 'command' and redirects output to file
\time -o time.log command

use find command to search for .png and .jpg files
find ./ -type f \( -iname \*.jpg -o -iname \*.png \)

Use metaflac to extract the artist field from myfile.flac, and set the variable ARTIST to the value of that field.
source <(metaflac --show-tag ARTIST myfile.flac)

(Linux specific) Use Midnight Commander's "view" mode to interactively display the current kernel's compile-time config file.
view /boot/config-$(uname -r)

Use multiple -exec command in find . Find all .txt files & grep banna in .txt files .
find . -name "*.txt" -exec echo {} \; -exec grep banana {} \;

Unset IFS and read a single character from standard input  with timeout of 0.01 seconds and save the response in variable "keypress"
IFS= read -t 0.01 -d '' -n1 keypress

Unset IFS and read a single character of standard input with no echo and save the response in variable "SELECT"
IFS= read -s -n 1 SELECT

Unset IFS and read standard input into variable "file" until a null character is found without allowing backslashes to escape characters
IFS= read -d $'\0' -r file

use regex with find command
find . * | grep -P "[a-f0-9\-]{36}\.jpg"

use regex with find command
find . -regextype posix-egrep -regex '\./[a-f0-9\-]{36}\.jpg'

use regex with find command
find . -regextype sed -regex ".*/[a-f0-9\-]\{36\}\.jpg"

Use the contents of compressed files "input1.txt.gz" and "input2.txt" as arguments to "command"
command $(zcat input1.txt.gz) $(zcat input2.txt)

Unset the DISPLAY variable
unset DISPLAY

Unset the executable bit of all regular files from directory trees arch, etc, lib, module, usr, xpic
find arch etc lib module usr xpic -type f | xargs chmod -x

Use the last 100 lines of "file1" as input to "wc -l" and monitor the pipeline with the "bar" command
tail -n 100 file1 | bar | wc -l

Use the octal form to find and print detailed information about all regular files in your home directory and below that have only the group permission set.
find . -perm 040 -type f -exec ls -l {} \;

Use the PHP interpreter to output an endless stream of "a" characters to "nohup.out" in the current directory, or in the home directory if that is not possible. The PHP process will not receive or respond to SIGHUP (signal 1) which are sent to it.
nohup php -r 'while (true) { echo "a";}' &

Use the uncompressed contents of "blah.gz" as input to "some_command"
cat blah.gz | gunzip | some_command

Use the uncompressed contents of "blah.gz" as input to "some_command"
gunzip -c blah.gz | some_command

Uses the time utility to report only real execution time of 'ls' command.
/usr/bin/time -f%e ls >/dev/null

Use up to a gigabyte of RAM at a rate of 1MB per second showing the current and total rate
yes | tr \\n x | head -c $((1024*1024*1024)) | pv -L $((1024*1024)) | grep n

(GNU specific) Set variable LINE to full process info of process currently taking the most CPU time, squeezing multiple consecutive spaces into one.
LINE=$(top -b -n 1 | tail -n +8 | head -n 1 | tr -s ' ')

(GNU specific) Set variable OUTPUT to full process info of process currently taking the most CPU time.
OUTPUT=`top -b -n 1 | tail -n +8 | head -n 1`

Variable PID contains a process ID, check if this process exists - resulting exit status from this command will be zero if it does and current user has permission to send it signals.
kill -0 $PID

Verbosely change ownership of "$file" to "root"
chown -v root "$file"

verbosely create intermediate directoriy tmp as required and directory boostinst
mkdir -pv /tmp/boostinst

Verbosely compresses all files on fourth and fifth depth level keeping original files in place.
bzip2 -kv */*/*/*/*

Verbosely compresses all files on sixth and seventh depth level keeping original files in place.
bzip2 -kv */*/*/*/*/*/*

Views text content of compressed FileB file in TarFile archive.
tar -xOf TarFile FileB.gz | zless

View lines 116 through 120 of history
history | head -n 120 | tail -n 5

View line 500 to line 500 + 501 in gzipped file "bigfile.z"
zcat bigfile.z | tail -n +500 | head -501

View manual page of find utility
man find

View manual page of the find command
man find

View the man page of find
man find

view the manual page of find
man find

wait 2 seconds and then print "hello"
echo "hello `sleep 2 &`"

wait for a change in "target-directory" before returning
inotifywait -e attrib target-directory

When a window is closed in a session, automatically renumbers the other windows in numerical order (since v1.7).
tmux set-option -g renumber-windows on

when using vi-insert keymap bind command "\C-v{}\ei" to key "{"
bind -m vi-insert '"{" "\C-v{}\ei"'

Close the master SSH control socket "my-ctrl-socket" to "jm@sampledomain.com"
ssh -S my-ctrl-socket -O exit jm@sampledomain.com

This will remove all files (type f) modified longer than 14 days ago under /root/Maildir/ recursively from there and deeper (mindepth 1
find /root/Maildir/ -mindepth 1 -type f -mtime +14 | xargs rm

switch to user username
su username

switch user to jenkins
su - jenkins

Wrap each line in "file" to fit in 80 characters and count the number of lines
fold file | wc -l

Wrap each line in "file.txt" to fit in 80 characters
cat file.txt | fold

Wrap each line in "file.txt" to fit in 80 characters
fold -w 80 file.txt

Wrap each line in "longline" to a maximum of 30 characters
fold -w30 longline

Wrap each line in "longline" to a maximum of 30 characters breaking at spaces
fold -w30 -s longline

Wrap standard input to fit in 10 characters per line
fold -w 10

Time stamp every ping request to 8.8.8.8 in Unix epoch format
ping -D -n -O -i1 -W1 8.8.8.8

Calculate MD5 sums for all regular files in the current directory tree
find . -type f | while read f; do g=`md5sum $f` > $f.md5; done

Change folder to the one where $0 link target file is located.
cd $(dirname $(readlink -f $0))

change group of the file /tmp/php_session to group daemon
chown -R :daemon /tmp/php_session

Change owner and group of "script.sh" to "root"
chown root:root script.sh

change owner and group of the directory  $dstdir" to the user and group of the file "$srcdir"
chown $(stat -f%u:%g "$srcdir") "$dstdir"

change owner of the files into directory "/mydir" with ".txt" extension to user root
find /mydir -type f -name "*.txt" -execdir chown root {} ';'

Change owner to "root" and group to "wheel" of "bin"
sudo chown root:wheel bin

Change permissions to 755 recursively only for directories
find . -type d -exec chmod 755 {} \;

Change the owner of all files in the current directory tree excluding those who match "./var/foo*" to "www-data"
find . -not -iwholename './var/foo*' -exec chown www-data '{}' \;

Change the owner to "root" and group to "specialusers" of "dir1"
chown root:specialusers dir1

change the permission of all php files in current folder
find . -name "*.php" -exec chmod 755 {} \;

Check whether "$path_in_question" is a mount point
df $path_in_question | grep " $path_in_question$"

This command find displays the files which are modified in the last 15 minutes. And it lists only the unhidden files. i.e hidden files that starts with a . (period) are not displayed in the find output.
find . -mmin -15 \( ! -regex ".*/\..*" \)

Compress in parallel regular files in the current directory tree that were last modified more than 7 days ago
find . -type f  -mtime +7 | tee compressedP.list | parallel compress

Compress in parallel regular files in the current directory tree that were last modified more than 7 days ago
find . -type f  -mtime +7 | tee compressedP.list | xargs -I{} -P10 compress {} &

Convert symlink to regular file
find . -type l | while read f; do /bin/cp -rf --remove-destination -f $(find . -name $(readlink "${f}")) "${f}";done;

convert all text files in the current folder from dos to unix format
find . -name *.txt | xargs dos2unix

Copies all files under current directory like '*FooBar*' to the '~/foo/bar' directory.
find -name '*FooBar*' -print0 | xargs -0 cp -t ~/foo/bar

Count files accessed more than a month ago
find . -atime +30 -exec ls \; | wc -l

Counts lines of myfile.txt file.
cat myfile.txt | wc -l

Count the number of lines in all ".txt" files
cat *.txt | wc -l

Count the number of files named `file1'
find -name file1 | wc -l

Copy /my/configfile to all empty directories of the $somedir directory tree
find "$somedir" -type d -empty -exec cp /my/configfile {} \;

Copy all files below the current directory whose names contain "FooBar" to directory foo/bar/ in user's home directory.
find -name '*FooBar*' -print0 | xargs -0 cp -t ~/foo/bar

Copy all files below the current directory whose names contain "FooBar" to directory foo/bar/ in user's home directory.
find . | grep FooBar | xargs -I{} cp {} ~/foo/bar

Copy all regular files from the current directory tree to /tmp
find . -type f -exec sh -c 'cp "$@" /tmp' {} +

Copy the current directory tree to '/path/to/destination/dir' preserving permissions, timestamp and ownership
find . | cpio -pdumv /path/to/destination/dir

copy the file header.shtml to each directory under dir1, dir2, dir3, or dir4
find dir1 dir2 dir3 dir4 -type d -exec cp header.shtml {} \;

create directory certs
mkdir certs/

create directory saxon_docs
mkdir saxon_docs

Create intermediate directories as required
mkdir -p $2

Delete all files beneath the current directory that begin with the letters 'Foo'.
find . -type f -name "Foo*" -exec rm {} \;

delete all the normal files in the current directory whcih have the word "gui" in their content.
find / -type f -print0 | xargs -0 grep -liwZ GUI | xargs -0 rm -f

delete all the regular files in the temp folder which have not been changed in the last 15*24 hours
find /tmp/ -ctime +15 -type f -exec rm {} \;

Delete files with inode number 782263 under current directory
find . -inum 782263 -exec rm -i {} \;

display a long listing of all fles in current folder which have been modified in the last 60 minutes
find . -mmin -60 -ls

display a list of all java or jsp files in the current folders
find . \( -name '*jsp' -o -name '*java' \) -type f -ls

display all files in the current folder which end with extension "myfile" followed by two digits
find . -regex '.*myfile[0-9][0-9]?'

display all files in the current folder with the name test excluding those that are present in the sub folders of the test folder
find . -name test -prune

display all soft links in current folder
find . -type l

display all symbolic links in the folder "myfiles"
find /myfiles -type l

display all symbolic links in the folder "myfiles" and follow them
find -L /myfiles

display all the directories in the current folder
find . -type d

display all the directories in the current folder
find . -type d -print

display all the empty files in current folder
find . -empty

display all the files and directories with the name "CVS"  from /usr/src folder that are at least seven levels deep and do not descend onto the folders
find /usr/src -name CVS -prune -o -depth +6 -print

display all the files ending with ".foo" excluding those that are in the directory ".snapshot"
find . -name .snapshot -prune -o -name '*.foo' -print

display all the files in the current folder which have been modified in the last 24 hours
find . -mtime -1

display all the files in the current folder which have been modified in the last 24 hours
find . -mtime -1 -print

display all the files in the entire file system which have set uid bit set.
find / -perm -u+s -print

display all the files in the file system which belong to the user "user1"
find / -user user1

display all the files in the home folder that have been modified in the last 7*24 hours
find $HOME -mtime -7

Display detailed usage help of the 'cp' (copy) command.
cp --help

display list of all the regular/normal files in the current folder which start with "my"
find . -name 'my*' -type f -ls

Search all regular files in the current directory for "example"
find -maxdepth 1 -type f | xargs grep -F 'example'

Search all the .c and .h files in the current directory tree for "expr"
find -name '*.[ch]' | xargs grep -E 'expr'

Search case insensitively for 'facebook', 'xing', 'linkedin', ''googleplus' in file 'access-log.txt', extract the matched part, sort them and print them by sorting them in asending order of the number of repeated lines
grep -ioh "facebook\|xing\|linkedin\|googleplus" access-log.txt | sort | uniq -c | sort -n

search for all the directories starting with the word in the current folder and give them as input to the script fixmbox
find . -name 'm?' -type d -exec ./fixmbox {} +

search for all the regular/normal files in the current folder which start with "my"
find . -name 'my*' -type f

Search for broken symlinks
find -L -type l

Search for directories that contain the phrase "foo" but do not end in ".bar"
find . -name '*foo*' ! -name '*.bar' -type d -print

Search for files "file1" or "file9"
find . -name file1 -or -name file9

Search for files that are at least 1.1GB
find / -size +1.1G

Search for files which have read and write permission for their owner, and group, but which other users can read but not write to.
find . -perm 664

Search for file "file" with minimum depth set to 4
find -mindepth 4 -name file

Search for first match of the case insensitive regex 're' in all *.coffee files under current directory
find . -name \*.coffee -exec grep -m1 -i 're' {} \;

search for MP3 files in the current folder and subfolders except in dir1 subfolder.
find ! -path "dir1" -iname "*.mp3"

search for the file "file1" in the entire file system
find / -name file1

search for the file filename in the entire file system
find / -name filename

search for the regular/normal file 'myfile' in the folder /root excluding those that are present in the /root/work directory
find /root/ -path '/root/work' -prune -o -name myfile -type f -print

search for the word LOG in all the files in the folder ~/jsmith
find ~jsmith -exec grep LOG '{}' /dev/null \; -print

Search for the wp-config.php file in /var/www and one level below
find /var/www/ -name wp-config.php -maxdepth 2

Search the .c files residing in the Lib/ directory tree for lines beginning with "PyErr"
find Lib/ -name '*.c' -print0 | xargs -0 grep ^PyErr

Search the .cs files of the current directory tree for string "content pattern"
find ./ -type f -iname "*.cs" -print0 | xargs -0 grep "content pattern"

Search the /home/pankaj directory for regular files whose status has changed within the last 5 minutes
find /home/pankaj -maxdepth 1 -cmin -5 -type f

Search the /path directory tree for files missing g+w or o+w bits
find /path ! -perm -022

Search the current directory tree for files whose names begin with "my" and end with "p" followed by any character
find . -regex ".*/my.*p.$"

Search the current directory tree for files whose names contain "bills"
find . -name '*bills*' -print

Search the current directory tree for files whose names match regular expression '.*packet.*', ignoring the case
find . -iregex ".*packet.*"

Search the current directory tree for regular files lacking read permissions for user, group, or others
find . -type f ! -perm -444

Search the directory tree given as variable $root_dir for regular files
find $root_dir -type f

Search the files of the current directory tree for string "searched-string"
find . | xargs grep "searched-string"

Search the local subdirectory tree of the current working directory and the /tmp directory tree for directories named mydir
find local /tmp -name mydir -type d -print

Search the home directory tree for files last modified more than a year ago
find $HOME -mtime +365

Search the system for 'dead' symbolic links
find / -type l -print | perl -nle '-e || print';

Find *.conf files/directories only upto 1 level down under /etc directory and show a few lines of output from the end
find /etc -maxdepth 1 -name "*.conf" | tail

find a file in current folder and discard the errors
find /. -name 'toBeSearched.file' 2>/dev/null

Find all *.java files under current directory and change their encoding to utf-8 from cp1252
find . -type f  -name '*.java' -exec sh -c 'iconv -f cp1252 -t utf-8 "$1" > converted && mv converted "$1"' -- {} \;

Find all *.ogg and *.mp3 (case insensitive) files/directories under your home directory
find $HOME -iname '*.ogg' -o -iname '*.mp3'

Find all *.rb files/directories under current directory
find . -name "*.rb"

Find all .php files in the current directory tree
find . -type f -name "*.php"

find all .pm, .pl files in /users/tom and search for a pattern in these files and display the matched file names
find /usr/tom | egrep '*.pl| *.pm' | xargs cat | grep <PATTERN>

Find all 777 permission directories and use chmod command to set permissions to 755
find . -type d -perm 777 -print -exec chmod 755 {} \;

Find all Subscription.java files/directories under current directory and enter into the parent directory of the first one found
cd $(find . -name Subscription.java | xargs dirname)

Find all Subscription.java files/directories under current directory and enter into the parent directory of the first one found
cd `find . -name Subscription.java | xargs dirname`

find and delete all the files in the entire file system whose size is greater than 100MB.
find / -size +100M -exec rm -rf {} \;

find all directories in the current directory
find . -type d

Find all directories under current directory and set read & execute permission for group and other for these files
find . -type d -print0 | xargs -0 chmod go+rx

Find all directories under current directory and set read-write-execute permission for owner, read-execute permission for group and no permission for other for those directories
find . -type d -exec chmod u=rwx,g=rx,o= '{}' \;

find all directory list which have empty list in /tmp directory
find /tmp -type d -empty

find all directory list which have empty list in /tmp directory .
find /tmp -type d -empty

Find all directories named 'files' under current directory and set read-write-execute permission for owner and group and no permission for other for those directories
find . -type d -name files -exec chmod ug=rwx,o= '{}' \;

Find all directories starting from the current directory
find . -type d

Find all directories with space in their names under current directory and rename them by replacing all spaces with _
find -name "* *" -type d | rename 's/ /_/g'

Find all empty directories under /tmp and below
find /tmp -type d -empty

Find all empty directories under a certain path
find /tmp -type d -empty

Find all empty regular files in the current directory and below
find . -type f -empty

find all java files in current folder and trim extra spaces, tab spaces
find . -type f -name "*.java" -exec perl -p -i -e "s/[ \t]$//g" {} \;

Find all executables under /path directory
find /path -perm /ugo+x

Find all file.ext files/directories under current directory with "FooBar" in their paths and copy them into the current directory
find . -name "file.ext"| grep "FooBar" | xargs -i cp -p "{}" .

find all files in and under the current directory that have read, write and execute permissions set for all users.
find . -perm 777 -print

find all files that do not have execute permission to all
find . -type d ! -perm -111

Find all files/drectories under '/u/bill' directory tree that have been accessed in the last 2 to 6 minutes
find /u/bill -amin +2 -amin -6

Find all files and directories containing "disc" in their names
find . -name *disc*

Find all files/directories under '/home/user/' directory tree whose status was changed exactly 10 minitues ago
find /home/user/ -cmin 10 -print

Find all files/directories under /myfiles following symlinks if needed
find -L /myfiles

Find all files/directories under /myfiles that were modified 2 days ago
find /myfiles -mtime 2

Find all files/directories under current directory and print their paths
find . -exec echo {} +

Find all files/directories under current directory and print their paths
find . -exec echo {} \;

Find all files/directories named 'vimrc' in the entire filesystem
find / -name vimrc

Find all files and directories whose names end in ".rpm" and change their permissions to 755
find / -name *.rpm -exec chmod 755 '{}' \;

Find all files, folders, symlinks, etc in the current directory recursively
find .

Find all files you have modified in the last two days
find ~ -type f -mtime -2

Find all files in the current directory tree ignoring the ".git" directory
find . -type d -name '.git*' -prune -o -type f -print

Find all files under current directory and change their permission to 400
find . -type f -exec chmod 400 {} \;

Find all files under current directory and set read permission for group and other for these files
find . -type f -print0 | xargs -0 chmod go+r

Find all files that are set group ID to staff
find . -group staff -perm -2000 -print

Find all files that belongs to group Developer under /home directory
find /home -group developer

Find all files with '.conf' extension under '/etc' directory going into at most 2 level deep and show the last 10 of them
find /etc -maxdepth 2 -name "*.conf" | tail

Find all files with '.txt' extension under '/home/my_dir' dirctory tree and display the number of lines in these files
find /home/my_dir -name '*.txt' | xargs grep -c ^.*

Find all files with the name "MyProgram.c" in the current directory and its sub-directories while ignoring the case of the file name.
find -iname "MyCProgram.c"

Find all files with the SUID bit set beginning with the root directory
find / -perm -u+s

Find all hidden regular files under /tmp and below
find /tmp -type f -name ".*"

find all jpg files in the folder which are in the path "/201111/" and sort them based on name
find */201111/* -name "*.jpg" | sort -t '_' -nk2

Find all PDF files in the current directory and its sub-directories that are not currently stored in the ./pdfs directory and move them into the ./pdfs directory.
find . -name "*.pdf" -print | grep -v "^\./pdfs/" | xargs -J X mv X ./pdfs/

Find and print detailed information about all regular files in your home directory and below that have only the group permission set
find . -perm g=r -type f -exec ls -l {} \;

Find all Read Only files in the file system
find / -perm /u=r

find all normal/regular files in current folder and display the total lines in them
find . -type f -exec wc -l {} +

Find all regular files 1 level down the $dir directory
find $dir -maxdepth 1 -type f

Find all regular files in the current directory tree that are not readable by all
find -type f ! -perm -444

Find all regular files under and below /somepath that have extensions PDF, TIF, TIFF, PNG, JPG, JPEG, BMP, PCX, or DCX, ignoring the case and excluding "*_ocr.pdf" files
find /somepath -type f -iregex ".*\.(pdf\|tif\|tiff\|png\|jpg\|jpeg\|bmp\|pcx\|dcx)" ! -name "*_ocr.pdf" -print0

Find all regular files under current directory tree that contain 'some text' in their names excluding paths that contain dot files/directories
find . -not -path '*/\.*' -type f -name '*some text*'

Find all regular files on the system whose size is greater than 20000k
find / -type f -size +20000k

Find and remove all .core files
find / -name "*.core" -print -exec rm {} \;

Find and remove all .core files
find / -name "*.core" | xargs rm

find all symbolic links in the current folder
find -type l

find all symbolic links under /usr
find /usr -type l

find all the directories in the current directory which dont have the execute permission.
find -type d ! -perm -111

find all the directories in the current folder that are empty(size 0 bytes)
find -type d -empty

find all the directories in the entire file system whose size is greater than 50KB
find / -type d -size +50k

find all the empty files and folders in your system
find / -empty

find all the files in current folder which have been updated in the last 60 minutes
find . -mmin -60

find all the files in the home folder which are empty (Size 0 bytes)
find ~ -empty

find all the files in the entire file system which have been modified in the last 5 days
find / -mtime -5 -print

find all the files in the entire file system whose size is between 50Mb to 100MB
find / -size +50M -size -100M

find all the files in the filesystem which do not belong to any group
find / -nogroup -print

find all the files in the folder /usr/bin which have been modified in the last 10 days
find /usr/bin -type f -mtime -10

find all the files which are of size 0 bytes.
find . -type f -empty

find all the file which name (name can contains space) end with c or h and content contain 'thing'
find . -name '*.[ch]' -print0 | xargs -r -0 grep -l thing

find all the file which name end with c or h and content contain 'thing'
find . -name '*.[ch]' | xargs grep -l thing

find all the files within your home folder accessed more than 100 days ago
find ~ -atime 100

Find all the files in file system which are accessed in last 1 hour
find / -amin -60

Find all the files which are accessed in last 1 hour in entire file system
find / -amin -60

find all the html files in the current folder
find . -name "*.html"

find all the html files in the current folder which have been modified in the last 7 days
find . -mtime -7 -name "*.html" -print

find all the mp3 files in the home folder which have been modified today
find ~ -type f -mtime 0 -iname '*.mp3'

find all the regular files in current folder, that have been changed in the last 3 days and display last 5 files
find . -type f -ctime -3 | tail -n 5

find all the regular/normal files in the current folder
find -type f

find all the xml files in the current folder except those that are present in the workspace folder and create a tarball of these files
find . -name \*.xml | grep -v /workspace/ | tr '\n' '\0' | xargs -0 tar -cf xml.tar

Find all the SGID bit files under current directory whose permissions set to 644 and show a few lines of output from the beginning
find . -perm 0644 | head

find all the symbolic links in the current folder and check the file type and display the output of those files which are broken
find ./ -type l -exec file {} \; |grep broken

Find broken links using the file command on each symlinks in the system and searching for the keword 'broken' with grep
find / -type l -print0 | xargs -0 file | grep broken

find directories under the $LOGDIR directory where there have been no modifications for 5 days and deletes them.
find $LOGDIR -type d -mtime +5 -exec rm -f {} \;

find file end with  '.txt' in current directory.
find . -name "*.txt"

find files having the extension "bam" in current directory
find . -name "*.bam"

find files in /tmp directory that named are core and deletes them
find /tmp -name core -type f -print | xargs /bin/rm -f

find files which full path name like '*f' at current directory and print
find .  -path '*f'

Find files/directories named 'foo' under current directory tree without descending into directories named 'foo'
find . -name foo -type d -prune -o -name foo -print

Find files and directories owned by xuser1 and change their ownership to user2
find . -user xuser1 -exec chown -R user2 {} \;

Find files/directories that are owned by the user 'syslog' in entire filesystem
find / -user syslog

Find files in the current directory and below that are newer than /bin/sh
find . -newer /bin/sh

Find files in the current directory tree whose names match regular expression "^.*~$\|^.*#$"
find -regex "^.*~$\|^.*#$"

Find files modified in last 7 days
find . -mtime -7 -type f

Find files named core in or below the directory /tmp and delete them. Note that this will work incorrectly if there are any filenames containing newlines, single or double quotes, or spaces.
find /tmp -name core -type f -print | xargs /bin/rm -f

Find files named tecmint.txt  of owner root in the entire file system
find / -user root -name tecmint.txt

Find files on the system that are bigger than 20 megabytes and show the sorted list of their filenames
find / -type f -size +20000k -exec ls -lh {} \; 2> /dev/null | awk '{ print $NF ": " $5 }' | sort -nrk 2,2

Find files on the system that are bigger than 20 megabytes and show the sorted list of their filenames
find / -type f -size +20M -exec ls -lh {} \; 2> /dev/null | awk '{ print $NF ": " $5 }' | sort -nk 2,2

Find files that are writable by both the “other” and the group
find plsql -type f  -perm -220 -exec ls -l {} \; 2>/dev/null

Find files that are writable by both the “other” and the group
find plsql -type f  -perm -ug=rw -exec ls -l {} \; 2>/dev/null

Find files that have a modification time of a day ago
find / -mtime 1

Find files with group write permission and remove the permission
find . -perm -20 -exec chmod g-w {} ;

Find out all files owned by user vivek
find / -user vivek

Find file `Chapter1' on the system
find / -name Chapter1 -type f -print

find non-hidden files (ones that do not start with the period "." chartacter) that were are modified in the last 15 minutes.
find . -mmin -15 \( ! -regex ".*/\..*" \)

Find any files in the current directory and its sub-directories that were last accessed more than 7 days or are larger than 20480 blocks in size.
find . -atime +7 -o -size +20480 -print

Find recursively regular files in the current directory tree
find -type f -print0

Find recursively regular files in the current directory tree
find . -type f -print

Find regular files under / that contain "string" and clear out their contents
find / -maxdepth 1 -xdev -type f|xargs grep -l 'string'| xargs perl -pi -e 's/.//g'

Find regular files modified within the last ten minutes under /etc
find /etc -type f -mmin -10

find  symbolic link file that name match  '*sysdep.c'
find . -lname '*sysdep.c'

Find the 5 largest regular files in the Downloads folder of tecmint's home directory.
find /home/tecmint/Downloads/ -type f -exec du -Sh {} + | sort -rh | head -n 5

Find the number of regular files under and below directory /path/to/dir
find /path/to/dir -type f -exec printf %.sX {} + | wc -c

find the regular/normal file "myfile" in the folder /root
find /root/ -name myfile -type f

force remove all the c files in the current folder
find . -name "*.c" | xargs rm -rf

Sort the lines of the file 'inputfile', keep only the uniq lines and change it in-place
sort inputfile | uniq | sort -o inputfile

Kill processes listening on port 3000
lsof -n -i:3000 | grep LISTEN | awk '{ print $2 }' | uniq | xargs kill -9

Get a two column list of all regular .rb files residing in the current directory tree
find . -name "*.rb" -type f -print0 | xargs -0 -n 2 echo

set alias "memu" for command "ps -u $(whoami) -o pid,rss,command | awk '{print \$0}{sum+=\$2} END {print \"Total\", sum/1024, \"MB\"}'"
alias memu="ps -u $(whoami) -o pid,rss,command | awk '{print \$0}{sum+=\$2} END {print \"Total\", sum/1024, \"MB\"}'"

Set permissions to 600 for regular files under media/
find media/ -type f -exec chmod 600 {} \;

Set permissions to 600 for regular files under var/
find var/ -type f -exec chmod 600 {} \;

Get the disk space used by all *.txt (case insensitive) files/directories under folder 1 and folder2
find folder1 folder2 -iname '*.txt' -print0 | du --files0-from - -c -s | tail -1

Go back to last directory.
cd -

Unzip "doc.gz" and gzip every 1000 lines
zcat doc.gz | split -l 1000 --filter='gzip > $FILE.gz'

Append all regular files modified in the last 24 hours to the "$archive.tar" tar archive
find . -mtime -1 -type f -exec tar rvf "$archive.tar" '{}' \;

list all CSS files (and directories ending with “.css”) under the current directory
find . -name "*.css"

list all CSS files under the current directory
find . -type f -name "*.css"

List all empty files under the current directory
find . -maxdepth 1 -empty

list all files under the current directory, redirecting error messages to the output, filtering out lines containing the text "permission denied" and writing the output to a file called files_and_folders
find . 2>&1 | grep -v 'permission denied' > files_and_folders

list all links from / that point to nothing
find / -type l -print | perl -nle '-e || print';

List all files in entire file system that belong to the user wnj or modified later than the ttt file
find / \( -newer ttt -or -user wnj \) -print

List all files in the /myfiles directory tree
find /myfiles -exec ls -l {} ;

List and remove all regular files named "core" that are larger than 500KB
find /prog -type f -size +1000 -print -name core -exec rm {} \;

List all screen sessions
screen -ls

list all the files in the current directory which are of size 0 bytes.
find . -empty

List all zero-length files
find . -empty -exec ls {} \;

list directories owned by group ID 100 in the file system
find / -type d -gid  100

list jobs including its PIDs
jobs -l

list regular file which file name end with 'cache' 'xml' or 'html' in current directory
find . -type f \( -name "*cache" -o -name "*xml" -o -name "*html" \)

list the first line in every text file under the users home directory into report.txt
find $HOME/. -name *.txt -exec head -n 1 -v {} \; > report.txt

Locate the httpd.conf file on the system
find / -name httpd.conf

Look for files that have SUID or SGID set
find / -perm +6000 -type f

Make directory "dir" and do not cause an error if it exists
mkdir -p dir

Make directory "dir1"
mkdir dir1

Make directories "es/LC_MESSAGES" as needed and do not error if it exists
mkdir -p es/LC_MESSAGES

Make directories "project/{lib/ext,bin,src,doc/{html,info,pdf},demo/stat/a}" as needed and do not cause an error if it exists
mkdir -p project/{lib/ext,bin,src,doc/{html,info,pdf},demo/stat/a}

Make directorie(s) 'es/LC_MESSAGES' as needed in the current directory
mkdir -p es/LC_MESSAGES

Output the file name "file.txt' from the path "some/unknown/amount/of/sub/folder/file.txt"
basename "some/unknown/amount/of/sub/folder/file.txt"

Perform syntax check on all PHP files in the current directory tree
find . -name \*.php -type f -exec php -l {} \;

Print a list of all filepattern-*2009* files/directories under data/ to filesOfInterest.txt file
find data/ -name filepattern-*2009* -print > filesOfInterest.txt

Print a summary of the command-line usage of find
find --help

print all files in the current directory and all subdirectories
find .

print all files in the current directory and all subdirectories
find . -print

Prints long recursive listing of all content of a root folder, saving output to 'output.file'.
ls -lR / | tee output.file

print disk usage of files or folders in current directory
du -sh *

Prints listing of a root folder including hidden files, and saves output to 'output.file'.
ls -a | tee output.file

Print summary of new/missing files, and which files differ between dir1 and dir2.
diff  --brief --recursive dir1/ dir2/

Print the entire saved command history
history

Print the full path directory name of each "file.ext" found under the current directory
find . -name "file.ext" -execdir pwd ';'

Print the names and sizes of regular files residing in the "dir" directory tree
find dir -type f -printf "f %s %p\n"

Print the number of regular files found in the current directory tree
find . -type f | wc -l

Print which files differ between "folder1" and "folder2" treating all files as text
diff -arq folder1 folder2

Print which files differ in "folder1" and "folder2" excluding "node_modules" recursively, output in two columns, and paginate the output
diff -rqyl folder1 folder2 --exclude=node_modules

Print your/dir if it's empty
find your/dir -prune -empty

Recursively change the owner and group of all files in "public_html" to "owner"
chown -R owner:owner public_html

Recursively removes all empty folders under current path, printing info message on each operation, and suppressing error messages if folder is not empty.
find -type d -empty -exec rmdir -vp --ignore-fail-on-non-empty {} +

Remove all files from the system whose path names contain "GUI"
find / -type f -print0 | xargs -0 grep -liwZ GUI | xargs -0 rm -f

remove all the ".core" files in the file system
find / -name "*.core" -print -exec rm {} \;

remove all the ".core" files in the file system
find / -name "*.core" | xargs rm

remove all the files in the present directory which have special characters in their name and do not search in the sub directories of the current folder.
find . -name '*[+{;"\\=?~()<>&*|$ ]*' -maxdepth 0 -exec rm -f '{}' \;

Remove everything in a current folder without prompting.
find -mindepth 1 -maxdepth 1 -print0 | xargs -0 rm -rf

Remove files from the home directory tree that were last accessed more than 100 days ago
find ~ -atime +100 -delete

Replace all spaces with underscores in directory paths under current directory.
find -name "* *" -type d | rename 's/ /_/g'

recursively change owner of the directory /tmp to the current user
sudo chown -R $USER ~/tmp

Return 0 if file system is mounted on '/full/path'
df /full/path | grep -q /full/path

Write output of "ls -lR /" to standard output and append to "output.file"
ls -lR / | tee -a output.file

searches through the /usr directory for the regular  file named 'Chapter1*'
find /usr -name "Chapter*" -type f

Sets 'globstar' shell option.
shopt -s globstar

Sets shell option 'globstar'.
shopt -s globstar

Show a long listing of files not modified in over 20 days or not accessed in over 40 days
find /mydir \(-mtime +20 -o -atime +40\) -exec ls -l {} \;

show all files in the current folder that belongs to a specific userid
find . -user <userid>

show all the directories in the current folder
find . -type d

Split "2011.psv" into chunks of at most 50000000 lines each as input to "./filter.sh"
split -l 50000000 --filter=./filter.sh 2011.psv

Split a file ADDRESSS_FILE into pieces per 20 lines named with prefix "temp_file_ and numeric suffixes
split -l20 ADDRESSS_FILE temp_file_

run bash shell as user root
su -c 'bash --rcfile myfile'

Unset (delete) all environment variables.
unset `env | awk -F= '/^\w/ {print $1}' | xargs`

use find -exec with multiple commands
find . -name "*.txt" -exec echo {} \; -exec grep banana {} \;

Use the last 100 lines of "file1" as input to "wc -l" and monitor the pipeline with the "pv" command
tail -n 100 file1 | pv | wc -l

Archive all *.1 files/directories to each filename.tgz files and remove the original source
find *.1  -exec tar czf '{}.tgz' '{}' --remove-files \;

Calculate the MD5 checksums of all files from directory tree //path/to/source/Directory and save them as Output.txt
find //path/to/source/Directory -type f -exec md5sum {} + | awk '{print $0}' > Output.txt

Calculate the md5sum of all the files with name "MyCProgram.c", ignoring case
find -iname "MyCProgram.c" -exec md5sum {} \;

change html files to mode 644
find /usr/local -name "*.html" -type f -exec chmod 644 {} \;

change owner and group of the file it to user and group root
chown root:root it

Change permissions of all directories in the ~/dir_data directory tree in accordance with mode `a+xr,u+w'
find ~/dir_data -type d -exec chmod a+xr,u+w {} \;

Change the permissions of all regular files whose names end with .mp3 in the directory tree /var/ftp/mp3
find /var/ftp/mp3 -name '*.mp3' -type f -exec chmod 644 {} \;

Change to folder where the oracle binary is.
cd "$(dirname "$(which oracle)")"

Change to folder where the oracle binary is.
cd "$(dirname $(which oracle))"

Change to folder where the oracle binary is.
cd $(dirname $(which oracle))

Change to folder where the oracle binary is.
cd $(dirname `which oracle`)

Change to folder where the oracle binary is.
cd $(which oracle | xargs dirname)

Check if the directory tree whose name is given as variable $somedir contains no regular files
find "$somedir" -type f -exec echo Found unexpected file {} \;

Convert all markdown files on the system to html
find / -name "*.md" -type f -exec sh -c 'markdown "$0" > "$0.html"' {} \;

Convert all markdown files on the system to html
find / -name "*.md" -type f -exec sh -c 'markdown "${0}" > "${0%.md}.html"' {} \;

convert all the normal files in the current folder from dos format to unix format (remove extra characters at the end etc.) and save the output to a file
find . -type f -exec dos2unix {} {} \;

Counts all files in a current folder and subfolders.
find . -type f | wc -l

Counts lines of /dir/file.txt file.
cat /dir/file.txt | wc -l

Counts total lines in all *.php files in the current directory recursively
find . -name '*.php' -type f | xargs cat | wc -l

Count the number of lines in "/etc/fstab"
cat /etc/fstab | wc -l

Copy a comlex directory tree from one machine o another while preserving copy permissions and ownership
find . -depth -print | cpio -o -O /target/directory

Create a compressed archive of "/home" and split the contents into files with at most 4000 MiB each and use prefix "/media/DRIVENAME/BACKUPNAME.tgz"
tar --one-file-system -czv /home | split -b 4000m - /media/DRIVENAME/BACKUPNAME.tgz

create a tar ball of all the jpg and png images in the current folder
find . \( -iname "*.png" -o -iname "*.jpg" \) -print -exec tar -rf images.tar {} \;

Create directory `junk' in the home directory
find ~ -type d -exec mkdir junk {} \; 2> /dev/null

Create directorie(s) 'some/path' as required in the current directory
mkdir -p ./some/path

create directory /etc/cron.5minute
mkdir /etc/cron.5minute

create directory /tmp/new
mkdir /tmp/new

create directory new_dir
mkdir new_dir

create directory practice into home directory
mkdir ~/practice

create directory testExpress
mkdir testExpress

Delete all contents form the files that contain the case insensitive regex 'stringtofind' in maximum 1 level down the / directory excluding other partitions
find / -maxdepth 1 -xdev -type f -exec grep -Zli "stringtofind" {} + | parallel -0 sed "'/./d'" '{}'

Delete all contents form the files that contain the case insensitive regex 'stringtofind' in maximum 1 level down the / directory excluding other partitions
find / -maxdepth 1 -xdev -type f -exec grep -li "stringtofind" {} + | parallel sed "'/./d'" '{}'

Delete all regular files named 'FindCommandExamples.txt' under current directory tree
find . -type f -name "FindCommandExamples.txt" -exec rm -f {} \;

delete all the text files in the current folder.
find . -type f -name "*.txt" -exec rm -f {} \;

delete all the files in the current folder
find . -delete

Delete empty regular files
find . -type f -empty -delete

Delete orphan vim undo files under current directory
find . -type f -iname '*.un~' | while read UNDOFILE ; do FILE=$( echo "$UNDOFILE" | sed -r -e 's/.un~$//' -e 's&/\.([^/]*)&/\1&' ) ; [[ -e "$FILE" ]] || rm "$UNDOFILE" ; done

display all directories in current folder
find -type d

display all directories in current folder
find . -type d -print0

display all files in current folder
find .

display all files in the current folder while discarding the errors save the output to a file
find . 2>/dev/null >files_and_folders

display all instances of "foo.cpp" file in the current folder which are not in the sub directory tree ".svn"
find . -name 'foo.cpp' '!' -path '.svn'

display all the ".mov" video files in the current folder in the format filename and folder path
find . -iname "*.mov" -printf "%p %f\n"

display all the text files in the current folder and discard all the errors.
find -name "*.txt" 2>>/dev/null

display all the files in the current folder that are at least one week old (7 days) but less then 30 days old
find . -mtime +30 -a -mtime -7 -print0

display all the files in the file system which are changed a minute ago
find / -newerct '1 minute ago' -print

display all the files in the folders mydir1, mydir2 which are bigger than 2KB and have not been accessed in the last 30*24 hours
find /mydir1 /mydir2 -size +2000 -atime +30 -print

display all the regular/normal files in the folder "/home/user/demo" which have the permission 777.
find /home/user/demo -type f -perm 777 -print

display the file name and the file type of all the files in the current directory
find . -printf "%y %p\n"

Search /root/directory/to/search recursively for the files matching pattern 'filename.*'
find /root/directory/to/search -name 'filename.*'

Search directory /tmp/foo for files containing "/tmp/foo/bar" in their full names
find /tmp/foo -path /tmp/foo/bar -print

search for a folder junk in the home directory and create files cart1, cart2, cart3 ... cart6 in the folder junk. Discard all the errors.
find ~/junk -exec touch ~/junk/cart{1,2,3,4,5,6} {} \; 2> /dev/null

search for a regular/normal file "myfile" in the entire file system excluding the folder in excluded_path
find / -path excluded_path -prune -o -type f -name myfile -print

search for all the files in the current directory which have size greater than 10KB (approx) and less than 32KB(approx).
find . -size +10000c -size -32000c -print

search for all the files in the current folder which start with "my"
find . -name 'my*'

search for all the files with the name "dummy" in the current folder
find -type f -name dummy

Search for directory foo ignoring case
find . -iname foo -type d

Search for files bigger than 10M
find ~ -size +10M

Search for files whose name is "filename" and whose permissions are 777
find / -perm 777 -iname "filename"

search for files that are readable for everybody, have at least on write bit set but are not executable for anybody
find . -perm -444 -perm /222 ! -perm /111

Search for regular file foo ignoring case
find . -iname foo -type f

Search for the extended grep regex 'expr' in all files with '.c' and '.h' extension under current directory tree
find . -name '*.[ch]' | xargs grep -E 'expr'

search for the regular/normal file 'myfile' in the folder /root excluding those that are present in the "work" directory
find /root/ -name 'work' -prune -o -name myfile -type f -print

Search  in current directory downwards all files whic  have permission 777 .
find . -perm 777 -print

Search the /myfiles directory tree for regular files with read and write permissions set for `others'
find /myfiles -type f -perm -o+rw

Search the /path directory tree for files lacking the group writable bit
find /path ! -perm /020

Search the /path directory tree for files lacking the group writable bit
find /path ! -perm /g+w

Search the current directory and all subdirectories for files that have 777 permissions and the permissions to 755
find . -type f -perm 777 -exec chmod 755 {} \;

Search the current directory tree for *bash* files
find . -name "*bash*"

Search the current directory tree for files whose names start with "f"
find . -name f* -print

Search the directory tree given as variable $dir for regular files
find $dir -type f

Search the files from the current directory tree for "chrome"
find . -exec grep chrome {} +

Search the files from the current directory tree for "chrome"
find . -exec grep chrome {} \;

Search the files from the current directory tree for "chrome"
find . | xargs grep 'chrome'

Search the files from the current directory tree for "foo"
find . -exec grep -l foo {} +

Search the system for a file by its content limiting the search to regular files smaller than 10KB
find / -type f -size -10k 2>/dev/null -print0 | xargs -0 egrep '\bsomeknowncontent\b'

Enables 'nullglob' shell option.
shopt -s nullglob

Report all C language source code files under the current directory
find . -name \*.c -print

Find *.c and *.sh files
find . -type f \( -name "*.c" -o -name "*.sh" \)

Find *.conf files/directories only upto 2 levels down under /etc directory and show a few lines of output from the end
find /etc -maxdepth 2 -name "*.conf" | tail

Find a directory named 'project.images' case insensitively in the entire filesystem and show it in long listing format
find  / -type d -iname "project.images" -ls

Find all *.c files under /home
find /home -name "*.c"

Find all *.gz files in the current directory and decompress them using gunzip
find . -name '*.gz' -print0 | xargs -0 gunzip

Find all *.jpg files and copy them to /
find / -type f -name *.jpg  -exec cp {} . \;

Find all *.mp3 files in file system with more than 10MB and delete them using rm command
find / -type f -name *.mp3 -size +10M -exec rm {} \;

Find all *.txt files/directories under your home directory
find ~/ -name '*.txt'

Find all *.txt file (case insensitive) in the entire system and copy them to /tmp/txt
find / -iname '*.txt' | xargs --replace=@ cp @ /tmp/txt

Find all .log files in the /var/log directory tree and compress them using bzip2
find /var/log -name '*.log' | tar cv --files-from=- | bzip2 > log.tar.bz2

Find all .svn directories under current directory and delete them
find . -type d -name ".svn" -print | parallel rm -rf

Find all directories in current directory without going into sub-directories
find . -type d -maxdepth 1

Find all directories under mydir
find mydir -type d

find all directories named build under the current directory
find . -type d -name build

find all text files in the current directory
find . -name "*.txt" -print

find all files and directories that have been modified in the last seven days
find . -mtime -7

find all files in /usr/bin and run the "file" command on them.
find /usr/bin | xargs file

find all files in current folder which are bigger than 1 MB and move them to another folder after user confirmation
find . -size +1M -ok mv {} files \+

find all files in the current folder which have not been accessed in the last 30 days in the current folder
find . -atime +30 -print

find all files in the current folder with the permission 777 and modify the permissions as 755.
find . -type f -perm 777 -exec chmod 755 {} \;

Find all files/directories in entire file system with 644 permission
find / -perm 644

Find all files and directories in the current directory recursively that contain spaces in their names
find . -name '* *'

Find all files/directories under current directory tree whose paths start with './sr' and end with 'sc'
find . -path './sr*sc'

Find all files/directories under current directory with the null character as the delimiter
find -print0

Find all files/directories named 'apt' in the entrie filesystem
find  / -name "apt"

Find all files and directories whose names end in ".rpm", ignoring removable media, such as cdrom, floppy, etc.
find / -xdev -name \*.rpm

Find all files called wp-config.php in the /var/www directory and below
find /var/www/ -name wp-config.php

Find all files in the current directory tree and count them
find | wc -l

Find all files under $1 directory excluding hidden files and append a null character at the end of each of their paths
find "$1" -path "*/.*" -prune -o \( -type f -print0 \)

Find all files under current directory with 755 permission and change their permission to 644
find . -type f -perm 755 -exec chmod 644 {} \;

Find all files matching shell pattern "foo/bar" in the foo directory tree
find foo -path foo/bar -print

Find all files that belongs to user root under / directory and show a few lines of output from the beginning
find / -user root | head

Find all files that were last accessed more than 7 days ago under /home
find /home -atime +7

Find all files with the SUID bit set
find / -perm -u+s

Find and list all files on your current directory and show a few lines of output from the beginning
find | head

Find all PNG and JPG files and append them to archive `images.tar'
find . \( -iname "*.png" -o -iname "*.jpg" \) -print -exec tar -rf images.tar {} \;

Find and print all PDF files in the current directory and its sub-directories except for any found in the ./pdfs directory.
find . -name "*.pdf" -print | grep -v "^\./pdfs/"

Find and print the full pathname of all PDF files in the current directory and its sub-directories.
find . -name "*.pdf" -print

find all regular files which have been modified in the last 48 hours in home folder
find ~ -type f -mtime -2

Find all regular files in the entire filesystem that belong to the group 'users'
find /  -type f -group users

Find all subdirectories of the current directory and run comand "cmd2" for each of them
find -maxdepth 1 -type d | while read dir; do echo $dir; echo cmd2; done

Find and the 5 largest regular files in the Downloads folder of tecmint's home directory and output the file sizes in bytes.
find /home/tecmint/Downloads/ -type f -printf "%s %p\n" | sort -rn | head -n 5

find all the log files in the file system which are present in the current partition
find / -xdev -name "*.log"

find all the core files in the temp folder and force delete them
find /tmp -name core -type f -print | xargs /bin/rm -f

find all the directories in the folder $LOGDIR which have been modified in the last 5 days and delete them.
find $LOGDIR -type d -mtime +5 -exec rm -f {} \;

find all the text files in the entire filesystem which belong to the user root and display the ten files.
find / -user root -iname "*.txt" | head

find all the files in the home folder which have been modified today
find ~ -type f -mtime 0

find all the files in the current folder which have executable permission to all the users and display the ten files
find . -perm /a=x | head

find all the files in the current folder which have been accessed in the last 60 minutes
find . -amin -60

find all the files in the current folder which do not have the execute permission
find . -type d ! -perm -111

find all the files in the file system which have been modified in the last 60 minutes
find / -mmin -60

find all txt files under the current folder except ./misc folder
find . -path ./misc -prune -o -name '*.txt' -print

find all the files that have not been modified in the last 2 days
find -mtime +2

Find all the files in file system which are greater than 50MB and less than 100MB
find / -size +50M -size -100M

Find all the files that end with the extension “.java” in the current directoy tree
find . -name "*.java"

Find all the files which are changed in last 1 hour in entire file system and show a few lines of output from the beginning
find / -cmin -60 | head

Find all the files which are greater than 50MB and less than 100MB
find / -size +50M -size -100M

Find all the files which were modified 50 days ago
find / -mtime 50

find all the html files in the current folder which have not been modified in the last 7 days
find . -mtime +7 -name "*.html" -print

find all the html files in the current folder which have been modified exactly 7 days ago
find . -mtime 7 -name "*.html" -print

Find all the regular files under current directory tree that have not been modified in the last 31 days and delete them
find . -type f -mtime +31 -print0 | xargs -0 -r rm -f

Find all the Sticky Bit set files whose permission are 551
find / -perm 1551

find all the symbolic links in the current folder and check the file type and display the names of files which are broken
find . -type l -exec sh -c "file -b {} | grep -q ^broken" \; -print

find all the symbolic links in the current folder that are broken
find . -xtype l

find  case-insensitive StringBuffer in all *.java files
find . -type f -name "*.java" -exec grep -il string {} \;

Find every vim undo file in the current directory tree
find -type f -iname '*.un~'

Find every file/directory under the directory /home owned by the user joe
find /home -user joe

Find text in whole directory tree
find . -type f | xargs grep "text"

find files in the current directory and sub-directories, whose content was updated within the last hour
find . -mmin -60

find files under the current directory containing a space in the filename and delete them
find . -name "* *" -exec rm -f {} \;

find files which do not have all permissions to all the users in the current directory
find . -type f ! -perm 777 | head

Find files/directories in entire file system that had their meta information changed more than 3 days ago
find / -ctime +3

Find files/directories under /tmp smaller than 100 bytes
find /tmp -size -100c

Find files and directories modified in last 24 hours
find . -mtime 1

Find files in the current directory tree that were accessed within the last 60 minutes
find . -amin -60

find foo, Foo, FOo, FOO, etc., but only dirs
find . -iname foo -type d

Find only directories
find . -type d

find regular files in the "mail" folder under the user's home directory, displaying filenames and lines that contain the text "Linux"
find ~/mail -type f | xargs grep "Linux"

find the MyCProgram.c (case insensitive find) under the current directory and run the md5sum command against it
find -iname "MyCProgram.c" -exec md5sum {} \;

find the count of text files that are present in the current working directory.
find . -maxdepth 1 -name \*.txt -print0 | grep -cz .

Find the empty directories and files under current directory
find -empty

Find the file with inode number 211028 in the current dirrectory tree and move it to newname.dir
find . -inum 211028 -exec mv {} newname.dir \;

Find user daniel's files of type jpeg
find . -user daniel -type f -name *.jpg

Set 644 permission to all regular files under current directory
find . -type f -exec chmod 644 {} \;

Set 644 permission to all regular files under current directory
find . -type f -print0 | xargs -0 chmod 644

Set permissions to 700 for directories under media/
find media/ -type d -exec chmod 700 {} \;

Set permissions to ug=rwx,o= for directories under the $d directory tree
find $d -type d -exec chmod ug=rwx,o= '{}' \;

Set the read bit for "other" on all *rc.conf files in the current directory tree
find . -name "*rc.conf" -exec chmod o+r '{}' \;

get the root access
sudo su

Set variable "finalName" to the second-to-last slash-separated path component of variable "path"
finalName=$(basename -- "$(dirname -- "$path")")

Identify files that do not have a listing in the /etc/passwd or /etc/group file
find / -nouser -o  -nogroup

list *.bmp and *.txt files under the /home/user/Desktop directory.
find /home/user/Desktop -name '*.bmp' -o -name '*.txt'

List all *.png files/directories under /home/kibab directory
find /home/kibab -name '*.png' -exec echo '{}' ';'

list all java file that StringBuff in context.
find . -type f -name "*.java" -exec grep -l StringBuffer {} \;

list all files under the current directory, writing the output to the file files_and_folders
find . > files_and_folders

List all files from the current directory tree that were modified less than 60 minutes ago, omitting "."
find . -mindepth 1 -mmin -60 | xargs -r ls -ld

List all regular files from the current directory tree that were modified less than 60 minutes ago
find . -mmin -60 -type f -exec ls -l {} \;

List all regular files from the current directory tree that were modified less than 60 minutes ago
find . -mmin -60 -type f -ls

List all regular files from the current directory tree that were modified less than 60 minutes ago
find . -mmin -60 -type f | xargs ls -l

List all the file links
find . -type l

List in detail all *.txt files in the current directory tree, omitting paths ./Movies/*, ./Downloads/*, and ./Music/*
find . -type f -name "*.txt" ! -path "./Movies/*" ! -path "./Downloads/*" ! -path "./Music/*" -ls

list the regular files in your home directory that were modified yesterday
find ~/ -daystart -type f -mtime 1

List the regular files of the current directory tree that contain string "texthere"
find -type f -exec grep -l "texthere" {} +

List the z* links in the /usr/bin directory and the file to which it points to
find /usr/bin  -type l  -name "z*" -exec ls  -l {} \;

Locate all *.txt files in the current directory tree
find . -name "*.txt"

Make directory "dirname" with permissions set to 777
mkdir -m 777 dirname

Measure the disk space taken up by all *.txt files in the current directory tree
find . -name "*.txt" -print0 |xargs -0 du -ch

Print git branch currently checked out in a working directory.
git status | head -1 | cut -d ' ' -f 3

Print the contents of all ".py" on the file system as input to "tqdm --unit loc --unit_scale True | wc -l"
find / -name '*.py' -exec cat \{} \; | tqdm --unit loc --unit_scale True | wc -l

Print the current directory
find -maxdepth 0

Print the current directory
find -prune

Print the grand total file system disk space usage with block sizes in units of TiB
df --total -BT | tail -n 1

Print the last 10 lines of '/var/log/syslog', printing out any additional data appended to the file
tail -f /var/log/syslog

Print the list of directories residing in the current directory tree
find . -type d -exec ls -ld {} \;

prints the names of all files in the directory tree rooted in /usr/src whose name ends with ‘.c’ and that are larger than 100 Kilobytes.
find /usr/src -name '*.c' -size +100k -print

Print the second space separated fields from standard input
tr -s ' ' | cut -d ' ' -f 2

Print the size for every *.ogg file found under the home directory
find $HOME -name '*.ogg' -type f -exec du -h '{}' \;

Recursively copies everything from '/zzz/zzz/' to the '/xxx/xxx' overwriting the existing files and answering 'yes' on each request for overwriting.
yes | cp -rf /zzz/zzz/* /xxx/xxx

Recursively search for all regular files below directory "dir1" in currentd directory, and output the name of each, without any containing directories.
find ./dir1 -type f -exec basename {} \;

Recursively finds in all folders but "./output/*" all files but *.o, *.swp and prints strings with 'soc_attach' text pattern and number of matched string.
find .  \( ! -path "./output/*" \) -a \( -type f \) -a \( ! -name '*.o' \) -a \( ! -name '*.swp' \) | xargs grep -n soc_attach

Recursively removes all files and folders named '.svn' in a current folder, handling content of removed folder before folder inself.
find . -depth -name .svn -exec rm -fr {} \;

Remove all *.doc files from the current directory tree
find . -name '*.doc' -exec rm "{}" \;

remove all the files with the name "Trash" in the folder /home
find /home -name Trash -exec rm {} \;

Remove junk files modified more than 31 days ago recursively
find /path/to/junk/files -type f -mtime +31 -exec rm -f {} \;

recursively change owner and group of the directory  /vol/html and all files into it to user ec2-user and group apache
sudo chown -R ec2-user:apache /vol/html

recursively change owner of the directory /usr/local to the current user
sudo chown -R `whoami` /usr/local

Return a list of files newer than file poop
find . -mnewer poop

Write the list of all files on the system to "masterfilelist.out"
find  /   -print > masterfilelist.out

Searches through the /usr/local directory for files that end with the extension .html. When these files are found, their permission is changed to mode 644 (rw-r--r--).
find /usr/local -name "*.html" -type f -exec chmod 644 {} \;

Show a listing of files not modified in over 20 days or not accessed in over 40 days
find /mydir \(-mtime +20 -o -atime +40\) -exec ls -l {} \;

show all files in /usr/tom and display only files ending with ".pl" or ".pm"
find /usr/tom | egrep '*.pl| *.pm'

show all the files  in current directory
find .

show all the regular files in current folder
find . -type f -print0

Show ls's detailed output for all files named "something"
find . -name something -exec ls -l {} \;

Show manual page of find utility
man find

Simulate a full login
su -

Split a file "file.tar.gz" into pieces named as "file.tar.gz.part-NNN" with size 1024 MB where NNN is a numeric suffix
split -b 1024m "file.tar.gz" "file.tar.gz.part-"

Split the contents of all ".txt" excluding the first 1000 lines into files of at most 1000 lines each
cat *.txt | tail -n +1001 | split --lines=1000

Truncates file $file, removing last line from it.
tail -n 1 "$file" | wc -c | xargs -I {} truncate "$file" -s -{}

run ls command on files found
find . -name "*.pl" -exec ls -ld {} \;

update the permission of all the php files in current directory and save the output to a file
find . -name '*.php' -exec chmod 755 {} \; | tee logfile.txt

